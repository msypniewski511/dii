var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to3, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to3, key) && key !== except)
        __defProp(to3, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to3;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@rails/actioncable/src/adapters.js
var adapters_default;
var init_adapters = __esm({
  "node_modules/@rails/actioncable/src/adapters.js"() {
    adapters_default = {
      logger: typeof console !== "undefined" ? console : void 0,
      WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
    };
  }
});

// node_modules/@rails/actioncable/src/logger.js
var logger_default;
var init_logger = __esm({
  "node_modules/@rails/actioncable/src/logger.js"() {
    init_adapters();
    logger_default = {
      log(...messages) {
        if (this.enabled) {
          messages.push(Date.now());
          adapters_default.logger.log("[ActionCable]", ...messages);
        }
      }
    };
  }
});

// node_modules/@rails/actioncable/src/connection_monitor.js
var now, secondsSince, ConnectionMonitor, connection_monitor_default;
var init_connection_monitor = __esm({
  "node_modules/@rails/actioncable/src/connection_monitor.js"() {
    init_logger();
    now = () => (/* @__PURE__ */ new Date()).getTime();
    secondsSince = (time) => (now() - time) / 1e3;
    ConnectionMonitor = class {
      constructor(connection) {
        this.visibilityDidChange = this.visibilityDidChange.bind(this);
        this.connection = connection;
        this.reconnectAttempts = 0;
      }
      start() {
        if (!this.isRunning()) {
          this.startedAt = now();
          delete this.stoppedAt;
          this.startPolling();
          addEventListener("visibilitychange", this.visibilityDidChange);
          logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
        }
      }
      stop() {
        if (this.isRunning()) {
          this.stoppedAt = now();
          this.stopPolling();
          removeEventListener("visibilitychange", this.visibilityDidChange);
          logger_default.log("ConnectionMonitor stopped");
        }
      }
      isRunning() {
        return this.startedAt && !this.stoppedAt;
      }
      recordMessage() {
        this.pingedAt = now();
      }
      recordConnect() {
        this.reconnectAttempts = 0;
        delete this.disconnectedAt;
        logger_default.log("ConnectionMonitor recorded connect");
      }
      recordDisconnect() {
        this.disconnectedAt = now();
        logger_default.log("ConnectionMonitor recorded disconnect");
      }
      // Private
      startPolling() {
        this.stopPolling();
        this.poll();
      }
      stopPolling() {
        clearTimeout(this.pollTimeout);
      }
      poll() {
        this.pollTimeout = setTimeout(
          () => {
            this.reconnectIfStale();
            this.poll();
          },
          this.getPollInterval()
        );
      }
      getPollInterval() {
        const { staleThreshold, reconnectionBackoffRate } = this.constructor;
        const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
        const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
        const jitter = jitterMax * Math.random();
        return staleThreshold * 1e3 * backoff * (1 + jitter);
      }
      reconnectIfStale() {
        if (this.connectionIsStale()) {
          logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
          this.reconnectAttempts++;
          if (this.disconnectedRecently()) {
            logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
          } else {
            logger_default.log("ConnectionMonitor reopening");
            this.connection.reopen();
          }
        }
      }
      get refreshedAt() {
        return this.pingedAt ? this.pingedAt : this.startedAt;
      }
      connectionIsStale() {
        return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
      }
      disconnectedRecently() {
        return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
      }
      visibilityDidChange() {
        if (document.visibilityState === "visible") {
          setTimeout(
            () => {
              if (this.connectionIsStale() || !this.connection.isOpen()) {
                logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                this.connection.reopen();
              }
            },
            200
          );
        }
      }
    };
    ConnectionMonitor.staleThreshold = 6;
    ConnectionMonitor.reconnectionBackoffRate = 0.15;
    connection_monitor_default = ConnectionMonitor;
  }
});

// node_modules/@rails/actioncable/src/internal.js
var internal_default;
var init_internal = __esm({
  "node_modules/@rails/actioncable/src/internal.js"() {
    internal_default = {
      "message_types": {
        "welcome": "welcome",
        "disconnect": "disconnect",
        "ping": "ping",
        "confirmation": "confirm_subscription",
        "rejection": "reject_subscription"
      },
      "disconnect_reasons": {
        "unauthorized": "unauthorized",
        "invalid_request": "invalid_request",
        "server_restart": "server_restart",
        "remote": "remote"
      },
      "default_mount_path": "/cable",
      "protocols": [
        "actioncable-v1-json",
        "actioncable-unsupported"
      ]
    };
  }
});

// node_modules/@rails/actioncable/src/connection.js
var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
var init_connection = __esm({
  "node_modules/@rails/actioncable/src/connection.js"() {
    init_adapters();
    init_connection_monitor();
    init_internal();
    init_logger();
    ({ message_types, protocols } = internal_default);
    supportedProtocols = protocols.slice(0, protocols.length - 1);
    indexOf = [].indexOf;
    Connection = class {
      constructor(consumer2) {
        this.open = this.open.bind(this);
        this.consumer = consumer2;
        this.subscriptions = this.consumer.subscriptions;
        this.monitor = new connection_monitor_default(this);
        this.disconnected = true;
      }
      send(data) {
        if (this.isOpen()) {
          this.webSocket.send(JSON.stringify(data));
          return true;
        } else {
          return false;
        }
      }
      open() {
        if (this.isActive()) {
          logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
          return false;
        } else {
          const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
          logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
          if (this.webSocket) {
            this.uninstallEventHandlers();
          }
          this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
          this.installEventHandlers();
          this.monitor.start();
          return true;
        }
      }
      close({ allowReconnect } = { allowReconnect: true }) {
        if (!allowReconnect) {
          this.monitor.stop();
        }
        if (this.isOpen()) {
          return this.webSocket.close();
        }
      }
      reopen() {
        logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
        if (this.isActive()) {
          try {
            return this.close();
          } catch (error2) {
            logger_default.log("Failed to reopen WebSocket", error2);
          } finally {
            logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
            setTimeout(this.open, this.constructor.reopenDelay);
          }
        } else {
          return this.open();
        }
      }
      getProtocol() {
        if (this.webSocket) {
          return this.webSocket.protocol;
        }
      }
      isOpen() {
        return this.isState("open");
      }
      isActive() {
        return this.isState("open", "connecting");
      }
      triedToReconnect() {
        return this.monitor.reconnectAttempts > 0;
      }
      // Private
      isProtocolSupported() {
        return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
      }
      isState(...states) {
        return indexOf.call(states, this.getState()) >= 0;
      }
      getState() {
        if (this.webSocket) {
          for (let state in adapters_default.WebSocket) {
            if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
              return state.toLowerCase();
            }
          }
        }
        return null;
      }
      installEventHandlers() {
        for (let eventName in this.events) {
          const handler = this.events[eventName].bind(this);
          this.webSocket[`on${eventName}`] = handler;
        }
      }
      uninstallEventHandlers() {
        for (let eventName in this.events) {
          this.webSocket[`on${eventName}`] = function() {
          };
        }
      }
    };
    Connection.reopenDelay = 500;
    Connection.prototype.events = {
      message(event2) {
        if (!this.isProtocolSupported()) {
          return;
        }
        const { identifier, message, reason, reconnect, type } = JSON.parse(event2.data);
        this.monitor.recordMessage();
        switch (type) {
          case message_types.welcome:
            if (this.triedToReconnect()) {
              this.reconnectAttempted = true;
            }
            this.monitor.recordConnect();
            return this.subscriptions.reload();
          case message_types.disconnect:
            logger_default.log(`Disconnecting. Reason: ${reason}`);
            return this.close({ allowReconnect: reconnect });
          case message_types.ping:
            return null;
          case message_types.confirmation:
            this.subscriptions.confirmSubscription(identifier);
            if (this.reconnectAttempted) {
              this.reconnectAttempted = false;
              return this.subscriptions.notify(identifier, "connected", { reconnected: true });
            } else {
              return this.subscriptions.notify(identifier, "connected", { reconnected: false });
            }
          case message_types.rejection:
            return this.subscriptions.reject(identifier);
          default:
            return this.subscriptions.notify(identifier, "received", message);
        }
      },
      open() {
        logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
        this.disconnected = false;
        if (!this.isProtocolSupported()) {
          logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
          return this.close({ allowReconnect: false });
        }
      },
      close(event2) {
        logger_default.log("WebSocket onclose event");
        if (this.disconnected) {
          return;
        }
        this.disconnected = true;
        this.monitor.recordDisconnect();
        return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
      },
      error() {
        logger_default.log("WebSocket onerror event");
      }
    };
    connection_default = Connection;
  }
});

// node_modules/@rails/actioncable/src/subscription.js
var extend, Subscription;
var init_subscription = __esm({
  "node_modules/@rails/actioncable/src/subscription.js"() {
    extend = function(object, properties) {
      if (properties != null) {
        for (let key in properties) {
          const value = properties[key];
          object[key] = value;
        }
      }
      return object;
    };
    Subscription = class {
      constructor(consumer2, params = {}, mixin) {
        this.consumer = consumer2;
        this.identifier = JSON.stringify(params);
        extend(this, mixin);
      }
      // Perform a channel action with the optional data passed as an attribute
      perform(action, data = {}) {
        data.action = action;
        return this.send(data);
      }
      send(data) {
        return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
      }
      unsubscribe() {
        return this.consumer.subscriptions.remove(this);
      }
    };
  }
});

// node_modules/@rails/actioncable/src/subscription_guarantor.js
var SubscriptionGuarantor, subscription_guarantor_default;
var init_subscription_guarantor = __esm({
  "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
    init_logger();
    SubscriptionGuarantor = class {
      constructor(subscriptions) {
        this.subscriptions = subscriptions;
        this.pendingSubscriptions = [];
      }
      guarantee(subscription) {
        if (this.pendingSubscriptions.indexOf(subscription) == -1) {
          logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
          this.pendingSubscriptions.push(subscription);
        } else {
          logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
        }
        this.startGuaranteeing();
      }
      forget(subscription) {
        logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
        this.pendingSubscriptions = this.pendingSubscriptions.filter((s4) => s4 !== subscription);
      }
      startGuaranteeing() {
        this.stopGuaranteeing();
        this.retrySubscribing();
      }
      stopGuaranteeing() {
        clearTimeout(this.retryTimeout);
      }
      retrySubscribing() {
        this.retryTimeout = setTimeout(
          () => {
            if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
              this.pendingSubscriptions.map((subscription) => {
                logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                this.subscriptions.subscribe(subscription);
              });
            }
          },
          500
        );
      }
    };
    subscription_guarantor_default = SubscriptionGuarantor;
  }
});

// node_modules/@rails/actioncable/src/subscriptions.js
var Subscriptions;
var init_subscriptions = __esm({
  "node_modules/@rails/actioncable/src/subscriptions.js"() {
    init_subscription();
    init_subscription_guarantor();
    init_logger();
    Subscriptions = class {
      constructor(consumer2) {
        this.consumer = consumer2;
        this.guarantor = new subscription_guarantor_default(this);
        this.subscriptions = [];
      }
      create(channelName, mixin) {
        const channel = channelName;
        const params = typeof channel === "object" ? channel : { channel };
        const subscription = new Subscription(this.consumer, params, mixin);
        return this.add(subscription);
      }
      // Private
      add(subscription) {
        this.subscriptions.push(subscription);
        this.consumer.ensureActiveConnection();
        this.notify(subscription, "initialized");
        this.subscribe(subscription);
        return subscription;
      }
      remove(subscription) {
        this.forget(subscription);
        if (!this.findAll(subscription.identifier).length) {
          this.sendCommand(subscription, "unsubscribe");
        }
        return subscription;
      }
      reject(identifier) {
        return this.findAll(identifier).map((subscription) => {
          this.forget(subscription);
          this.notify(subscription, "rejected");
          return subscription;
        });
      }
      forget(subscription) {
        this.guarantor.forget(subscription);
        this.subscriptions = this.subscriptions.filter((s4) => s4 !== subscription);
        return subscription;
      }
      findAll(identifier) {
        return this.subscriptions.filter((s4) => s4.identifier === identifier);
      }
      reload() {
        return this.subscriptions.map((subscription) => this.subscribe(subscription));
      }
      notifyAll(callbackName, ...args) {
        return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
      }
      notify(subscription, callbackName, ...args) {
        let subscriptions;
        if (typeof subscription === "string") {
          subscriptions = this.findAll(subscription);
        } else {
          subscriptions = [subscription];
        }
        return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
      }
      subscribe(subscription) {
        if (this.sendCommand(subscription, "subscribe")) {
          this.guarantor.guarantee(subscription);
        }
      }
      confirmSubscription(identifier) {
        logger_default.log(`Subscription confirmed ${identifier}`);
        this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
      }
      sendCommand(subscription, command) {
        const { identifier } = subscription;
        return this.consumer.send({ command, identifier });
      }
    };
  }
});

// node_modules/@rails/actioncable/src/consumer.js
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a4 = document.createElement("a");
    a4.href = url;
    a4.href = a4.href;
    a4.protocol = a4.protocol.replace("http", "ws");
    return a4.href;
  } else {
    return url;
  }
}
var Consumer;
var init_consumer = __esm({
  "node_modules/@rails/actioncable/src/consumer.js"() {
    init_connection();
    init_subscriptions();
    Consumer = class {
      constructor(url) {
        this._url = url;
        this.subscriptions = new Subscriptions(this);
        this.connection = new connection_default(this);
        this.subprotocols = [];
      }
      get url() {
        return createWebSocketURL(this._url);
      }
      send(data) {
        return this.connection.send(data);
      }
      connect() {
        return this.connection.open();
      }
      disconnect() {
        return this.connection.close({ allowReconnect: false });
      }
      ensureActiveConnection() {
        if (!this.connection.isActive()) {
          return this.connection.open();
        }
      }
      addSubProtocol(subprotocol) {
        this.subprotocols = [...this.subprotocols, subprotocol];
      }
    };
  }
});

// node_modules/@rails/actioncable/src/index.js
var src_exports = {};
__export(src_exports, {
  Connection: () => connection_default,
  ConnectionMonitor: () => connection_monitor_default,
  Consumer: () => Consumer,
  INTERNAL: () => internal_default,
  Subscription: () => Subscription,
  SubscriptionGuarantor: () => subscription_guarantor_default,
  Subscriptions: () => Subscriptions,
  adapters: () => adapters_default,
  createConsumer: () => createConsumer,
  createWebSocketURL: () => createWebSocketURL,
  getConfig: () => getConfig,
  logger: () => logger_default
});
function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}
var init_src = __esm({
  "node_modules/@rails/actioncable/src/index.js"() {
    init_connection();
    init_connection_monitor();
    init_consumer();
    init_internal();
    init_subscription();
    init_subscriptions();
    init_subscription_guarantor();
    init_adapters();
    init_logger();
  }
});

// node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "node_modules/jquery/dist/jquery.js"(exports, module) {
    (function(global, factory) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w5) {
          if (!w5.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w5);
        };
      } else {
        factory(global);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push = arr.push;
      var indexOf2 = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction2 = function isFunction3(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code, node, doc) {
        doc = doc || document2;
        var i4, val, script = doc.createElement("script");
        script.text = code;
        if (node) {
          for (i4 in preservedScriptAttributes) {
            val = node[i4] || node.getAttribute && node.getAttribute(i4);
            if (val) {
              script.setAttribute(i4, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
        return new jQuery2.fn.init(selector, context);
      };
      jQuery2.fn = jQuery2.prototype = {
        // The current version of jQuery being used
        jquery: version2,
        constructor: jQuery2,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery2.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback2) {
          return jQuery2.each(this, callback2);
        },
        map: function(callback2) {
          return this.pushStack(jQuery2.map(this, function(elem, i4) {
            return callback2.call(elem, i4, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i4) {
            return (i4 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i4) {
            return i4 % 2;
          }));
        },
        eq: function(i4) {
          var len = this.length, j5 = +i4 + (i4 < 0 ? len : 0);
          return this.pushStack(j5 >= 0 && j5 < len ? [this[j5]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery2.extend = jQuery2.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone3, target = arguments[0] || {}, i4 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i4] || {};
          i4++;
        }
        if (typeof target !== "object" && !isFunction2(target)) {
          target = {};
        }
        if (i4 === length) {
          target = this;
          i4--;
        }
        for (; i4 < length; i4++) {
          if ((options = arguments[i4]) != null) {
            for (name in options) {
              copy = options[name];
              if (name === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone3 = [];
                } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                  clone3 = {};
                } else {
                  clone3 = src;
                }
                copyIsArray = false;
                target[name] = jQuery2.extend(deep, clone3, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery2.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
          DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback2) {
          var length, i4 = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i4 < length; i4++) {
              if (callback2.call(obj[i4], i4, obj[i4]) === false) {
                break;
              }
            }
          } else {
            for (i4 in obj) {
              if (callback2.call(obj[i4], i4, obj[i4]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i4 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i4++]) {
              ret += jQuery2.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery2.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i4) {
          return arr2 == null ? -1 : indexOf2.call(arr2, elem, i4);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
          var len = +second.length, j5 = 0, i4 = first.length;
          for (; j5 < len; j5++) {
            first[i4++] = second[j5];
          }
          first.length = i4;
          return first;
        },
        grep: function(elems, callback2, invert) {
          var callbackInverse, matches2 = [], i4 = 0, length = elems.length, callbackExpect = !invert;
          for (; i4 < length; i4++) {
            callbackInverse = !callback2(elems[i4], i4);
            if (callbackInverse !== callbackExpect) {
              matches2.push(elems[i4]);
            }
          }
          return matches2;
        },
        // arg is for internal usage only
        map: function(elems, callback2, arg) {
          var length, value, i4 = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i4 < length; i4++) {
              value = callback2(elems[i4], i4, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i4 in elems) {
              value = callback2(elems[i4], i4, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery2.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i2, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction2(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery2.contains = function(a4, b4) {
        var bup = b4 && b4.parentNode;
        return a4 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a4.contains ? a4.contains(bup) : a4.compareDocumentPosition && a4.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery2.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push;
      (function() {
        var i4, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches2, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a4, b4) {
          if (a4 === b4) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push2.apply(
            arr = slice.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e4) {
          push2 = {
            apply: function(target, els) {
              pushNative.apply(target, slice.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice.call(arguments, 1));
            }
          };
        }
        function find(selector, context, results, seed) {
          var m5, i5, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m5 = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m5)) {
                      if (elem.id === m5) {
                        push2.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m5)) && find.contains(context, elem) && elem.id === m5) {
                      push2.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m5 = match[3]) && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m5));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery2.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize2(selector);
                  i5 = groups.length;
                  while (i5--) {
                    groups[i5] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i5]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache2(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache2[keys.shift()];
            }
            return cache2[key + " "] = value;
          }
          return cache2;
        }
        function markFunction(fn2) {
          fn2[expando] = true;
          return fn2;
        }
        function assert(fn2) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn2(el);
          } catch (e4) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn2) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches3) {
              var j5, matchIndexes = fn2([], seed.length, argument), i5 = matchIndexes.length;
              while (i5--) {
                if (seed[j5 = matchIndexes[i5]]) {
                  seed[j5] = !(matches3[j5] = seed[j5]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery2.isXMLDoc(document3);
          matches2 = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery2.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches2.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e4) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id2);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i5, elems, elem = context.getElementById(id2);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id2) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id2);
                  i5 = 0;
                  while (elem = elems[i5++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id2) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className2, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className2);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a4, b4) {
            if (a4 === b4) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a4.compareDocumentPosition - !b4.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a4.ownerDocument || a4) == (b4.ownerDocument || b4) ? a4.compareDocumentPosition(b4) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support.sortDetached && b4.compareDocumentPosition(a4) === compare) {
              if (a4 === document3 || a4.ownerDocument == preferredDoc && find.contains(preferredDoc, a4)) {
                return -1;
              }
              if (b4 === document3 || b4.ownerDocument == preferredDoc && find.contains(preferredDoc, b4)) {
                return 1;
              }
              return sortInput ? indexOf2.call(sortInput, a4) - indexOf2.call(sortInput, b4) : 0;
            }
            return compare & 4 ? -1 : 1;
          };
          return document3;
        }
        find.matches = function(expr, elements2) {
          return find(expr, null, null, elements2);
        };
        find.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches2.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e4) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find(expr, document3, null, [elem]).length > 0;
        };
        find.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery2.contains(context, elem);
        };
        find.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name);
        };
        find.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery2.uniqueSort = function(results) {
          var elem, duplicates = [], j5 = 0, i5 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i5++]) {
              if (elem === results[i5]) {
                j5 = duplicates.push(i5);
              }
            }
            while (j5--) {
              splice.call(results, duplicates[j5], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery2.fn.uniqueSort = function() {
          return this.pushStack(jQuery2.uniqueSort(slice.apply(this)));
        };
        Expr = jQuery2.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className2) {
              var pattern = classCache[className2 + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className2 + "(" + whitespace + "|$)")) && classCache(className2, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name, operator, check) {
              return function(elem) {
                var result = find.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                if (operator === "=") {
                  return result === check;
                }
                if (operator === "!=") {
                  return result !== check;
                }
                if (operator === "^=") {
                  return check && result.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result === check || result.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache2, outerCache, node, nodeIndex, start4, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start4 = dir2 = type === "only" && !start4 && "nextSibling";
                    }
                    return true;
                  }
                  start4 = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache2 = outerCache[type] || [];
                    nodeIndex = cache2[0] === dirruns && cache2[1];
                    diff = nodeIndex && cache2[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start4.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start4.pop()) {
                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
              if (fn2[expando]) {
                return fn2(argument);
              }
              if (fn2.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches3) {
                  var idx, matched = fn2(seed, argument), i5 = matched.length;
                  while (i5--) {
                    idx = indexOf2.call(seed, matched[i5]);
                    seed[idx] = !(matches3[idx] = matched[i5]);
                  }
                }) : function(elem) {
                  return fn2(elem, 0, args);
                };
              }
              return fn2;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches3, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i5 = seed.length;
                while (i5--) {
                  if (elem = unmatched[i5]) {
                    seed[i5] = !(matches3[i5] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery2.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i5 = 0;
              for (; i5 < length; i5 += 2) {
                matchIndexes.push(i5);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i5 = 1;
              for (; i5 < length; i5 += 2) {
                matchIndexes.push(i5);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i5;
              if (argument < 0) {
                i5 = argument + length;
              } else if (argument > length) {
                i5 = length;
              } else {
                i5 = argument;
              }
              for (; --i5 >= 0; ) {
                matchIndexes.push(i5);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i5 = argument < 0 ? argument + length : argument;
              for (; ++i5 < length; ) {
                matchIndexes.push(i5);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i4 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i4] = createInputPseudo(i4);
        }
        for (i4 in { submit: true, reset: true }) {
          Expr.pseudos[i4] = createButtonPseudo(i4);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize2(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i5 = 0, len = tokens.length, selector = "";
          for (; i5 < len; i5++) {
            selector += tokens[i5].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip2 = combinator.next, key = skip2 || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip2 && nodeName(elem, skip2)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i5 = matchers.length;
            while (i5--) {
              if (!matchers[i5](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i5 = 0, len = contexts.length;
          for (; i5 < len; i5++) {
            find(selector, contexts[i5], results);
          }
          return results;
        }
        function condense(unmatched, map3, filter, context, xml) {
          var elem, newUnmatched = [], i5 = 0, len = unmatched.length, mapped = map3 != null;
          for (; i5 < len; i5++) {
            if (elem = unmatched[i5]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map3.push(i5);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i5, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i5 = temp.length;
              while (i5--) {
                if (elem = temp[i5]) {
                  matcherOut[postMap[i5]] = !(matcherIn[postMap[i5]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i5 = matcherOut.length;
                  while (i5--) {
                    if (elem = matcherOut[i5]) {
                      temp.push(matcherIn[i5] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i5 = matcherOut.length;
                while (i5--) {
                  if ((elem = matcherOut[i5]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i5]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j5, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i5 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf2.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i5 < len; i5++) {
            if (matcher = Expr.relative[tokens[i5].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i5].type].apply(null, tokens[i5].matches);
              if (matcher[expando]) {
                j5 = ++i5;
                for (; j5 < len; j5++) {
                  if (Expr.relative[tokens[j5].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i5 > 1 && elementMatcher(matchers),
                  i5 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i5 - 1).concat({ value: tokens[i5 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher,
                  i5 < j5 && matcherFromTokens(tokens.slice(i5, j5)),
                  j5 < len && matcherFromTokens(tokens = tokens.slice(j5)),
                  j5 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j5, matcher, matchedCount = 0, i5 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i5 !== len && (elem = elems[i5]) != null; i5++) {
              if (byElement && elem) {
                j5 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j5++]) {
                  if (matcher(elem, context || document3, xml)) {
                    push2.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i5;
            if (bySet && i5 !== matchedCount) {
              j5 = 0;
              while (matcher = setMatchers[j5++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i5--) {
                    if (!(unmatched[i5] || setMatched[i5])) {
                      setMatched[i5] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i5, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize2(selector);
            }
            i5 = match.length;
            while (i5--) {
              cached = matcherFromTokens(match[i5]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select(selector, context, results, seed) {
          var i5, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i5 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i5--) {
              token = tokens[i5];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find2 = Expr.find[type]) {
                if (seed = find2(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i5, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery2.find = find;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.unique = jQuery2.uniqueSort;
        find.compile = compile;
        find.select = select;
        find.setDocument = setDocument;
        find.tokenize = tokenize2;
        find.escape = jQuery2.escapeSelector;
        find.getText = jQuery2.text;
        find.isXML = jQuery2.isXMLDoc;
        find.selectors = jQuery2.expr;
        find.support = jQuery2.support;
        find.uniqueSort = jQuery2.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery2(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n3, elem) {
        var matched = [];
        for (; n3; n3 = n3.nextSibling) {
          if (n3.nodeType === 1 && n3 !== elem) {
            matched.push(n3);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery2.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements2, qualifier, not) {
        if (isFunction2(qualifier)) {
          return jQuery2.grep(elements2, function(elem, i4) {
            return !!qualifier.call(elem, i4, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery2.grep(elements2, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery2.grep(elements2, function(elem) {
            return indexOf2.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery2.filter(qualifier, elements2, not);
      }
      jQuery2.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery2.fn.extend({
        find: function(selector) {
          var i4, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery2(selector).filter(function() {
              for (i4 = 0; i4 < len; i4++) {
                if (jQuery2.contains(self2[i4], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i4 = 0; i4 < len; i4++) {
            jQuery2.find(selector, self2[i4], ret);
          }
          return len > 1 ? jQuery2.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery2 ? context[0] : context;
              jQuery2.merge(this, jQuery2.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction2(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction2(selector)) {
          return root.ready !== void 0 ? root.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery2)
          );
        }
        return jQuery2.makeArray(selector, this);
      };
      init.prototype = jQuery2.fn;
      rootjQuery = jQuery2(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery2.fn.extend({
        has: function(target) {
          var targets = jQuery2(target, this), l4 = targets.length;
          return this.filter(function() {
            var i4 = 0;
            for (; i4 < l4; i4++) {
              if (jQuery2.contains(this, targets[i4])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i4 = 0, l4 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i4 < l4; i4++) {
              for (cur = this[i4]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf2.call(jQuery2(elem), this[0]);
          }
          return indexOf2.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery2.uniqueSort(
              jQuery2.merge(this.get(), jQuery2(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery2.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i2, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i2, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i2, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery2.merge([], elem.childNodes);
        }
      }, function(name, fn2) {
        jQuery2.fn[name] = function(until, selector) {
          var matched = jQuery2.map(this, fn2, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery2.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery2.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object = {};
        jQuery2.each(options.match(rnothtmlwhite) || [], function(_4, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery2.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire2 = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add2(args) {
                jQuery2.each(args, function(_4, arg) {
                  if (isFunction2(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add2(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire2();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery2.each(arguments, function(_4, arg) {
              var index4;
              while ((index4 = jQuery2.inArray(arg, list, index4)) > -1) {
                list.splice(index4, 1);
                if (index4 <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn2) {
            return fn2 ? jQuery2.inArray(fn2, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire2();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v4) {
        return v4;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve2, reject, noValue) {
        var method;
        try {
          if (value && isFunction2(method = value.promise)) {
            method.call(value).done(resolve2).fail(reject);
          } else if (value && isFunction2(method = value.then)) {
            method.call(value, resolve2, reject);
          } else {
            resolve2.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject.apply(void 0, [value2]);
        }
      }
      jQuery2.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery2.Callbacks("memory"),
              jQuery2.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn2) {
              return promise.then(null, fn2);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery2.Deferred(function(newDefer) {
                jQuery2.each(tuples, function(_i2, tuple) {
                  var fn2 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn2 && fn2.apply(this, arguments);
                    if (returned && isFunction2(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn2 ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve2(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction2(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve2(maxDepth, deferred2, Identity, special),
                          resolve2(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve2(maxDepth, deferred2, Identity, special),
                          resolve2(maxDepth, deferred2, Thrower, special),
                          resolve2(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e4) {
                      if (jQuery2.Deferred.exceptionHook) {
                        jQuery2.Deferred.exceptionHook(
                          e4,
                          process.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e4];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery2.Deferred.getErrorHook) {
                      process.error = jQuery2.Deferred.getErrorHook();
                    } else if (jQuery2.Deferred.getStackHook) {
                      process.error = jQuery2.Deferred.getStackHook();
                    }
                    window2.setTimeout(process);
                  }
                };
              }
              return jQuery2.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction2(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction2(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve2(
                    0,
                    newDefer,
                    isFunction2(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery2.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery2.each(tuples, function(i4, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i4][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i4][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i4 = remaining, resolveContexts = Array(i4), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i5) {
            return function(value) {
              resolveContexts[i5] = this;
              resolveValues[i5] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i4)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction2(resolveValues[i4] && resolveValues[i4].then)) {
              return primary.then();
            }
          }
          while (i4--) {
            adoptValue(resolveValues[i4], updateFunc(i4), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery2.Deferred.exceptionHook = function(error2, asyncError) {
        if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error2.message,
            error2.stack,
            asyncError
          );
        }
      };
      jQuery2.readyException = function(error2) {
        window2.setTimeout(function() {
          throw error2;
        });
      };
      var readyList = jQuery2.Deferred();
      jQuery2.fn.ready = function(fn2) {
        readyList.then(fn2).catch(function(error2) {
          jQuery2.readyException(error2);
        });
        return this;
      };
      jQuery2.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
            return;
          }
          jQuery2.isReady = true;
          if (wait !== true && --jQuery2.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery2]);
        }
      });
      jQuery2.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery2.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery2.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
        var i4 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i4 in key) {
            access(elems, fn2, i4, key[i4], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction2(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn2.call(elems, value);
              fn2 = null;
            } else {
              bulk = fn2;
              fn2 = function(elem, _key, value2) {
                return bulk.call(jQuery2(elem), value2);
              };
            }
          }
          if (fn2) {
            for (; i4 < len; i4++) {
              fn2(
                elems[i4],
                key,
                raw ? value : value.call(elems[i4], i4, fn2(elems[i4], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn2.call(elems);
        }
        return len ? fn2(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery2.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache2 = this.cache(owner);
          if (typeof data === "string") {
            cache2[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache2[camelCase(prop)] = data[prop];
            }
          }
          return cache2;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i4, cache2 = owner[this.expando];
          if (cache2 === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
            }
            i4 = key.length;
            while (i4--) {
              delete cache2[key[i4]];
            }
          }
          if (key === void 0 || jQuery2.isEmptyObject(cache2)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache2 = owner[this.expando];
          return cache2 !== void 0 && !jQuery2.isEmptyObject(cache2);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData2(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name;
        if (data === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = getData2(data);
            } catch (e4) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery2.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery2.fn.extend({
        data: function(key, value) {
          var i4, name, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i4 = attrs.length;
                while (i4--) {
                  if (attrs[i4]) {
                    name = attrs[i4].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery2.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery2.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
            jQuery2.dequeue(elem, type);
          };
          if (fn2 === "inprogress") {
            fn2 = queue.shift();
            startLength--;
          }
          if (fn2) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn2.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery2.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery2.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery2.queue(this[0], type);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery2.queue(this, type, data);
            jQuery2._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery2.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery2.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count = 1, defer = jQuery2.Deferred(), elements2 = this, i4 = this.length, resolve2 = function() {
            if (!--count) {
              defer.resolveWith(elements2, [elements2]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i4--) {
            tmp = dataPriv.get(elements2[i4], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve2);
            }
          }
          resolve2();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery2.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery2.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial = initial / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery2.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery2.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery2.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements2, show) {
        var display, elem, values = [], index4 = 0, length = elements2.length;
        for (; index4 < length; index4++) {
          elem = elements2[index4];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values[index4] = dataPriv.get(elem, "display") || null;
              if (!values[index4]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index4] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index4] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index4 = 0; index4 < length; index4++) {
          if (values[index4] != null) {
            elements2[index4].style.display = values[index4];
          }
        }
        return elements2;
      }
      jQuery2.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery2(this).show();
            } else {
              jQuery2(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery2.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i4 = 0, l4 = elems.length;
        for (; i4 < l4; i4++) {
          dataPriv.set(
            elems[i4],
            "globalEval",
            !refElements || dataPriv.get(refElements[i4], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j5, fragment = context.createDocumentFragment(), nodes = [], i4 = 0, l4 = elems.length;
        for (; i4 < l4; i4++) {
          elem = elems[i4];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
              j5 = wrap[0];
              while (j5--) {
                tmp = tmp.lastChild;
              }
              jQuery2.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i4 = 0;
        while (elem = nodes[i4++]) {
          if (selection && jQuery2.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j5 = 0;
            while (elem = tmp[j5++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on2(elem, types, selector, data, fn2, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type in types) {
            on2(elem, type, selector, data, types[type], one);
          }
          return elem;
        }
        if (data == null && fn2 == null) {
          fn2 = selector;
          data = selector = void 0;
        } else if (fn2 == null) {
          if (typeof selector === "string") {
            fn2 = data;
            data = void 0;
          } else {
            fn2 = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn2 === false) {
          fn2 = returnFalse;
        } else if (!fn2) {
          return elem;
        }
        if (one === 1) {
          origFn = fn2;
          fn2 = function(event2) {
            jQuery2().off(event2);
            return origFn.apply(this, arguments);
          };
          fn2.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
        }
        return elem.each(function() {
          jQuery2.event.add(this, types, fn2, data, selector);
        });
      }
      jQuery2.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t5, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery2.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery2.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e4) {
              return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e4.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t5 = types.length;
          while (t5--) {
            tmp = rtypenamespace.exec(types[t5]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery2.event.special[type] || {};
            handleObj = jQuery2.extend({
              type,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery2.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j5, origCount, tmp, events, t5, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t5 = types.length;
          while (t5--) {
            tmp = rtypenamespace.exec(types[t5]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery2.event.remove(elem, type + types[t5], handler, selector, true);
              }
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j5 = handlers.length;
            while (j5--) {
              handleObj = handlers[j5];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j5, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery2.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery2.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i4, j5, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event2 = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event2.type] || [], special = jQuery2.event.special[event2.type] || {};
          args[0] = event2;
          for (i4 = 1; i4 < arguments.length; i4++) {
            args[i4] = arguments[i4];
          }
          event2.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event2) === false) {
            return;
          }
          handlerQueue = jQuery2.event.handlers.call(this, event2, handlers);
          i4 = 0;
          while ((matched = handlerQueue[i4++]) && !event2.isPropagationStopped()) {
            event2.currentTarget = matched.elem;
            j5 = 0;
            while ((handleObj = matched.handlers[j5++]) && !event2.isImmediatePropagationStopped()) {
              if (!event2.rnamespace || handleObj.namespace === false || event2.rnamespace.test(handleObj.namespace)) {
                event2.handleObj = handleObj;
                event2.data = handleObj.data;
                ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event2.result = ret) === false) {
                    event2.preventDefault();
                    event2.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event2);
          }
          return event2.result;
        },
        handlers: function(event2, handlers) {
          var i4, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event2.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event2.type === "click" && event2.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event2.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i4 = 0; i4 < delegateCount; i4++) {
                  handleObj = handlers[i4];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery2.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction2(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event2) {
              var target = event2.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event2) {
              if (event2.result !== void 0 && event2.originalEvent) {
                event2.originalEvent.returnValue = event2.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery2.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery2.event.add(el, type, {
          namespace: false,
          handler: function(event2) {
            var result, saved = dataPriv.get(this, type);
            if (event2.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result) {
                  event2.stopImmediatePropagation();
                  event2.preventDefault();
                  return result;
                }
              } else if ((jQuery2.event.special[type] || {}).delegateType) {
                event2.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery2.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event2.stopPropagation();
              event2.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery2.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery2.Event = function(src, props) {
        if (!(this instanceof jQuery2.Event)) {
          return new jQuery2.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery2.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery2.expando] = true;
      };
      jQuery2.Event.prototype = {
        constructor: jQuery2.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e4 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.preventDefault();
          }
        },
        stopPropagation: function() {
          var e4 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e4 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e4 && !this.isSimulated) {
            e4.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery2.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery2.event.addProp);
      jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event2 = jQuery2.event.fix(nativeEvent);
            event2.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event2.isSimulated = true;
            handle(nativeEvent);
            if (event2.target === event2.currentTarget) {
              handle(event2);
            }
          } else {
            jQuery2.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery2.event.fix(nativeEvent)
            );
          }
        }
        jQuery2.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event2) {
            return dataPriv.get(event2.target, type);
          },
          delegateType
        };
        jQuery2.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery2.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery2.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event2) {
            var ret, target = this, related = event2.relatedTarget, handleObj = event2.handleObj;
            if (!related || related !== target && !jQuery2.contains(target, related)) {
              event2.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event2.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery2.fn.extend({
        on: function(types, selector, data, fn2) {
          return on2(this, types, selector, data, fn2);
        },
        one: function(types, selector, data, fn2) {
          return on2(this, types, selector, data, fn2, 1);
        },
        off: function(types, selector, fn2) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery2(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn2 = selector;
            selector = void 0;
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          }
          return this.each(function() {
            jQuery2.event.remove(this, types, fn2, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery2(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i4, l4, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i4 = 0, l4 = events[type].length; i4 < l4; i4++) {
                jQuery2.event.add(dest, type, events[type][i4]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery2.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback2, ignored) {
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i4 = 0, l4 = collection.length, iNoClone = l4 - 1, value = args[0], valueIsFunction = isFunction2(value);
        if (valueIsFunction || l4 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index4) {
            var self2 = collection.eq(index4);
            if (valueIsFunction) {
              args[0] = value.call(this, index4, self2.html());
            }
            domManip(self2, args, callback2, ignored);
          });
        }
        if (l4) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i4 < l4; i4++) {
              node = fragment;
              if (i4 !== iNoClone) {
                node = jQuery2.clone(node, true, true);
                if (hasScripts) {
                  jQuery2.merge(scripts, getAll(node, "script"));
                }
              }
              callback2.call(collection[i4], node, i4);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery2.map(scripts, restoreScript);
              for (i4 = 0; i4 < hasScripts; i4++) {
                node = scripts[i4];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery2._evalUrl && !node.noModule) {
                      jQuery2._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i4 = 0;
        for (; (node = nodes[i4]) != null; i4++) {
          if (!keepData && node.nodeType === 1) {
            jQuery2.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery2.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i4, l4, srcElements, destElements, clone3 = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
            destElements = getAll(clone3);
            srcElements = getAll(elem);
            for (i4 = 0, l4 = srcElements.length; i4 < l4; i4++) {
              fixInput(srcElements[i4], destElements[i4]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone3);
              for (i4 = 0, l4 = srcElements.length; i4 < l4; i4++) {
                cloneCopyEvent(srcElements[i4], destElements[i4]);
              }
            } else {
              cloneCopyEvent(elem, clone3);
            }
          }
          destElements = getAll(clone3, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone3;
        },
        cleanData: function(elems) {
          var data, elem, type, special = jQuery2.event.special, i4 = 0;
          for (; (elem = elems[i4]) !== void 0; i4++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery2.event.remove(elem, type);
                    } else {
                      jQuery2.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery2.fn.extend({
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i4 = 0;
          for (; (elem = this[i4]) != null; i4++) {
            if (elem.nodeType === 1) {
              jQuery2.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i4 = 0, l4 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery2.htmlPrefilter(value2);
              try {
                for (; i4 < l4; i4++) {
                  elem = this[i4] || {};
                  if (elem.nodeType === 1) {
                    jQuery2.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e4) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery2.inArray(this, ignored) < 0) {
              jQuery2.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery2.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery2.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i4 = 0;
          for (; i4 <= last; i4++) {
            elems = i4 === last ? this : this.clone(true);
            jQuery2(insert[i4])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap2 = function(elem, options, callback2) {
        var ret, name, old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback2.call(elem);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery2.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table, tr2, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table = document2.createElement("table");
              tr2 = document2.createElement("tr");
              trChild = document2.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr2.style.cssText = "box-sizing:content-box;border:1px solid";
              tr2.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr2).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr2);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr2.offsetHeight;
              documentElement.removeChild(table);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery2.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i4 = cssPrefixes.length;
        while (i4--) {
          name = cssPrefixes[i4] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery2.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches2 = rcssNum.exec(value);
        return matches2 ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches2[2] - (subtract || 0)) + (matches2[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i4 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i4 < 4; i4 += 2) {
          if (box === "margin") {
            marginDelta += jQuery2.css(elem, box + cssExpand[i4], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery2.css(elem, "padding" + cssExpand[i4], true, styles);
            if (box !== "padding") {
              delta += jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
            } else {
              extra += jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery2.css(elem, "padding" + cssExpand[i4], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery2.css(elem, "border" + cssExpand[i4] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery2.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery2.each(["height", "width"], function(_i2, dimension) {
        jQuery2.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap2(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches2, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
              );
            }
            if (subtract && (matches2 = rcssNum.exec(value)) && (matches2[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery2.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery2.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap2(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery2.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery2.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i4 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i4 < 4; i4++) {
              expanded[prefix + cssExpand[i4] + suffix] = parts[i4] || parts[i4 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery2.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name2, value2) {
            var styles, len, map3 = {}, i4 = 0;
            if (Array.isArray(name2)) {
              styles = getStyles(elem);
              len = name2.length;
              for (; i4 < len; i4++) {
                map3[name2[i4]] = jQuery2.css(elem, name2[i4], false, styles);
              }
              return map3;
            }
            return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
          }, name, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery2.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery2.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery2.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery2.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery2.fx.step[tween.prop]) {
              jQuery2.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery2.easing = {
        linear: function(p4) {
          return p4;
        },
        swing: function(p4) {
          return 0.5 - Math.cos(p4 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery2.fx = Tween.prototype.init;
      jQuery2.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery2.fx.interval);
          }
          jQuery2.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i4 = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i4 < 4; i4 += 2 - includeWidth) {
          which = cssExpand[i4];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation2.tweeners[prop] || []).concat(Animation2.tweeners["*"]), index4 = 0, length = collection.length;
        for (; index4 < length; index4++) {
          if (tween = collection[index4].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery2._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery2.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
          }
        }
        propTween = !jQuery2.isEmptyObject(props);
        if (!propTween && jQuery2.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery2.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery2.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery2.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery2.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index4, name, easing, value, hooks;
        for (index4 in props) {
          name = camelCase(index4);
          easing = specialEasing[name];
          value = props[index4];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index4] = value[0];
          }
          if (index4 !== name) {
            props[name] = value;
            delete props[index4];
          }
          hooks = jQuery2.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index4 in value) {
              if (!(index4 in props)) {
                props[index4] = value[index4];
                specialEasing[index4] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation2(elem, properties, options) {
        var result, stopped, index4 = 0, length = Animation2.prefilters.length, deferred = jQuery2.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index5 = 0, length2 = animation.tweens.length;
          for (; index5 < length2; index5++) {
            animation.tweens[index5].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery2.extend({}, properties),
          opts: jQuery2.extend(true, {
            specialEasing: {},
            easing: jQuery2.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery2.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index5 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index5 < length2; index5++) {
              animation.tweens[index5].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index4 < length; index4++) {
          result = Animation2.prefilters[index4].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction2(result.stop)) {
              jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery2.map(props, createTween, animation);
        if (isFunction2(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery2.fx.timer(
          jQuery2.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery2.Animation = jQuery2.extend(Animation2, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback2) {
          if (isFunction2(props)) {
            callback2 = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index4 = 0, length = props.length;
          for (; index4 < length; index4++) {
            prop = props[index4];
            Animation2.tweeners[prop] = Animation2.tweeners[prop] || [];
            Animation2.tweeners[prop].unshift(callback2);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback2, prepend) {
          if (prepend) {
            Animation2.prefilters.unshift(callback2);
          } else {
            Animation2.prefilters.push(callback2);
          }
        }
      });
      jQuery2.speed = function(speed, easing, fn2) {
        var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
          complete: fn2 || !fn2 && easing || isFunction2(speed) && speed,
          duration: speed,
          easing: fn2 && easing || easing && !isFunction2(easing) && easing
        };
        if (jQuery2.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery2.fx.speeds) {
              opt.duration = jQuery2.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery2.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction2(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery2.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery2.fn.extend({
        fadeTo: function(speed, to3, easing, callback2) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to3 }, speed, easing, callback2);
        },
        animate: function(prop, speed, easing, callback2) {
          var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback2), doAnimation = function() {
            var anim = Animation2(this, jQuery2.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index4 = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
            if (index4) {
              if (data[index4] && data[index4].stop) {
                stopQueue(data[index4]);
              }
            } else {
              for (index4 in data) {
                if (data[index4] && data[index4].stop && rrun.test(index4)) {
                  stopQueue(data[index4]);
                }
              }
            }
            for (index4 = timers.length; index4--; ) {
              if (timers[index4].elem === this && (type == null || timers[index4].queue === type)) {
                timers[index4].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index4, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery2.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index4, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
            data.finish = true;
            jQuery2.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index4 = timers.length; index4--; ) {
              if (timers[index4].elem === this && timers[index4].queue === type) {
                timers[index4].anim.stop(true);
                timers.splice(index4, 1);
              }
            }
            for (index4 = 0; index4 < length; index4++) {
              if (queue[index4] && queue[index4].finish) {
                queue[index4].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery2.each(["toggle", "show", "hide"], function(_i2, name) {
        var cssFn = jQuery2.fn[name];
        jQuery2.fn[name] = function(speed, easing, callback2) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback2);
        };
      });
      jQuery2.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery2.fn[name] = function(speed, easing, callback2) {
          return this.animate(props, speed, easing, callback2);
        };
      });
      jQuery2.timers = [];
      jQuery2.fx.tick = function() {
        var timer, i4 = 0, timers = jQuery2.timers;
        fxNow = Date.now();
        for (; i4 < timers.length; i4++) {
          timer = timers[i4];
          if (!timer() && timers[i4] === timer) {
            timers.splice(i4--, 1);
          }
        }
        if (!timers.length) {
          jQuery2.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery2.fx.timer = function(timer) {
        jQuery2.timers.push(timer);
        jQuery2.fx.start();
      };
      jQuery2.fx.interval = 13;
      jQuery2.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery2.fx.stop = function() {
        inProgress = null;
      };
      jQuery2.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery2.fn.delay = function(time, type) {
        time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery2.expr.attrHandle;
      jQuery2.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery2.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery2.removeAttr(this, name);
          });
        }
      });
      jQuery2.extend({
        attr: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery2.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery2.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery2.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name, i4 = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i4++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name) {
          if (value === false) {
            jQuery2.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i2, name) {
        var getter = attrHandle[name] || jQuery2.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery2.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery2.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery2.propFix[name] || name];
          });
        }
      });
      jQuery2.extend({
        prop: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            name = jQuery2.propFix[name] || name;
            hooks = jQuery2.propHooks[name];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery2.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery2.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery2.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery2.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery2.fn.extend({
        addClass: function(value) {
          var classNames, cur, curValue, className2, i4, finalValue;
          if (isFunction2(value)) {
            return this.each(function(j5) {
              jQuery2(this).addClass(value.call(this, j5, getClass(this)));
            });
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i4 = 0; i4 < classNames.length; i4++) {
                  className2 = classNames[i4];
                  if (cur.indexOf(" " + className2 + " ") < 0) {
                    cur += className2 + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames, cur, curValue, className2, i4, finalValue;
          if (isFunction2(value)) {
            return this.each(function(j5) {
              jQuery2(this).removeClass(value.call(this, j5, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i4 = 0; i4 < classNames.length; i4++) {
                  className2 = classNames[i4];
                  while (cur.indexOf(" " + className2 + " ") > -1) {
                    cur = cur.replace(" " + className2 + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames, className2, i4, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction2(value)) {
            return this.each(function(i5) {
              jQuery2(this).toggleClass(
                value.call(this, i5, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery2(this);
              for (i4 = 0; i4 < classNames.length; i4++) {
                className2 = classNames[i4];
                if (self2.hasClass(className2)) {
                  self2.removeClass(className2);
                } else {
                  self2.addClass(className2);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className2 = getClass(this);
              if (className2) {
                dataPriv.set(this, "__className__", className2);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className2 || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className2, elem, i4 = 0;
          className2 = " " + selector + " ";
          while (elem = this[i4++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className2) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery2.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction2(value);
          return this.each(function(i4) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i4, jQuery2(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery2.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery2.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery2.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery2.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i4, options = elem.options, index4 = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index4 + 1 : options.length;
              if (index4 < 0) {
                i4 = max;
              } else {
                i4 = one ? index4 : 0;
              }
              for (; i4 < max; i4++) {
                option = options[i4];
                if ((option.selected || i4 === index4) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery2(option).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i4 = options.length;
              while (i4--) {
                option = options[i4];
                if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }
      });
      jQuery2.each(["radio", "checkbox"], function() {
        jQuery2.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery2.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location2 = window2.location;
      var nonce2 = { guid: Date.now() };
      var rquery = /\?/;
      jQuery2.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e4) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
          }).join("\n") : data));
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e4) {
        e4.stopPropagation();
      };
      jQuery2.extend(jQuery2.event, {
        trigger: function(event2, data, elem, onlyHandlers) {
          var i4, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event2, "type") ? event2.type : event2, namespaces = hasOwn.call(event2, "namespace") ? event2.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery2.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event2 = event2[jQuery2.expando] ? event2 : new jQuery2.Event(type, typeof event2 === "object" && event2);
          event2.isTrigger = onlyHandlers ? 2 : 3;
          event2.namespace = namespaces.join(".");
          event2.rnamespace = event2.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event2.result = void 0;
          if (!event2.target) {
            event2.target = elem;
          }
          data = data == null ? [event2] : jQuery2.makeArray(data, [event2]);
          special = jQuery2.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i4 = 0;
          while ((cur = eventPath[i4++]) && !event2.isPropagationStopped()) {
            lastElement = cur;
            event2.type = i4 > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event2.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event2.result = handle.apply(cur, data);
              if (event2.result === false) {
                event2.preventDefault();
              }
            }
          }
          event2.type = type;
          if (!onlyHandlers && !event2.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery2.event.triggered = type;
                if (event2.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event2.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery2.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event2.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event2) {
          var e4 = jQuery2.extend(
            new jQuery2.Event(),
            event2,
            {
              type,
              isSimulated: true
            }
          );
          jQuery2.event.trigger(e4, null, elem);
        }
      });
      jQuery2.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery2.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery2.event.trigger(type, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add2) {
        var name;
        if (Array.isArray(obj)) {
          jQuery2.each(obj, function(i4, v4) {
            if (traditional || rbracket.test(prefix)) {
              add2(prefix, v4);
            } else {
              buildParams(
                prefix + "[" + (typeof v4 === "object" && v4 != null ? i4 : "") + "]",
                v4,
                traditional,
                add2
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
          }
        } else {
          add2(prefix, obj);
        }
      }
      jQuery2.param = function(a4, traditional) {
        var prefix, s4 = [], add2 = function(key, valueOrFunction) {
          var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s4[s4.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a4 == null) {
          return "";
        }
        if (Array.isArray(a4) || a4.jquery && !jQuery2.isPlainObject(a4)) {
          jQuery2.each(a4, function() {
            add2(this.name, this.value);
          });
        } else {
          for (prefix in a4) {
            buildParams(prefix, a4[prefix], traditional, add2);
          }
        }
        return s4.join("&");
      };
      jQuery2.fn.extend({
        serialize: function() {
          return jQuery2.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements2 = jQuery2.prop(this, "elements");
            return elements2 ? jQuery2.makeArray(elements2) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i2, elem) {
            var val = jQuery2(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery2.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location2.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i4 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction2(func)) {
            while (dataType = dataTypes[i4++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery2.each(structure[dataType] || [], function(_4, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery2.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s4, jqXHR, responses) {
        var ct2, type, finalDataType, firstDataType, contents = s4.contents, dataTypes = s4.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct2 === void 0) {
            ct2 = s4.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct2) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct2)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s4.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s4, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s4.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s4.converters) {
            converters[conv.toLowerCase()] = s4.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s4.responseFields[current]) {
            jqXHR[s4.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s4.dataFilter) {
            response = s4.dataFilter(response, s4.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s4.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e4) {
                    return {
                      state: "parsererror",
                      error: conv ? e4 : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery2.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location2.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location2.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery2.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery2.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i4, uncached, s4 = jQuery2.ajaxSetup({}, options), callbackContext = s4.context || s4, globalEventContext = s4.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s4.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name, value) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s4.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map3) {
              var code;
              if (map3) {
                if (completed2) {
                  jqXHR.always(map3[jqXHR.status]);
                } else {
                  for (code in map3) {
                    statusCode[code] = [statusCode[code], map3[code]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s4.url = ((url || s4.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
          s4.type = options.method || options.type || s4.method || s4.type;
          s4.dataTypes = (s4.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s4.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s4.url;
              urlAnchor.href = urlAnchor.href;
              s4.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e4) {
              s4.crossDomain = true;
            }
          }
          if (s4.data && s4.processData && typeof s4.data !== "string") {
            s4.data = jQuery2.param(s4.data, s4.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s4, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery2.event && s4.global;
          if (fireGlobals && jQuery2.active++ === 0) {
            jQuery2.event.trigger("ajaxStart");
          }
          s4.type = s4.type.toUpperCase();
          s4.hasContent = !rnoContent.test(s4.type);
          cacheURL = s4.url.replace(rhash, "");
          if (!s4.hasContent) {
            uncached = s4.url.slice(cacheURL.length);
            if (s4.data && (s4.processData || typeof s4.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s4.data;
              delete s4.data;
            }
            if (s4.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce2.guid++ + uncached;
            }
            s4.url = cacheURL + uncached;
          } else if (s4.data && s4.processData && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s4.data = s4.data.replace(r20, "+");
          }
          if (s4.ifModified) {
            if (jQuery2.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
            }
            if (jQuery2.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
            }
          }
          if (s4.data && s4.hasContent && s4.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s4.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s4.dataTypes[0] && s4.accepts[s4.dataTypes[0]] ? s4.accepts[s4.dataTypes[0]] + (s4.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s4.accepts["*"]
          );
          for (i4 in s4.headers) {
            jqXHR.setRequestHeader(i4, s4.headers[i4]);
          }
          if (s4.beforeSend && (s4.beforeSend.call(callbackContext, jqXHR, s4) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s4.complete);
          jqXHR.done(s4.success);
          jqXHR.fail(s4.error);
          transport = inspectPrefiltersOrTransports(transports, s4, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s4]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s4.async && s4.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s4.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e4) {
              if (completed2) {
                throw e4;
              }
              done(-1, e4);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s4, jqXHR, responses);
            }
            if (!isSuccess && jQuery2.inArray("script", s4.dataTypes) > -1 && jQuery2.inArray("json", s4.dataTypes) < 0) {
              s4.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s4, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s4.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery2.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery2.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s4.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error2 = response.error;
                isSuccess = !error2;
              }
            } else {
              error2 = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s4, isSuccess ? success : error2]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s4]);
              if (!--jQuery2.active) {
                jQuery2.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback2) {
          return jQuery2.get(url, data, callback2, "json");
        },
        getScript: function(url, callback2) {
          return jQuery2.get(url, void 0, callback2, "script");
        }
      });
      jQuery2.each(["get", "post"], function(_i2, method) {
        jQuery2[method] = function(url, data, callback2, type) {
          if (isFunction2(data)) {
            type = type || callback2;
            callback2 = data;
            data = void 0;
          }
          return jQuery2.ajax(jQuery2.extend({
            url,
            type: method,
            dataType: type,
            data,
            success: callback2
          }, jQuery2.isPlainObject(url) && url));
        };
      });
      jQuery2.ajaxPrefilter(function(s4) {
        var i4;
        for (i4 in s4.headers) {
          if (i4.toLowerCase() === "content-type") {
            s4.contentType = s4.headers[i4] || "";
          }
        }
      });
      jQuery2._evalUrl = function(url, options, doc) {
        return jQuery2.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery2.globalEval(response, options, doc);
          }
        });
      };
      jQuery2.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (this[0]) {
            if (isFunction2(html)) {
              html = html.call(this[0]);
            }
            wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction2(html)) {
            return this.each(function(i4) {
              jQuery2(this).wrapInner(html.call(this, i4));
            });
          }
          return this.each(function() {
            var self2 = jQuery2(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction2(html);
          return this.each(function(i4) {
            jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i4) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery2(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery2.expr.pseudos.hidden = function(elem) {
        return !jQuery2.expr.pseudos.visible(elem);
      };
      jQuery2.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery2.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e4) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery2.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery2.ajaxTransport(function(options) {
        var callback2, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i4, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i4 in options.xhrFields) {
                  xhr[i4] = options.xhrFields[i4];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i4 in headers) {
                xhr.setRequestHeader(i4, headers[i4]);
              }
              callback2 = function(type) {
                return function() {
                  if (callback2) {
                    callback2 = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback2();
              errorCallback = xhr.onerror = xhr.ontimeout = callback2("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback2) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback2 = callback2("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e4) {
                if (callback2) {
                  throw e4;
                }
              }
            },
            abort: function() {
              if (callback2) {
                callback2();
              }
            }
          };
        }
      });
      jQuery2.ajaxPrefilter(function(s4) {
        if (s4.crossDomain) {
          s4.contents.script = false;
        }
      });
      jQuery2.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery2.globalEval(text);
            return text;
          }
        }
      });
      jQuery2.ajaxPrefilter("script", function(s4) {
        if (s4.cache === void 0) {
          s4.cache = false;
        }
        if (s4.crossDomain) {
          s4.type = "GET";
        }
      });
      jQuery2.ajaxTransport("script", function(s4) {
        if (s4.crossDomain || s4.scriptAttrs) {
          var script, callback2;
          return {
            send: function(_4, complete) {
              script = jQuery2("<script>").attr(s4.scriptAttrs || {}).prop({ charset: s4.scriptCharset, src: s4.url }).on("load error", callback2 = function(evt) {
                script.remove();
                callback2 = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback2) {
                callback2();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery2.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback2 = oldCallbacks.pop() || jQuery2.expando + "_" + nonce2.guid++;
          this[callback2] = true;
          return callback2;
        }
      });
      jQuery2.ajaxPrefilter("json jsonp", function(s4, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s4.jsonp !== false && (rjsonp.test(s4.url) ? "url" : typeof s4.data === "string" && (s4.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s4.data) && "data");
        if (jsonProp || s4.dataTypes[0] === "jsonp") {
          callbackName = s4.jsonpCallback = isFunction2(s4.jsonpCallback) ? s4.jsonpCallback() : s4.jsonpCallback;
          if (jsonProp) {
            s4[jsonProp] = s4[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s4.jsonp !== false) {
            s4.url += (rquery.test(s4.url) ? "&" : "?") + s4.jsonp + "=" + callbackName;
          }
          s4.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery2.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s4.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery2(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s4[callbackName]) {
              s4.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction2(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body2 = document2.implementation.createHTMLDocument("").body;
        body2.innerHTML = "<form></form><form></form>";
        return body2.childNodes.length === 2;
      }();
      jQuery2.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery2(scripts).remove();
        }
        return jQuery2.merge([], parsed.childNodes);
      };
      jQuery2.fn.load = function(url, params, callback2) {
        var selector, type, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction2(params)) {
          callback2 = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery2.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback2 && function(jqXHR, status) {
            self2.each(function() {
              callback2.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery2.expr.pseudos.animated = function(elem) {
        return jQuery2.grep(jQuery2.timers, function(fn2) {
          return elem === fn2.elem;
        }).length;
      };
      jQuery2.offset = {
        setOffset: function(elem, options, i4) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery2.css(elem, "top");
          curCSSLeft = jQuery2.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction2(options)) {
            options = options.call(elem, i4, jQuery2.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery2.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i4) {
              jQuery2.offset.setOffset(this, options, i4);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery2.css(elem, "position") === "fixed") {
            offset = elem.getBoundingClientRect();
          } else {
            offset = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery2(offsetParent).offset();
              parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery2.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery2.each(["top", "left"], function(_i2, prop) {
        jQuery2.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery2.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery2.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery2.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery2.style(elem, type2, value2, extra)
              );
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery2.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i2, type) {
        jQuery2.fn[type] = function(fn2) {
          return this.on(type, fn2);
        };
      });
      jQuery2.fn.extend({
        bind: function(types, data, fn2) {
          return this.on(types, null, data, fn2);
        },
        unbind: function(types, fn2) {
          return this.off(types, null, fn2);
        },
        delegate: function(selector, types, data, fn2) {
          return this.on(types, selector, data, fn2);
        },
        undelegate: function(selector, types, fn2) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery2.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i2, name) {
          jQuery2.fn[name] = function(data, fn2) {
            return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery2.proxy = function(fn2, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn2[context];
          context = fn2;
          fn2 = tmp;
        }
        if (!isFunction2(fn2)) {
          return void 0;
        }
        args = slice.call(arguments, 2);
        proxy = function() {
          return fn2.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn2.guid = fn2.guid || jQuery2.guid++;
        return proxy;
      };
      jQuery2.holdReady = function(hold) {
        if (hold) {
          jQuery2.readyWait++;
        } else {
          jQuery2.ready(true);
        }
      };
      jQuery2.isArray = Array.isArray;
      jQuery2.parseJSON = JSON.parse;
      jQuery2.nodeName = nodeName;
      jQuery2.isFunction = isFunction2;
      jQuery2.isWindow = isWindow;
      jQuery2.camelCase = camelCase;
      jQuery2.type = toType;
      jQuery2.now = Date.now;
      jQuery2.isNumeric = function(obj) {
        var type = jQuery2.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery2.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery2;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery2.noConflict = function(deep) {
        if (window2.$ === jQuery2) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery2) {
          window2.jQuery = _jQuery;
        }
        return jQuery2;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery2;
      }
      return jQuery2;
    });
  }
});

// node_modules/bootstrap/dist/js/bootstrap.bundle.min.js
var require_bootstrap_bundle_min = __commonJS({
  "node_modules/bootstrap/dist/js/bootstrap.bundle.min.js"(exports, module) {
    !function(t5, e4) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e4() : "function" == typeof define && define.amd ? define(e4) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).bootstrap = e4();
    }(exports, function() {
      "use strict";
      const t5 = /* @__PURE__ */ new Map(), e4 = { set(e5, i5, n4) {
        t5.has(e5) || t5.set(e5, /* @__PURE__ */ new Map());
        const s5 = t5.get(e5);
        s5.has(i5) || 0 === s5.size ? s5.set(i5, n4) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s5.keys())[0]}.`);
      }, get: (e5, i5) => t5.has(e5) && t5.get(e5).get(i5) || null, remove(e5, i5) {
        if (!t5.has(e5)) return;
        const n4 = t5.get(e5);
        n4.delete(i5), 0 === n4.size && t5.delete(e5);
      } }, i4 = "transitionend", n3 = (t6) => (t6 && window.CSS && window.CSS.escape && (t6 = t6.replace(/#([^\s"#']+)/g, (t7, e5) => `#${CSS.escape(e5)}`)), t6), s4 = (t6) => {
        t6.dispatchEvent(new Event(i4));
      }, o3 = (t6) => !(!t6 || "object" != typeof t6) && (void 0 !== t6.jquery && (t6 = t6[0]), void 0 !== t6.nodeType), r4 = (t6) => o3(t6) ? t6.jquery ? t6[0] : t6 : "string" == typeof t6 && t6.length > 0 ? document.querySelector(n3(t6)) : null, a4 = (t6) => {
        if (!o3(t6) || 0 === t6.getClientRects().length) return false;
        const e5 = "visible" === getComputedStyle(t6).getPropertyValue("visibility"), i5 = t6.closest("details:not([open])");
        if (!i5) return e5;
        if (i5 !== t6) {
          const e6 = t6.closest("summary");
          if (e6 && e6.parentNode !== i5) return false;
          if (null === e6) return false;
        }
        return e5;
      }, l4 = (t6) => !t6 || t6.nodeType !== Node.ELEMENT_NODE || !!t6.classList.contains("disabled") || (void 0 !== t6.disabled ? t6.disabled : t6.hasAttribute("disabled") && "false" !== t6.getAttribute("disabled")), c4 = (t6) => {
        if (!document.documentElement.attachShadow) return null;
        if ("function" == typeof t6.getRootNode) {
          const e5 = t6.getRootNode();
          return e5 instanceof ShadowRoot ? e5 : null;
        }
        return t6 instanceof ShadowRoot ? t6 : t6.parentNode ? c4(t6.parentNode) : null;
      }, h4 = () => {
      }, d3 = (t6) => {
        t6.offsetHeight;
      }, u4 = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, f4 = [], p4 = () => "rtl" === document.documentElement.dir, m5 = (t6) => {
        var e5;
        e5 = () => {
          const e6 = u4();
          if (e6) {
            const i5 = t6.NAME, n4 = e6.fn[i5];
            e6.fn[i5] = t6.jQueryInterface, e6.fn[i5].Constructor = t6, e6.fn[i5].noConflict = () => (e6.fn[i5] = n4, t6.jQueryInterface);
          }
        }, "loading" === document.readyState ? (f4.length || document.addEventListener("DOMContentLoaded", () => {
          for (const t7 of f4) t7();
        }), f4.push(e5)) : e5();
      }, g5 = (t6, e5 = [], i5 = t6) => "function" == typeof t6 ? t6(...e5) : i5, _4 = (t6, e5, n4 = true) => {
        if (!n4) return void g5(t6);
        const o4 = ((t7) => {
          if (!t7) return 0;
          let { transitionDuration: e6, transitionDelay: i5 } = window.getComputedStyle(t7);
          const n5 = Number.parseFloat(e6), s5 = Number.parseFloat(i5);
          return n5 || s5 ? (e6 = e6.split(",")[0], i5 = i5.split(",")[0], 1e3 * (Number.parseFloat(e6) + Number.parseFloat(i5))) : 0;
        })(e5) + 5;
        let r5 = false;
        const a5 = ({ target: n5 }) => {
          n5 === e5 && (r5 = true, e5.removeEventListener(i4, a5), g5(t6));
        };
        e5.addEventListener(i4, a5), setTimeout(() => {
          r5 || s4(e5);
        }, o4);
      }, b4 = (t6, e5, i5, n4) => {
        const s5 = t6.length;
        let o4 = t6.indexOf(e5);
        return -1 === o4 ? !i5 && n4 ? t6[s5 - 1] : t6[0] : (o4 += i5 ? 1 : -1, n4 && (o4 = (o4 + s5) % s5), t6[Math.max(0, Math.min(o4, s5 - 1))]);
      }, v4 = /[^.]*(?=\..*)\.|.*/, y4 = /\..*/, w5 = /::\d+$/, A4 = {};
      let E3 = 1;
      const T5 = { mouseenter: "mouseover", mouseleave: "mouseout" }, C4 = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
      function O3(t6, e5) {
        return e5 && `${e5}::${E3++}` || t6.uidEvent || E3++;
      }
      function x5(t6) {
        const e5 = O3(t6);
        return t6.uidEvent = e5, A4[e5] = A4[e5] || {}, A4[e5];
      }
      function k4(t6, e5, i5 = null) {
        return Object.values(t6).find((t7) => t7.callable === e5 && t7.delegationSelector === i5);
      }
      function L4(t6, e5, i5) {
        const n4 = "string" == typeof e5, s5 = n4 ? i5 : e5 || i5;
        let o4 = I4(t6);
        return C4.has(o4) || (o4 = t6), [n4, s5, o4];
      }
      function S3(t6, e5, i5, n4, s5) {
        if ("string" != typeof e5 || !t6) return;
        let [o4, r5, a5] = L4(e5, i5, n4);
        if (e5 in T5) {
          const t7 = (t8) => function(e6) {
            if (!e6.relatedTarget || e6.relatedTarget !== e6.delegateTarget && !e6.delegateTarget.contains(e6.relatedTarget)) return t8.call(this, e6);
          };
          r5 = t7(r5);
        }
        const l5 = x5(t6), c5 = l5[a5] || (l5[a5] = {}), h5 = k4(c5, r5, o4 ? i5 : null);
        if (h5) return void (h5.oneOff = h5.oneOff && s5);
        const d4 = O3(r5, e5.replace(v4, "")), u5 = o4 ? /* @__PURE__ */ function(t7, e6, i6) {
          return function n5(s6) {
            const o5 = t7.querySelectorAll(e6);
            for (let { target: r6 } = s6; r6 && r6 !== this; r6 = r6.parentNode) for (const a6 of o5) if (a6 === r6) return P4(s6, { delegateTarget: r6 }), n5.oneOff && N4.off(t7, s6.type, e6, i6), i6.apply(r6, [s6]);
          };
        }(t6, i5, r5) : /* @__PURE__ */ function(t7, e6) {
          return function i6(n5) {
            return P4(n5, { delegateTarget: t7 }), i6.oneOff && N4.off(t7, n5.type, e6), e6.apply(t7, [n5]);
          };
        }(t6, r5);
        u5.delegationSelector = o4 ? i5 : null, u5.callable = r5, u5.oneOff = s5, u5.uidEvent = d4, c5[d4] = u5, t6.addEventListener(a5, u5, o4);
      }
      function D4(t6, e5, i5, n4, s5) {
        const o4 = k4(e5[i5], n4, s5);
        o4 && (t6.removeEventListener(i5, o4, Boolean(s5)), delete e5[i5][o4.uidEvent]);
      }
      function $6(t6, e5, i5, n4) {
        const s5 = e5[i5] || {};
        for (const [o4, r5] of Object.entries(s5)) o4.includes(n4) && D4(t6, e5, i5, r5.callable, r5.delegationSelector);
      }
      function I4(t6) {
        return t6 = t6.replace(y4, ""), T5[t6] || t6;
      }
      const N4 = { on(t6, e5, i5, n4) {
        S3(t6, e5, i5, n4, false);
      }, one(t6, e5, i5, n4) {
        S3(t6, e5, i5, n4, true);
      }, off(t6, e5, i5, n4) {
        if ("string" != typeof e5 || !t6) return;
        const [s5, o4, r5] = L4(e5, i5, n4), a5 = r5 !== e5, l5 = x5(t6), c5 = l5[r5] || {}, h5 = e5.startsWith(".");
        if (void 0 === o4) {
          if (h5) for (const i6 of Object.keys(l5)) $6(t6, l5, i6, e5.slice(1));
          for (const [i6, n5] of Object.entries(c5)) {
            const s6 = i6.replace(w5, "");
            a5 && !e5.includes(s6) || D4(t6, l5, r5, n5.callable, n5.delegationSelector);
          }
        } else {
          if (!Object.keys(c5).length) return;
          D4(t6, l5, r5, o4, s5 ? i5 : null);
        }
      }, trigger(t6, e5, i5) {
        if ("string" != typeof e5 || !t6) return null;
        const n4 = u4();
        let s5 = null, o4 = true, r5 = true, a5 = false;
        e5 !== I4(e5) && n4 && (s5 = n4.Event(e5, i5), n4(t6).trigger(s5), o4 = !s5.isPropagationStopped(), r5 = !s5.isImmediatePropagationStopped(), a5 = s5.isDefaultPrevented());
        const l5 = P4(new Event(e5, { bubbles: o4, cancelable: true }), i5);
        return a5 && l5.preventDefault(), r5 && t6.dispatchEvent(l5), l5.defaultPrevented && s5 && s5.preventDefault(), l5;
      } };
      function P4(t6, e5 = {}) {
        for (const [i5, n4] of Object.entries(e5)) try {
          t6[i5] = n4;
        } catch (e6) {
          Object.defineProperty(t6, i5, { configurable: true, get: () => n4 });
        }
        return t6;
      }
      function j5(t6) {
        if ("true" === t6) return true;
        if ("false" === t6) return false;
        if (t6 === Number(t6).toString()) return Number(t6);
        if ("" === t6 || "null" === t6) return null;
        if ("string" != typeof t6) return t6;
        try {
          return JSON.parse(decodeURIComponent(t6));
        } catch (e5) {
          return t6;
        }
      }
      function M3(t6) {
        return t6.replace(/[A-Z]/g, (t7) => `-${t7.toLowerCase()}`);
      }
      const F5 = { setDataAttribute(t6, e5, i5) {
        t6.setAttribute(`data-bs-${M3(e5)}`, i5);
      }, removeDataAttribute(t6, e5) {
        t6.removeAttribute(`data-bs-${M3(e5)}`);
      }, getDataAttributes(t6) {
        if (!t6) return {};
        const e5 = {}, i5 = Object.keys(t6.dataset).filter((t7) => t7.startsWith("bs") && !t7.startsWith("bsConfig"));
        for (const n4 of i5) {
          let i6 = n4.replace(/^bs/, "");
          i6 = i6.charAt(0).toLowerCase() + i6.slice(1, i6.length), e5[i6] = j5(t6.dataset[n4]);
        }
        return e5;
      }, getDataAttribute: (t6, e5) => j5(t6.getAttribute(`data-bs-${M3(e5)}`)) };
      class H4 {
        static get Default() {
          return {};
        }
        static get DefaultType() {
          return {};
        }
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
        _getConfig(t6) {
          return t6 = this._mergeConfigObj(t6), t6 = this._configAfterMerge(t6), this._typeCheckConfig(t6), t6;
        }
        _configAfterMerge(t6) {
          return t6;
        }
        _mergeConfigObj(t6, e5) {
          const i5 = o3(e5) ? F5.getDataAttribute(e5, "config") : {};
          return { ...this.constructor.Default, ..."object" == typeof i5 ? i5 : {}, ...o3(e5) ? F5.getDataAttributes(e5) : {}, ..."object" == typeof t6 ? t6 : {} };
        }
        _typeCheckConfig(t6, e5 = this.constructor.DefaultType) {
          for (const [n4, s5] of Object.entries(e5)) {
            const e6 = t6[n4], r5 = o3(e6) ? "element" : null == (i5 = e6) ? `${i5}` : Object.prototype.toString.call(i5).match(/\s([a-z]+)/i)[1].toLowerCase();
            if (!new RegExp(s5).test(r5)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n4}" provided type "${r5}" but expected type "${s5}".`);
          }
          var i5;
        }
      }
      class W3 extends H4 {
        constructor(t6, i5) {
          super(), (t6 = r4(t6)) && (this._element = t6, this._config = this._getConfig(i5), e4.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
          e4.remove(this._element, this.constructor.DATA_KEY), N4.off(this._element, this.constructor.EVENT_KEY);
          for (const t6 of Object.getOwnPropertyNames(this)) this[t6] = null;
        }
        _queueCallback(t6, e5, i5 = true) {
          _4(t6, e5, i5);
        }
        _getConfig(t6) {
          return t6 = this._mergeConfigObj(t6, this._element), t6 = this._configAfterMerge(t6), this._typeCheckConfig(t6), t6;
        }
        static getInstance(t6) {
          return e4.get(r4(t6), this.DATA_KEY);
        }
        static getOrCreateInstance(t6, e5 = {}) {
          return this.getInstance(t6) || new this(t6, "object" == typeof e5 ? e5 : null);
        }
        static get VERSION() {
          return "5.3.3";
        }
        static get DATA_KEY() {
          return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
        static eventName(t6) {
          return `${t6}${this.EVENT_KEY}`;
        }
      }
      const B4 = (t6) => {
        let e5 = t6.getAttribute("data-bs-target");
        if (!e5 || "#" === e5) {
          let i5 = t6.getAttribute("href");
          if (!i5 || !i5.includes("#") && !i5.startsWith(".")) return null;
          i5.includes("#") && !i5.startsWith("#") && (i5 = `#${i5.split("#")[1]}`), e5 = i5 && "#" !== i5 ? i5.trim() : null;
        }
        return e5 ? e5.split(",").map((t7) => n3(t7)).join(",") : null;
      }, z4 = { find: (t6, e5 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e5, t6)), findOne: (t6, e5 = document.documentElement) => Element.prototype.querySelector.call(e5, t6), children: (t6, e5) => [].concat(...t6.children).filter((t7) => t7.matches(e5)), parents(t6, e5) {
        const i5 = [];
        let n4 = t6.parentNode.closest(e5);
        for (; n4; ) i5.push(n4), n4 = n4.parentNode.closest(e5);
        return i5;
      }, prev(t6, e5) {
        let i5 = t6.previousElementSibling;
        for (; i5; ) {
          if (i5.matches(e5)) return [i5];
          i5 = i5.previousElementSibling;
        }
        return [];
      }, next(t6, e5) {
        let i5 = t6.nextElementSibling;
        for (; i5; ) {
          if (i5.matches(e5)) return [i5];
          i5 = i5.nextElementSibling;
        }
        return [];
      }, focusableChildren(t6) {
        const e5 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t7) => `${t7}:not([tabindex^="-"])`).join(",");
        return this.find(e5, t6).filter((t7) => !l4(t7) && a4(t7));
      }, getSelectorFromElement(t6) {
        const e5 = B4(t6);
        return e5 && z4.findOne(e5) ? e5 : null;
      }, getElementFromSelector(t6) {
        const e5 = B4(t6);
        return e5 ? z4.findOne(e5) : null;
      }, getMultipleElementsFromSelector(t6) {
        const e5 = B4(t6);
        return e5 ? z4.find(e5) : [];
      } }, R2 = (t6, e5 = "hide") => {
        const i5 = `click.dismiss${t6.EVENT_KEY}`, n4 = t6.NAME;
        N4.on(document, i5, `[data-bs-dismiss="${n4}"]`, function(i6) {
          if (["A", "AREA"].includes(this.tagName) && i6.preventDefault(), l4(this)) return;
          const s5 = z4.getElementFromSelector(this) || this.closest(`.${n4}`);
          t6.getOrCreateInstance(s5)[e5]();
        });
      }, q4 = ".bs.alert", V4 = `close${q4}`, K3 = `closed${q4}`;
      class Q3 extends W3 {
        static get NAME() {
          return "alert";
        }
        close() {
          if (N4.trigger(this._element, V4).defaultPrevented) return;
          this._element.classList.remove("show");
          const t6 = this._element.classList.contains("fade");
          this._queueCallback(() => this._destroyElement(), this._element, t6);
        }
        _destroyElement() {
          this._element.remove(), N4.trigger(this._element, K3), this.dispose();
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = Q3.getOrCreateInstance(this);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6] || t6.startsWith("_") || "constructor" === t6) throw new TypeError(`No method named "${t6}"`);
              e5[t6](this);
            }
          });
        }
      }
      R2(Q3, "close"), m5(Q3);
      const X3 = '[data-bs-toggle="button"]';
      class Y2 extends W3 {
        static get NAME() {
          return "button";
        }
        toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = Y2.getOrCreateInstance(this);
            "toggle" === t6 && e5[t6]();
          });
        }
      }
      N4.on(document, "click.bs.button.data-api", X3, (t6) => {
        t6.preventDefault();
        const e5 = t6.target.closest(X3);
        Y2.getOrCreateInstance(e5).toggle();
      }), m5(Y2);
      const U3 = ".bs.swipe", G4 = `touchstart${U3}`, J3 = `touchmove${U3}`, Z3 = `touchend${U3}`, tt2 = `pointerdown${U3}`, et2 = `pointerup${U3}`, it2 = { endCallback: null, leftCallback: null, rightCallback: null }, nt2 = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
      class st2 extends H4 {
        constructor(t6, e5) {
          super(), this._element = t6, t6 && st2.isSupported() && (this._config = this._getConfig(e5), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
        }
        static get Default() {
          return it2;
        }
        static get DefaultType() {
          return nt2;
        }
        static get NAME() {
          return "swipe";
        }
        dispose() {
          N4.off(this._element, U3);
        }
        _start(t6) {
          this._supportPointerEvents ? this._eventIsPointerPenTouch(t6) && (this._deltaX = t6.clientX) : this._deltaX = t6.touches[0].clientX;
        }
        _end(t6) {
          this._eventIsPointerPenTouch(t6) && (this._deltaX = t6.clientX - this._deltaX), this._handleSwipe(), g5(this._config.endCallback);
        }
        _move(t6) {
          this._deltaX = t6.touches && t6.touches.length > 1 ? 0 : t6.touches[0].clientX - this._deltaX;
        }
        _handleSwipe() {
          const t6 = Math.abs(this._deltaX);
          if (t6 <= 40) return;
          const e5 = t6 / this._deltaX;
          this._deltaX = 0, e5 && g5(e5 > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
        _initEvents() {
          this._supportPointerEvents ? (N4.on(this._element, tt2, (t6) => this._start(t6)), N4.on(this._element, et2, (t6) => this._end(t6)), this._element.classList.add("pointer-event")) : (N4.on(this._element, G4, (t6) => this._start(t6)), N4.on(this._element, J3, (t6) => this._move(t6)), N4.on(this._element, Z3, (t6) => this._end(t6)));
        }
        _eventIsPointerPenTouch(t6) {
          return this._supportPointerEvents && ("pen" === t6.pointerType || "touch" === t6.pointerType);
        }
        static isSupported() {
          return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        }
      }
      const ot2 = ".bs.carousel", rt2 = ".data-api", at2 = "next", lt2 = "prev", ct2 = "left", ht2 = "right", dt2 = `slide${ot2}`, ut2 = `slid${ot2}`, ft2 = `keydown${ot2}`, pt2 = `mouseenter${ot2}`, mt2 = `mouseleave${ot2}`, gt2 = `dragstart${ot2}`, _t2 = `load${ot2}${rt2}`, bt2 = `click${ot2}${rt2}`, vt2 = "carousel", yt2 = "active", wt2 = ".active", At2 = ".carousel-item", Et2 = wt2 + At2, Tt2 = { ArrowLeft: ht2, ArrowRight: ct2 }, Ct2 = { interval: 5e3, keyboard: true, pause: "hover", ride: false, touch: true, wrap: true }, Ot2 = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
      class xt2 extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._interval = null, this._activeElement = null, this._isSliding = false, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z4.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === vt2 && this.cycle();
        }
        static get Default() {
          return Ct2;
        }
        static get DefaultType() {
          return Ot2;
        }
        static get NAME() {
          return "carousel";
        }
        next() {
          this._slide(at2);
        }
        nextWhenVisible() {
          !document.hidden && a4(this._element) && this.next();
        }
        prev() {
          this._slide(lt2);
        }
        pause() {
          this._isSliding && s4(this._element), this._clearInterval();
        }
        cycle() {
          this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
        }
        _maybeEnableCycle() {
          this._config.ride && (this._isSliding ? N4.one(this._element, ut2, () => this.cycle()) : this.cycle());
        }
        to(t6) {
          const e5 = this._getItems();
          if (t6 > e5.length - 1 || t6 < 0) return;
          if (this._isSliding) return void N4.one(this._element, ut2, () => this.to(t6));
          const i5 = this._getItemIndex(this._getActive());
          if (i5 === t6) return;
          const n4 = t6 > i5 ? at2 : lt2;
          this._slide(n4, e5[t6]);
        }
        dispose() {
          this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
        }
        _configAfterMerge(t6) {
          return t6.defaultInterval = t6.interval, t6;
        }
        _addEventListeners() {
          this._config.keyboard && N4.on(this._element, ft2, (t6) => this._keydown(t6)), "hover" === this._config.pause && (N4.on(this._element, pt2, () => this.pause()), N4.on(this._element, mt2, () => this._maybeEnableCycle())), this._config.touch && st2.isSupported() && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
          for (const t7 of z4.find(".carousel-item img", this._element)) N4.on(t7, gt2, (t8) => t8.preventDefault());
          const t6 = { leftCallback: () => this._slide(this._directionToOrder(ct2)), rightCallback: () => this._slide(this._directionToOrder(ht2)), endCallback: () => {
            "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
          } };
          this._swipeHelper = new st2(this._element, t6);
        }
        _keydown(t6) {
          if (/input|textarea/i.test(t6.target.tagName)) return;
          const e5 = Tt2[t6.key];
          e5 && (t6.preventDefault(), this._slide(this._directionToOrder(e5)));
        }
        _getItemIndex(t6) {
          return this._getItems().indexOf(t6);
        }
        _setActiveIndicatorElement(t6) {
          if (!this._indicatorsElement) return;
          const e5 = z4.findOne(wt2, this._indicatorsElement);
          e5.classList.remove(yt2), e5.removeAttribute("aria-current");
          const i5 = z4.findOne(`[data-bs-slide-to="${t6}"]`, this._indicatorsElement);
          i5 && (i5.classList.add(yt2), i5.setAttribute("aria-current", "true"));
        }
        _updateInterval() {
          const t6 = this._activeElement || this._getActive();
          if (!t6) return;
          const e5 = Number.parseInt(t6.getAttribute("data-bs-interval"), 10);
          this._config.interval = e5 || this._config.defaultInterval;
        }
        _slide(t6, e5 = null) {
          if (this._isSliding) return;
          const i5 = this._getActive(), n4 = t6 === at2, s5 = e5 || b4(this._getItems(), i5, n4, this._config.wrap);
          if (s5 === i5) return;
          const o4 = this._getItemIndex(s5), r5 = (e6) => N4.trigger(this._element, e6, { relatedTarget: s5, direction: this._orderToDirection(t6), from: this._getItemIndex(i5), to: o4 });
          if (r5(dt2).defaultPrevented) return;
          if (!i5 || !s5) return;
          const a5 = Boolean(this._interval);
          this.pause(), this._isSliding = true, this._setActiveIndicatorElement(o4), this._activeElement = s5;
          const l5 = n4 ? "carousel-item-start" : "carousel-item-end", c5 = n4 ? "carousel-item-next" : "carousel-item-prev";
          s5.classList.add(c5), d3(s5), i5.classList.add(l5), s5.classList.add(l5), this._queueCallback(() => {
            s5.classList.remove(l5, c5), s5.classList.add(yt2), i5.classList.remove(yt2, c5, l5), this._isSliding = false, r5(ut2);
          }, i5, this._isAnimated()), a5 && this.cycle();
        }
        _isAnimated() {
          return this._element.classList.contains("slide");
        }
        _getActive() {
          return z4.findOne(Et2, this._element);
        }
        _getItems() {
          return z4.find(At2, this._element);
        }
        _clearInterval() {
          this._interval && (clearInterval(this._interval), this._interval = null);
        }
        _directionToOrder(t6) {
          return p4() ? t6 === ct2 ? lt2 : at2 : t6 === ct2 ? at2 : lt2;
        }
        _orderToDirection(t6) {
          return p4() ? t6 === lt2 ? ct2 : ht2 : t6 === lt2 ? ht2 : ct2;
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = xt2.getOrCreateInstance(this, t6);
            if ("number" != typeof t6) {
              if ("string" == typeof t6) {
                if (void 0 === e5[t6] || t6.startsWith("_") || "constructor" === t6) throw new TypeError(`No method named "${t6}"`);
                e5[t6]();
              }
            } else e5.to(t6);
          });
        }
      }
      N4.on(document, bt2, "[data-bs-slide], [data-bs-slide-to]", function(t6) {
        const e5 = z4.getElementFromSelector(this);
        if (!e5 || !e5.classList.contains(vt2)) return;
        t6.preventDefault();
        const i5 = xt2.getOrCreateInstance(e5), n4 = this.getAttribute("data-bs-slide-to");
        return n4 ? (i5.to(n4), void i5._maybeEnableCycle()) : "next" === F5.getDataAttribute(this, "slide") ? (i5.next(), void i5._maybeEnableCycle()) : (i5.prev(), void i5._maybeEnableCycle());
      }), N4.on(window, _t2, () => {
        const t6 = z4.find('[data-bs-ride="carousel"]');
        for (const e5 of t6) xt2.getOrCreateInstance(e5);
      }), m5(xt2);
      const kt2 = ".bs.collapse", Lt2 = `show${kt2}`, St2 = `shown${kt2}`, Dt2 = `hide${kt2}`, $t2 = `hidden${kt2}`, It2 = `click${kt2}.data-api`, Nt2 = "show", Pt2 = "collapse", jt2 = "collapsing", Mt2 = `:scope .${Pt2} .${Pt2}`, Ft2 = '[data-bs-toggle="collapse"]', Ht2 = { parent: null, toggle: true }, Wt2 = { parent: "(null|element)", toggle: "boolean" };
      class Bt2 extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._isTransitioning = false, this._triggerArray = [];
          const i5 = z4.find(Ft2);
          for (const t7 of i5) {
            const e6 = z4.getSelectorFromElement(t7), i6 = z4.find(e6).filter((t8) => t8 === this._element);
            null !== e6 && i6.length && this._triggerArray.push(t7);
          }
          this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
          return Ht2;
        }
        static get DefaultType() {
          return Wt2;
        }
        static get NAME() {
          return "collapse";
        }
        toggle() {
          this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (this._isTransitioning || this._isShown()) return;
          let t6 = [];
          if (this._config.parent && (t6 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t7) => t7 !== this._element).map((t7) => Bt2.getOrCreateInstance(t7, { toggle: false }))), t6.length && t6[0]._isTransitioning) return;
          if (N4.trigger(this._element, Lt2).defaultPrevented) return;
          for (const e6 of t6) e6.hide();
          const e5 = this._getDimension();
          this._element.classList.remove(Pt2), this._element.classList.add(jt2), this._element.style[e5] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
          const i5 = `scroll${e5[0].toUpperCase() + e5.slice(1)}`;
          this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(jt2), this._element.classList.add(Pt2, Nt2), this._element.style[e5] = "", N4.trigger(this._element, St2);
          }, this._element, true), this._element.style[e5] = `${this._element[i5]}px`;
        }
        hide() {
          if (this._isTransitioning || !this._isShown()) return;
          if (N4.trigger(this._element, Dt2).defaultPrevented) return;
          const t6 = this._getDimension();
          this._element.style[t6] = `${this._element.getBoundingClientRect()[t6]}px`, d3(this._element), this._element.classList.add(jt2), this._element.classList.remove(Pt2, Nt2);
          for (const t7 of this._triggerArray) {
            const e5 = z4.getElementFromSelector(t7);
            e5 && !this._isShown(e5) && this._addAriaAndCollapsedClass([t7], false);
          }
          this._isTransitioning = true, this._element.style[t6] = "", this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(jt2), this._element.classList.add(Pt2), N4.trigger(this._element, $t2);
          }, this._element, true);
        }
        _isShown(t6 = this._element) {
          return t6.classList.contains(Nt2);
        }
        _configAfterMerge(t6) {
          return t6.toggle = Boolean(t6.toggle), t6.parent = r4(t6.parent), t6;
        }
        _getDimension() {
          return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
          if (!this._config.parent) return;
          const t6 = this._getFirstLevelChildren(Ft2);
          for (const e5 of t6) {
            const t7 = z4.getElementFromSelector(e5);
            t7 && this._addAriaAndCollapsedClass([e5], this._isShown(t7));
          }
        }
        _getFirstLevelChildren(t6) {
          const e5 = z4.find(Mt2, this._config.parent);
          return z4.find(t6, this._config.parent).filter((t7) => !e5.includes(t7));
        }
        _addAriaAndCollapsedClass(t6, e5) {
          if (t6.length) for (const i5 of t6) i5.classList.toggle("collapsed", !e5), i5.setAttribute("aria-expanded", e5);
        }
        static jQueryInterface(t6) {
          const e5 = {};
          return "string" == typeof t6 && /show|hide/.test(t6) && (e5.toggle = false), this.each(function() {
            const i5 = Bt2.getOrCreateInstance(this, e5);
            if ("string" == typeof t6) {
              if (void 0 === i5[t6]) throw new TypeError(`No method named "${t6}"`);
              i5[t6]();
            }
          });
        }
      }
      N4.on(document, It2, Ft2, function(t6) {
        ("A" === t6.target.tagName || t6.delegateTarget && "A" === t6.delegateTarget.tagName) && t6.preventDefault();
        for (const t7 of z4.getMultipleElementsFromSelector(this)) Bt2.getOrCreateInstance(t7, { toggle: false }).toggle();
      }), m5(Bt2);
      var zt2 = "top", Rt2 = "bottom", qt2 = "right", Vt2 = "left", Kt2 = "auto", Qt2 = [zt2, Rt2, qt2, Vt2], Xt2 = "start", Yt2 = "end", Ut2 = "clippingParents", Gt2 = "viewport", Jt2 = "popper", Zt2 = "reference", te2 = Qt2.reduce(function(t6, e5) {
        return t6.concat([e5 + "-" + Xt2, e5 + "-" + Yt2]);
      }, []), ee2 = [].concat(Qt2, [Kt2]).reduce(function(t6, e5) {
        return t6.concat([e5, e5 + "-" + Xt2, e5 + "-" + Yt2]);
      }, []), ie2 = "beforeRead", ne2 = "read", se2 = "afterRead", oe2 = "beforeMain", re2 = "main", ae2 = "afterMain", le2 = "beforeWrite", ce2 = "write", he2 = "afterWrite", de2 = [ie2, ne2, se2, oe2, re2, ae2, le2, ce2, he2];
      function ue2(t6) {
        return t6 ? (t6.nodeName || "").toLowerCase() : null;
      }
      function fe2(t6) {
        if (null == t6) return window;
        if ("[object Window]" !== t6.toString()) {
          var e5 = t6.ownerDocument;
          return e5 && e5.defaultView || window;
        }
        return t6;
      }
      function pe2(t6) {
        return t6 instanceof fe2(t6).Element || t6 instanceof Element;
      }
      function me2(t6) {
        return t6 instanceof fe2(t6).HTMLElement || t6 instanceof HTMLElement;
      }
      function ge2(t6) {
        return "undefined" != typeof ShadowRoot && (t6 instanceof fe2(t6).ShadowRoot || t6 instanceof ShadowRoot);
      }
      const _e2 = { name: "applyStyles", enabled: true, phase: "write", fn: function(t6) {
        var e5 = t6.state;
        Object.keys(e5.elements).forEach(function(t7) {
          var i5 = e5.styles[t7] || {}, n4 = e5.attributes[t7] || {}, s5 = e5.elements[t7];
          me2(s5) && ue2(s5) && (Object.assign(s5.style, i5), Object.keys(n4).forEach(function(t8) {
            var e6 = n4[t8];
            false === e6 ? s5.removeAttribute(t8) : s5.setAttribute(t8, true === e6 ? "" : e6);
          }));
        });
      }, effect: function(t6) {
        var e5 = t6.state, i5 = { popper: { position: e5.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e5.elements.popper.style, i5.popper), e5.styles = i5, e5.elements.arrow && Object.assign(e5.elements.arrow.style, i5.arrow), function() {
          Object.keys(e5.elements).forEach(function(t7) {
            var n4 = e5.elements[t7], s5 = e5.attributes[t7] || {}, o4 = Object.keys(e5.styles.hasOwnProperty(t7) ? e5.styles[t7] : i5[t7]).reduce(function(t8, e6) {
              return t8[e6] = "", t8;
            }, {});
            me2(n4) && ue2(n4) && (Object.assign(n4.style, o4), Object.keys(s5).forEach(function(t8) {
              n4.removeAttribute(t8);
            }));
          });
        };
      }, requires: ["computeStyles"] };
      function be2(t6) {
        return t6.split("-")[0];
      }
      var ve2 = Math.max, ye2 = Math.min, we2 = Math.round;
      function Ae2() {
        var t6 = navigator.userAgentData;
        return null != t6 && t6.brands && Array.isArray(t6.brands) ? t6.brands.map(function(t7) {
          return t7.brand + "/" + t7.version;
        }).join(" ") : navigator.userAgent;
      }
      function Ee2() {
        return !/^((?!chrome|android).)*safari/i.test(Ae2());
      }
      function Te2(t6, e5, i5) {
        void 0 === e5 && (e5 = false), void 0 === i5 && (i5 = false);
        var n4 = t6.getBoundingClientRect(), s5 = 1, o4 = 1;
        e5 && me2(t6) && (s5 = t6.offsetWidth > 0 && we2(n4.width) / t6.offsetWidth || 1, o4 = t6.offsetHeight > 0 && we2(n4.height) / t6.offsetHeight || 1);
        var r5 = (pe2(t6) ? fe2(t6) : window).visualViewport, a5 = !Ee2() && i5, l5 = (n4.left + (a5 && r5 ? r5.offsetLeft : 0)) / s5, c5 = (n4.top + (a5 && r5 ? r5.offsetTop : 0)) / o4, h5 = n4.width / s5, d4 = n4.height / o4;
        return { width: h5, height: d4, top: c5, right: l5 + h5, bottom: c5 + d4, left: l5, x: l5, y: c5 };
      }
      function Ce2(t6) {
        var e5 = Te2(t6), i5 = t6.offsetWidth, n4 = t6.offsetHeight;
        return Math.abs(e5.width - i5) <= 1 && (i5 = e5.width), Math.abs(e5.height - n4) <= 1 && (n4 = e5.height), { x: t6.offsetLeft, y: t6.offsetTop, width: i5, height: n4 };
      }
      function Oe2(t6, e5) {
        var i5 = e5.getRootNode && e5.getRootNode();
        if (t6.contains(e5)) return true;
        if (i5 && ge2(i5)) {
          var n4 = e5;
          do {
            if (n4 && t6.isSameNode(n4)) return true;
            n4 = n4.parentNode || n4.host;
          } while (n4);
        }
        return false;
      }
      function xe2(t6) {
        return fe2(t6).getComputedStyle(t6);
      }
      function ke2(t6) {
        return ["table", "td", "th"].indexOf(ue2(t6)) >= 0;
      }
      function Le2(t6) {
        return ((pe2(t6) ? t6.ownerDocument : t6.document) || window.document).documentElement;
      }
      function Se2(t6) {
        return "html" === ue2(t6) ? t6 : t6.assignedSlot || t6.parentNode || (ge2(t6) ? t6.host : null) || Le2(t6);
      }
      function De2(t6) {
        return me2(t6) && "fixed" !== xe2(t6).position ? t6.offsetParent : null;
      }
      function $e2(t6) {
        for (var e5 = fe2(t6), i5 = De2(t6); i5 && ke2(i5) && "static" === xe2(i5).position; ) i5 = De2(i5);
        return i5 && ("html" === ue2(i5) || "body" === ue2(i5) && "static" === xe2(i5).position) ? e5 : i5 || function(t7) {
          var e6 = /firefox/i.test(Ae2());
          if (/Trident/i.test(Ae2()) && me2(t7) && "fixed" === xe2(t7).position) return null;
          var i6 = Se2(t7);
          for (ge2(i6) && (i6 = i6.host); me2(i6) && ["html", "body"].indexOf(ue2(i6)) < 0; ) {
            var n4 = xe2(i6);
            if ("none" !== n4.transform || "none" !== n4.perspective || "paint" === n4.contain || -1 !== ["transform", "perspective"].indexOf(n4.willChange) || e6 && "filter" === n4.willChange || e6 && n4.filter && "none" !== n4.filter) return i6;
            i6 = i6.parentNode;
          }
          return null;
        }(t6) || e5;
      }
      function Ie2(t6) {
        return ["top", "bottom"].indexOf(t6) >= 0 ? "x" : "y";
      }
      function Ne2(t6, e5, i5) {
        return ve2(t6, ye2(e5, i5));
      }
      function Pe2(t6) {
        return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t6);
      }
      function je2(t6, e5) {
        return e5.reduce(function(e6, i5) {
          return e6[i5] = t6, e6;
        }, {});
      }
      const Me2 = { name: "arrow", enabled: true, phase: "main", fn: function(t6) {
        var e5, i5 = t6.state, n4 = t6.name, s5 = t6.options, o4 = i5.elements.arrow, r5 = i5.modifiersData.popperOffsets, a5 = be2(i5.placement), l5 = Ie2(a5), c5 = [Vt2, qt2].indexOf(a5) >= 0 ? "height" : "width";
        if (o4 && r5) {
          var h5 = function(t7, e6) {
            return Pe2("number" != typeof (t7 = "function" == typeof t7 ? t7(Object.assign({}, e6.rects, { placement: e6.placement })) : t7) ? t7 : je2(t7, Qt2));
          }(s5.padding, i5), d4 = Ce2(o4), u5 = "y" === l5 ? zt2 : Vt2, f5 = "y" === l5 ? Rt2 : qt2, p5 = i5.rects.reference[c5] + i5.rects.reference[l5] - r5[l5] - i5.rects.popper[c5], m6 = r5[l5] - i5.rects.reference[l5], g6 = $e2(o4), _5 = g6 ? "y" === l5 ? g6.clientHeight || 0 : g6.clientWidth || 0 : 0, b5 = p5 / 2 - m6 / 2, v5 = h5[u5], y5 = _5 - d4[c5] - h5[f5], w6 = _5 / 2 - d4[c5] / 2 + b5, A5 = Ne2(v5, w6, y5), E4 = l5;
          i5.modifiersData[n4] = ((e5 = {})[E4] = A5, e5.centerOffset = A5 - w6, e5);
        }
      }, effect: function(t6) {
        var e5 = t6.state, i5 = t6.options.element, n4 = void 0 === i5 ? "[data-popper-arrow]" : i5;
        null != n4 && ("string" != typeof n4 || (n4 = e5.elements.popper.querySelector(n4))) && Oe2(e5.elements.popper, n4) && (e5.elements.arrow = n4);
      }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function Fe2(t6) {
        return t6.split("-")[1];
      }
      var He2 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function We2(t6) {
        var e5, i5 = t6.popper, n4 = t6.popperRect, s5 = t6.placement, o4 = t6.variation, r5 = t6.offsets, a5 = t6.position, l5 = t6.gpuAcceleration, c5 = t6.adaptive, h5 = t6.roundOffsets, d4 = t6.isFixed, u5 = r5.x, f5 = void 0 === u5 ? 0 : u5, p5 = r5.y, m6 = void 0 === p5 ? 0 : p5, g6 = "function" == typeof h5 ? h5({ x: f5, y: m6 }) : { x: f5, y: m6 };
        f5 = g6.x, m6 = g6.y;
        var _5 = r5.hasOwnProperty("x"), b5 = r5.hasOwnProperty("y"), v5 = Vt2, y5 = zt2, w6 = window;
        if (c5) {
          var A5 = $e2(i5), E4 = "clientHeight", T6 = "clientWidth";
          A5 === fe2(i5) && "static" !== xe2(A5 = Le2(i5)).position && "absolute" === a5 && (E4 = "scrollHeight", T6 = "scrollWidth"), (s5 === zt2 || (s5 === Vt2 || s5 === qt2) && o4 === Yt2) && (y5 = Rt2, m6 -= (d4 && A5 === w6 && w6.visualViewport ? w6.visualViewport.height : A5[E4]) - n4.height, m6 *= l5 ? 1 : -1), s5 !== Vt2 && (s5 !== zt2 && s5 !== Rt2 || o4 !== Yt2) || (v5 = qt2, f5 -= (d4 && A5 === w6 && w6.visualViewport ? w6.visualViewport.width : A5[T6]) - n4.width, f5 *= l5 ? 1 : -1);
        }
        var C5, O4 = Object.assign({ position: a5 }, c5 && He2), x6 = true === h5 ? function(t7, e6) {
          var i6 = t7.x, n5 = t7.y, s6 = e6.devicePixelRatio || 1;
          return { x: we2(i6 * s6) / s6 || 0, y: we2(n5 * s6) / s6 || 0 };
        }({ x: f5, y: m6 }, fe2(i5)) : { x: f5, y: m6 };
        return f5 = x6.x, m6 = x6.y, l5 ? Object.assign({}, O4, ((C5 = {})[y5] = b5 ? "0" : "", C5[v5] = _5 ? "0" : "", C5.transform = (w6.devicePixelRatio || 1) <= 1 ? "translate(" + f5 + "px, " + m6 + "px)" : "translate3d(" + f5 + "px, " + m6 + "px, 0)", C5)) : Object.assign({}, O4, ((e5 = {})[y5] = b5 ? m6 + "px" : "", e5[v5] = _5 ? f5 + "px" : "", e5.transform = "", e5));
      }
      const Be2 = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(t6) {
        var e5 = t6.state, i5 = t6.options, n4 = i5.gpuAcceleration, s5 = void 0 === n4 || n4, o4 = i5.adaptive, r5 = void 0 === o4 || o4, a5 = i5.roundOffsets, l5 = void 0 === a5 || a5, c5 = { placement: be2(e5.placement), variation: Fe2(e5.placement), popper: e5.elements.popper, popperRect: e5.rects.popper, gpuAcceleration: s5, isFixed: "fixed" === e5.options.strategy };
        null != e5.modifiersData.popperOffsets && (e5.styles.popper = Object.assign({}, e5.styles.popper, We2(Object.assign({}, c5, { offsets: e5.modifiersData.popperOffsets, position: e5.options.strategy, adaptive: r5, roundOffsets: l5 })))), null != e5.modifiersData.arrow && (e5.styles.arrow = Object.assign({}, e5.styles.arrow, We2(Object.assign({}, c5, { offsets: e5.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l5 })))), e5.attributes.popper = Object.assign({}, e5.attributes.popper, { "data-popper-placement": e5.placement });
      }, data: {} };
      var ze2 = { passive: true };
      const Re2 = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: function(t6) {
        var e5 = t6.state, i5 = t6.instance, n4 = t6.options, s5 = n4.scroll, o4 = void 0 === s5 || s5, r5 = n4.resize, a5 = void 0 === r5 || r5, l5 = fe2(e5.elements.popper), c5 = [].concat(e5.scrollParents.reference, e5.scrollParents.popper);
        return o4 && c5.forEach(function(t7) {
          t7.addEventListener("scroll", i5.update, ze2);
        }), a5 && l5.addEventListener("resize", i5.update, ze2), function() {
          o4 && c5.forEach(function(t7) {
            t7.removeEventListener("scroll", i5.update, ze2);
          }), a5 && l5.removeEventListener("resize", i5.update, ze2);
        };
      }, data: {} };
      var qe2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function Ve2(t6) {
        return t6.replace(/left|right|bottom|top/g, function(t7) {
          return qe2[t7];
        });
      }
      var Ke2 = { start: "end", end: "start" };
      function Qe2(t6) {
        return t6.replace(/start|end/g, function(t7) {
          return Ke2[t7];
        });
      }
      function Xe2(t6) {
        var e5 = fe2(t6);
        return { scrollLeft: e5.pageXOffset, scrollTop: e5.pageYOffset };
      }
      function Ye2(t6) {
        return Te2(Le2(t6)).left + Xe2(t6).scrollLeft;
      }
      function Ue2(t6) {
        var e5 = xe2(t6), i5 = e5.overflow, n4 = e5.overflowX, s5 = e5.overflowY;
        return /auto|scroll|overlay|hidden/.test(i5 + s5 + n4);
      }
      function Ge2(t6) {
        return ["html", "body", "#document"].indexOf(ue2(t6)) >= 0 ? t6.ownerDocument.body : me2(t6) && Ue2(t6) ? t6 : Ge2(Se2(t6));
      }
      function Je2(t6, e5) {
        var i5;
        void 0 === e5 && (e5 = []);
        var n4 = Ge2(t6), s5 = n4 === (null == (i5 = t6.ownerDocument) ? void 0 : i5.body), o4 = fe2(n4), r5 = s5 ? [o4].concat(o4.visualViewport || [], Ue2(n4) ? n4 : []) : n4, a5 = e5.concat(r5);
        return s5 ? a5 : a5.concat(Je2(Se2(r5)));
      }
      function Ze2(t6) {
        return Object.assign({}, t6, { left: t6.x, top: t6.y, right: t6.x + t6.width, bottom: t6.y + t6.height });
      }
      function ti2(t6, e5, i5) {
        return e5 === Gt2 ? Ze2(function(t7, e6) {
          var i6 = fe2(t7), n4 = Le2(t7), s5 = i6.visualViewport, o4 = n4.clientWidth, r5 = n4.clientHeight, a5 = 0, l5 = 0;
          if (s5) {
            o4 = s5.width, r5 = s5.height;
            var c5 = Ee2();
            (c5 || !c5 && "fixed" === e6) && (a5 = s5.offsetLeft, l5 = s5.offsetTop);
          }
          return { width: o4, height: r5, x: a5 + Ye2(t7), y: l5 };
        }(t6, i5)) : pe2(e5) ? function(t7, e6) {
          var i6 = Te2(t7, false, "fixed" === e6);
          return i6.top = i6.top + t7.clientTop, i6.left = i6.left + t7.clientLeft, i6.bottom = i6.top + t7.clientHeight, i6.right = i6.left + t7.clientWidth, i6.width = t7.clientWidth, i6.height = t7.clientHeight, i6.x = i6.left, i6.y = i6.top, i6;
        }(e5, i5) : Ze2(function(t7) {
          var e6, i6 = Le2(t7), n4 = Xe2(t7), s5 = null == (e6 = t7.ownerDocument) ? void 0 : e6.body, o4 = ve2(i6.scrollWidth, i6.clientWidth, s5 ? s5.scrollWidth : 0, s5 ? s5.clientWidth : 0), r5 = ve2(i6.scrollHeight, i6.clientHeight, s5 ? s5.scrollHeight : 0, s5 ? s5.clientHeight : 0), a5 = -n4.scrollLeft + Ye2(t7), l5 = -n4.scrollTop;
          return "rtl" === xe2(s5 || i6).direction && (a5 += ve2(i6.clientWidth, s5 ? s5.clientWidth : 0) - o4), { width: o4, height: r5, x: a5, y: l5 };
        }(Le2(t6)));
      }
      function ei2(t6) {
        var e5, i5 = t6.reference, n4 = t6.element, s5 = t6.placement, o4 = s5 ? be2(s5) : null, r5 = s5 ? Fe2(s5) : null, a5 = i5.x + i5.width / 2 - n4.width / 2, l5 = i5.y + i5.height / 2 - n4.height / 2;
        switch (o4) {
          case zt2:
            e5 = { x: a5, y: i5.y - n4.height };
            break;
          case Rt2:
            e5 = { x: a5, y: i5.y + i5.height };
            break;
          case qt2:
            e5 = { x: i5.x + i5.width, y: l5 };
            break;
          case Vt2:
            e5 = { x: i5.x - n4.width, y: l5 };
            break;
          default:
            e5 = { x: i5.x, y: i5.y };
        }
        var c5 = o4 ? Ie2(o4) : null;
        if (null != c5) {
          var h5 = "y" === c5 ? "height" : "width";
          switch (r5) {
            case Xt2:
              e5[c5] = e5[c5] - (i5[h5] / 2 - n4[h5] / 2);
              break;
            case Yt2:
              e5[c5] = e5[c5] + (i5[h5] / 2 - n4[h5] / 2);
          }
        }
        return e5;
      }
      function ii2(t6, e5) {
        void 0 === e5 && (e5 = {});
        var i5 = e5, n4 = i5.placement, s5 = void 0 === n4 ? t6.placement : n4, o4 = i5.strategy, r5 = void 0 === o4 ? t6.strategy : o4, a5 = i5.boundary, l5 = void 0 === a5 ? Ut2 : a5, c5 = i5.rootBoundary, h5 = void 0 === c5 ? Gt2 : c5, d4 = i5.elementContext, u5 = void 0 === d4 ? Jt2 : d4, f5 = i5.altBoundary, p5 = void 0 !== f5 && f5, m6 = i5.padding, g6 = void 0 === m6 ? 0 : m6, _5 = Pe2("number" != typeof g6 ? g6 : je2(g6, Qt2)), b5 = u5 === Jt2 ? Zt2 : Jt2, v5 = t6.rects.popper, y5 = t6.elements[p5 ? b5 : u5], w6 = function(t7, e6, i6, n5) {
          var s6 = "clippingParents" === e6 ? function(t8) {
            var e7 = Je2(Se2(t8)), i7 = ["absolute", "fixed"].indexOf(xe2(t8).position) >= 0 && me2(t8) ? $e2(t8) : t8;
            return pe2(i7) ? e7.filter(function(t9) {
              return pe2(t9) && Oe2(t9, i7) && "body" !== ue2(t9);
            }) : [];
          }(t7) : [].concat(e6), o5 = [].concat(s6, [i6]), r6 = o5[0], a6 = o5.reduce(function(e7, i7) {
            var s7 = ti2(t7, i7, n5);
            return e7.top = ve2(s7.top, e7.top), e7.right = ye2(s7.right, e7.right), e7.bottom = ye2(s7.bottom, e7.bottom), e7.left = ve2(s7.left, e7.left), e7;
          }, ti2(t7, r6, n5));
          return a6.width = a6.right - a6.left, a6.height = a6.bottom - a6.top, a6.x = a6.left, a6.y = a6.top, a6;
        }(pe2(y5) ? y5 : y5.contextElement || Le2(t6.elements.popper), l5, h5, r5), A5 = Te2(t6.elements.reference), E4 = ei2({ reference: A5, element: v5, strategy: "absolute", placement: s5 }), T6 = Ze2(Object.assign({}, v5, E4)), C5 = u5 === Jt2 ? T6 : A5, O4 = { top: w6.top - C5.top + _5.top, bottom: C5.bottom - w6.bottom + _5.bottom, left: w6.left - C5.left + _5.left, right: C5.right - w6.right + _5.right }, x6 = t6.modifiersData.offset;
        if (u5 === Jt2 && x6) {
          var k5 = x6[s5];
          Object.keys(O4).forEach(function(t7) {
            var e6 = [qt2, Rt2].indexOf(t7) >= 0 ? 1 : -1, i6 = [zt2, Rt2].indexOf(t7) >= 0 ? "y" : "x";
            O4[t7] += k5[i6] * e6;
          });
        }
        return O4;
      }
      function ni2(t6, e5) {
        void 0 === e5 && (e5 = {});
        var i5 = e5, n4 = i5.placement, s5 = i5.boundary, o4 = i5.rootBoundary, r5 = i5.padding, a5 = i5.flipVariations, l5 = i5.allowedAutoPlacements, c5 = void 0 === l5 ? ee2 : l5, h5 = Fe2(n4), d4 = h5 ? a5 ? te2 : te2.filter(function(t7) {
          return Fe2(t7) === h5;
        }) : Qt2, u5 = d4.filter(function(t7) {
          return c5.indexOf(t7) >= 0;
        });
        0 === u5.length && (u5 = d4);
        var f5 = u5.reduce(function(e6, i6) {
          return e6[i6] = ii2(t6, { placement: i6, boundary: s5, rootBoundary: o4, padding: r5 })[be2(i6)], e6;
        }, {});
        return Object.keys(f5).sort(function(t7, e6) {
          return f5[t7] - f5[e6];
        });
      }
      const si2 = { name: "flip", enabled: true, phase: "main", fn: function(t6) {
        var e5 = t6.state, i5 = t6.options, n4 = t6.name;
        if (!e5.modifiersData[n4]._skip) {
          for (var s5 = i5.mainAxis, o4 = void 0 === s5 || s5, r5 = i5.altAxis, a5 = void 0 === r5 || r5, l5 = i5.fallbackPlacements, c5 = i5.padding, h5 = i5.boundary, d4 = i5.rootBoundary, u5 = i5.altBoundary, f5 = i5.flipVariations, p5 = void 0 === f5 || f5, m6 = i5.allowedAutoPlacements, g6 = e5.options.placement, _5 = be2(g6), b5 = l5 || (_5 !== g6 && p5 ? function(t7) {
            if (be2(t7) === Kt2) return [];
            var e6 = Ve2(t7);
            return [Qe2(t7), e6, Qe2(e6)];
          }(g6) : [Ve2(g6)]), v5 = [g6].concat(b5).reduce(function(t7, i6) {
            return t7.concat(be2(i6) === Kt2 ? ni2(e5, { placement: i6, boundary: h5, rootBoundary: d4, padding: c5, flipVariations: p5, allowedAutoPlacements: m6 }) : i6);
          }, []), y5 = e5.rects.reference, w6 = e5.rects.popper, A5 = /* @__PURE__ */ new Map(), E4 = true, T6 = v5[0], C5 = 0; C5 < v5.length; C5++) {
            var O4 = v5[C5], x6 = be2(O4), k5 = Fe2(O4) === Xt2, L5 = [zt2, Rt2].indexOf(x6) >= 0, S4 = L5 ? "width" : "height", D5 = ii2(e5, { placement: O4, boundary: h5, rootBoundary: d4, altBoundary: u5, padding: c5 }), $7 = L5 ? k5 ? qt2 : Vt2 : k5 ? Rt2 : zt2;
            y5[S4] > w6[S4] && ($7 = Ve2($7));
            var I5 = Ve2($7), N5 = [];
            if (o4 && N5.push(D5[x6] <= 0), a5 && N5.push(D5[$7] <= 0, D5[I5] <= 0), N5.every(function(t7) {
              return t7;
            })) {
              T6 = O4, E4 = false;
              break;
            }
            A5.set(O4, N5);
          }
          if (E4) for (var P5 = function(t7) {
            var e6 = v5.find(function(e7) {
              var i6 = A5.get(e7);
              if (i6) return i6.slice(0, t7).every(function(t8) {
                return t8;
              });
            });
            if (e6) return T6 = e6, "break";
          }, j6 = p5 ? 3 : 1; j6 > 0 && "break" !== P5(j6); j6--) ;
          e5.placement !== T6 && (e5.modifiersData[n4]._skip = true, e5.placement = T6, e5.reset = true);
        }
      }, requiresIfExists: ["offset"], data: { _skip: false } };
      function oi2(t6, e5, i5) {
        return void 0 === i5 && (i5 = { x: 0, y: 0 }), { top: t6.top - e5.height - i5.y, right: t6.right - e5.width + i5.x, bottom: t6.bottom - e5.height + i5.y, left: t6.left - e5.width - i5.x };
      }
      function ri2(t6) {
        return [zt2, qt2, Rt2, Vt2].some(function(e5) {
          return t6[e5] >= 0;
        });
      }
      const ai2 = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(t6) {
        var e5 = t6.state, i5 = t6.name, n4 = e5.rects.reference, s5 = e5.rects.popper, o4 = e5.modifiersData.preventOverflow, r5 = ii2(e5, { elementContext: "reference" }), a5 = ii2(e5, { altBoundary: true }), l5 = oi2(r5, n4), c5 = oi2(a5, s5, o4), h5 = ri2(l5), d4 = ri2(c5);
        e5.modifiersData[i5] = { referenceClippingOffsets: l5, popperEscapeOffsets: c5, isReferenceHidden: h5, hasPopperEscaped: d4 }, e5.attributes.popper = Object.assign({}, e5.attributes.popper, { "data-popper-reference-hidden": h5, "data-popper-escaped": d4 });
      } }, li2 = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(t6) {
        var e5 = t6.state, i5 = t6.options, n4 = t6.name, s5 = i5.offset, o4 = void 0 === s5 ? [0, 0] : s5, r5 = ee2.reduce(function(t7, i6) {
          return t7[i6] = function(t8, e6, i7) {
            var n5 = be2(t8), s6 = [Vt2, zt2].indexOf(n5) >= 0 ? -1 : 1, o5 = "function" == typeof i7 ? i7(Object.assign({}, e6, { placement: t8 })) : i7, r6 = o5[0], a6 = o5[1];
            return r6 = r6 || 0, a6 = (a6 || 0) * s6, [Vt2, qt2].indexOf(n5) >= 0 ? { x: a6, y: r6 } : { x: r6, y: a6 };
          }(i6, e5.rects, o4), t7;
        }, {}), a5 = r5[e5.placement], l5 = a5.x, c5 = a5.y;
        null != e5.modifiersData.popperOffsets && (e5.modifiersData.popperOffsets.x += l5, e5.modifiersData.popperOffsets.y += c5), e5.modifiersData[n4] = r5;
      } }, ci2 = { name: "popperOffsets", enabled: true, phase: "read", fn: function(t6) {
        var e5 = t6.state, i5 = t6.name;
        e5.modifiersData[i5] = ei2({ reference: e5.rects.reference, element: e5.rects.popper, strategy: "absolute", placement: e5.placement });
      }, data: {} }, hi2 = { name: "preventOverflow", enabled: true, phase: "main", fn: function(t6) {
        var e5 = t6.state, i5 = t6.options, n4 = t6.name, s5 = i5.mainAxis, o4 = void 0 === s5 || s5, r5 = i5.altAxis, a5 = void 0 !== r5 && r5, l5 = i5.boundary, c5 = i5.rootBoundary, h5 = i5.altBoundary, d4 = i5.padding, u5 = i5.tether, f5 = void 0 === u5 || u5, p5 = i5.tetherOffset, m6 = void 0 === p5 ? 0 : p5, g6 = ii2(e5, { boundary: l5, rootBoundary: c5, padding: d4, altBoundary: h5 }), _5 = be2(e5.placement), b5 = Fe2(e5.placement), v5 = !b5, y5 = Ie2(_5), w6 = "x" === y5 ? "y" : "x", A5 = e5.modifiersData.popperOffsets, E4 = e5.rects.reference, T6 = e5.rects.popper, C5 = "function" == typeof m6 ? m6(Object.assign({}, e5.rects, { placement: e5.placement })) : m6, O4 = "number" == typeof C5 ? { mainAxis: C5, altAxis: C5 } : Object.assign({ mainAxis: 0, altAxis: 0 }, C5), x6 = e5.modifiersData.offset ? e5.modifiersData.offset[e5.placement] : null, k5 = { x: 0, y: 0 };
        if (A5) {
          if (o4) {
            var L5, S4 = "y" === y5 ? zt2 : Vt2, D5 = "y" === y5 ? Rt2 : qt2, $7 = "y" === y5 ? "height" : "width", I5 = A5[y5], N5 = I5 + g6[S4], P5 = I5 - g6[D5], j6 = f5 ? -T6[$7] / 2 : 0, M4 = b5 === Xt2 ? E4[$7] : T6[$7], F6 = b5 === Xt2 ? -T6[$7] : -E4[$7], H5 = e5.elements.arrow, W4 = f5 && H5 ? Ce2(H5) : { width: 0, height: 0 }, B5 = e5.modifiersData["arrow#persistent"] ? e5.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, z5 = B5[S4], R3 = B5[D5], q5 = Ne2(0, E4[$7], W4[$7]), V5 = v5 ? E4[$7] / 2 - j6 - q5 - z5 - O4.mainAxis : M4 - q5 - z5 - O4.mainAxis, K4 = v5 ? -E4[$7] / 2 + j6 + q5 + R3 + O4.mainAxis : F6 + q5 + R3 + O4.mainAxis, Q4 = e5.elements.arrow && $e2(e5.elements.arrow), X4 = Q4 ? "y" === y5 ? Q4.clientTop || 0 : Q4.clientLeft || 0 : 0, Y3 = null != (L5 = null == x6 ? void 0 : x6[y5]) ? L5 : 0, U4 = I5 + K4 - Y3, G5 = Ne2(f5 ? ye2(N5, I5 + V5 - Y3 - X4) : N5, I5, f5 ? ve2(P5, U4) : P5);
            A5[y5] = G5, k5[y5] = G5 - I5;
          }
          if (a5) {
            var J4, Z4 = "x" === y5 ? zt2 : Vt2, tt3 = "x" === y5 ? Rt2 : qt2, et3 = A5[w6], it3 = "y" === w6 ? "height" : "width", nt3 = et3 + g6[Z4], st3 = et3 - g6[tt3], ot3 = -1 !== [zt2, Vt2].indexOf(_5), rt3 = null != (J4 = null == x6 ? void 0 : x6[w6]) ? J4 : 0, at3 = ot3 ? nt3 : et3 - E4[it3] - T6[it3] - rt3 + O4.altAxis, lt3 = ot3 ? et3 + E4[it3] + T6[it3] - rt3 - O4.altAxis : st3, ct3 = f5 && ot3 ? function(t7, e6, i6) {
              var n5 = Ne2(t7, e6, i6);
              return n5 > i6 ? i6 : n5;
            }(at3, et3, lt3) : Ne2(f5 ? at3 : nt3, et3, f5 ? lt3 : st3);
            A5[w6] = ct3, k5[w6] = ct3 - et3;
          }
          e5.modifiersData[n4] = k5;
        }
      }, requiresIfExists: ["offset"] };
      function di2(t6, e5, i5) {
        void 0 === i5 && (i5 = false);
        var n4, s5, o4 = me2(e5), r5 = me2(e5) && function(t7) {
          var e6 = t7.getBoundingClientRect(), i6 = we2(e6.width) / t7.offsetWidth || 1, n5 = we2(e6.height) / t7.offsetHeight || 1;
          return 1 !== i6 || 1 !== n5;
        }(e5), a5 = Le2(e5), l5 = Te2(t6, r5, i5), c5 = { scrollLeft: 0, scrollTop: 0 }, h5 = { x: 0, y: 0 };
        return (o4 || !o4 && !i5) && (("body" !== ue2(e5) || Ue2(a5)) && (c5 = (n4 = e5) !== fe2(n4) && me2(n4) ? { scrollLeft: (s5 = n4).scrollLeft, scrollTop: s5.scrollTop } : Xe2(n4)), me2(e5) ? ((h5 = Te2(e5, true)).x += e5.clientLeft, h5.y += e5.clientTop) : a5 && (h5.x = Ye2(a5))), { x: l5.left + c5.scrollLeft - h5.x, y: l5.top + c5.scrollTop - h5.y, width: l5.width, height: l5.height };
      }
      function ui2(t6) {
        var e5 = /* @__PURE__ */ new Map(), i5 = /* @__PURE__ */ new Set(), n4 = [];
        function s5(t7) {
          i5.add(t7.name), [].concat(t7.requires || [], t7.requiresIfExists || []).forEach(function(t8) {
            if (!i5.has(t8)) {
              var n5 = e5.get(t8);
              n5 && s5(n5);
            }
          }), n4.push(t7);
        }
        return t6.forEach(function(t7) {
          e5.set(t7.name, t7);
        }), t6.forEach(function(t7) {
          i5.has(t7.name) || s5(t7);
        }), n4;
      }
      var fi2 = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function pi2() {
        for (var t6 = arguments.length, e5 = new Array(t6), i5 = 0; i5 < t6; i5++) e5[i5] = arguments[i5];
        return !e5.some(function(t7) {
          return !(t7 && "function" == typeof t7.getBoundingClientRect);
        });
      }
      function mi2(t6) {
        void 0 === t6 && (t6 = {});
        var e5 = t6, i5 = e5.defaultModifiers, n4 = void 0 === i5 ? [] : i5, s5 = e5.defaultOptions, o4 = void 0 === s5 ? fi2 : s5;
        return function(t7, e6, i6) {
          void 0 === i6 && (i6 = o4);
          var s6, r5, a5 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, fi2, o4), modifiersData: {}, elements: { reference: t7, popper: e6 }, attributes: {}, styles: {} }, l5 = [], c5 = false, h5 = { state: a5, setOptions: function(i7) {
            var s7 = "function" == typeof i7 ? i7(a5.options) : i7;
            d4(), a5.options = Object.assign({}, o4, a5.options, s7), a5.scrollParents = { reference: pe2(t7) ? Je2(t7) : t7.contextElement ? Je2(t7.contextElement) : [], popper: Je2(e6) };
            var r6, c6, u5 = function(t8) {
              var e7 = ui2(t8);
              return de2.reduce(function(t9, i8) {
                return t9.concat(e7.filter(function(t10) {
                  return t10.phase === i8;
                }));
              }, []);
            }((r6 = [].concat(n4, a5.options.modifiers), c6 = r6.reduce(function(t8, e7) {
              var i8 = t8[e7.name];
              return t8[e7.name] = i8 ? Object.assign({}, i8, e7, { options: Object.assign({}, i8.options, e7.options), data: Object.assign({}, i8.data, e7.data) }) : e7, t8;
            }, {}), Object.keys(c6).map(function(t8) {
              return c6[t8];
            })));
            return a5.orderedModifiers = u5.filter(function(t8) {
              return t8.enabled;
            }), a5.orderedModifiers.forEach(function(t8) {
              var e7 = t8.name, i8 = t8.options, n5 = void 0 === i8 ? {} : i8, s8 = t8.effect;
              if ("function" == typeof s8) {
                var o5 = s8({ state: a5, name: e7, instance: h5, options: n5 });
                l5.push(o5 || function() {
                });
              }
            }), h5.update();
          }, forceUpdate: function() {
            if (!c5) {
              var t8 = a5.elements, e7 = t8.reference, i7 = t8.popper;
              if (pi2(e7, i7)) {
                a5.rects = { reference: di2(e7, $e2(i7), "fixed" === a5.options.strategy), popper: Ce2(i7) }, a5.reset = false, a5.placement = a5.options.placement, a5.orderedModifiers.forEach(function(t9) {
                  return a5.modifiersData[t9.name] = Object.assign({}, t9.data);
                });
                for (var n5 = 0; n5 < a5.orderedModifiers.length; n5++) if (true !== a5.reset) {
                  var s7 = a5.orderedModifiers[n5], o5 = s7.fn, r6 = s7.options, l6 = void 0 === r6 ? {} : r6, d5 = s7.name;
                  "function" == typeof o5 && (a5 = o5({ state: a5, options: l6, name: d5, instance: h5 }) || a5);
                } else a5.reset = false, n5 = -1;
              }
            }
          }, update: (s6 = function() {
            return new Promise(function(t8) {
              h5.forceUpdate(), t8(a5);
            });
          }, function() {
            return r5 || (r5 = new Promise(function(t8) {
              Promise.resolve().then(function() {
                r5 = void 0, t8(s6());
              });
            })), r5;
          }), destroy: function() {
            d4(), c5 = true;
          } };
          if (!pi2(t7, e6)) return h5;
          function d4() {
            l5.forEach(function(t8) {
              return t8();
            }), l5 = [];
          }
          return h5.setOptions(i6).then(function(t8) {
            !c5 && i6.onFirstUpdate && i6.onFirstUpdate(t8);
          }), h5;
        };
      }
      var gi2 = mi2(), _i2 = mi2({ defaultModifiers: [Re2, ci2, Be2, _e2] }), bi2 = mi2({ defaultModifiers: [Re2, ci2, Be2, _e2, li2, si2, hi2, Me2, ai2] });
      const vi2 = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: ae2, afterRead: se2, afterWrite: he2, applyStyles: _e2, arrow: Me2, auto: Kt2, basePlacements: Qt2, beforeMain: oe2, beforeRead: ie2, beforeWrite: le2, bottom: Rt2, clippingParents: Ut2, computeStyles: Be2, createPopper: bi2, createPopperBase: gi2, createPopperLite: _i2, detectOverflow: ii2, end: Yt2, eventListeners: Re2, flip: si2, hide: ai2, left: Vt2, main: re2, modifierPhases: de2, offset: li2, placements: ee2, popper: Jt2, popperGenerator: mi2, popperOffsets: ci2, preventOverflow: hi2, read: ne2, reference: Zt2, right: qt2, start: Xt2, top: zt2, variationPlacements: te2, viewport: Gt2, write: ce2 }, Symbol.toStringTag, { value: "Module" })), yi2 = "dropdown", wi2 = ".bs.dropdown", Ai2 = ".data-api", Ei2 = "ArrowUp", Ti2 = "ArrowDown", Ci2 = `hide${wi2}`, Oi2 = `hidden${wi2}`, xi2 = `show${wi2}`, ki2 = `shown${wi2}`, Li2 = `click${wi2}${Ai2}`, Si2 = `keydown${wi2}${Ai2}`, Di2 = `keyup${wi2}${Ai2}`, $i2 = "show", Ii2 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Ni2 = `${Ii2}.${$i2}`, Pi2 = ".dropdown-menu", ji2 = p4() ? "top-end" : "top-start", Mi2 = p4() ? "top-start" : "top-end", Fi2 = p4() ? "bottom-end" : "bottom-start", Hi2 = p4() ? "bottom-start" : "bottom-end", Wi2 = p4() ? "left-start" : "right-start", Bi2 = p4() ? "right-start" : "left-start", zi2 = { autoClose: true, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, Ri2 = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
      class qi2 extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._popper = null, this._parent = this._element.parentNode, this._menu = z4.next(this._element, Pi2)[0] || z4.prev(this._element, Pi2)[0] || z4.findOne(Pi2, this._parent), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
          return zi2;
        }
        static get DefaultType() {
          return Ri2;
        }
        static get NAME() {
          return yi2;
        }
        toggle() {
          return this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (l4(this._element) || this._isShown()) return;
          const t6 = { relatedTarget: this._element };
          if (!N4.trigger(this._element, xi2, t6).defaultPrevented) {
            if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t7 of [].concat(...document.body.children)) N4.on(t7, "mouseover", h4);
            this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add($i2), this._element.classList.add($i2), N4.trigger(this._element, ki2, t6);
          }
        }
        hide() {
          if (l4(this._element) || !this._isShown()) return;
          const t6 = { relatedTarget: this._element };
          this._completeHide(t6);
        }
        dispose() {
          this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
          this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t6) {
          if (!N4.trigger(this._element, Ci2, t6).defaultPrevented) {
            if ("ontouchstart" in document.documentElement) for (const t7 of [].concat(...document.body.children)) N4.off(t7, "mouseover", h4);
            this._popper && this._popper.destroy(), this._menu.classList.remove($i2), this._element.classList.remove($i2), this._element.setAttribute("aria-expanded", "false"), F5.removeDataAttribute(this._menu, "popper"), N4.trigger(this._element, Oi2, t6);
          }
        }
        _getConfig(t6) {
          if ("object" == typeof (t6 = super._getConfig(t6)).reference && !o3(t6.reference) && "function" != typeof t6.reference.getBoundingClientRect) throw new TypeError(`${yi2.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
          return t6;
        }
        _createPopper() {
          if (void 0 === vi2) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
          let t6 = this._element;
          "parent" === this._config.reference ? t6 = this._parent : o3(this._config.reference) ? t6 = r4(this._config.reference) : "object" == typeof this._config.reference && (t6 = this._config.reference);
          const e5 = this._getPopperConfig();
          this._popper = bi2(t6, this._menu, e5);
        }
        _isShown() {
          return this._menu.classList.contains($i2);
        }
        _getPlacement() {
          const t6 = this._parent;
          if (t6.classList.contains("dropend")) return Wi2;
          if (t6.classList.contains("dropstart")) return Bi2;
          if (t6.classList.contains("dropup-center")) return "top";
          if (t6.classList.contains("dropdown-center")) return "bottom";
          const e5 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
          return t6.classList.contains("dropup") ? e5 ? Mi2 : ji2 : e5 ? Hi2 : Fi2;
        }
        _detectNavbar() {
          return null !== this._element.closest(".navbar");
        }
        _getOffset() {
          const { offset: t6 } = this._config;
          return "string" == typeof t6 ? t6.split(",").map((t7) => Number.parseInt(t7, 10)) : "function" == typeof t6 ? (e5) => t6(e5, this._element) : t6;
        }
        _getPopperConfig() {
          const t6 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
          return (this._inNavbar || "static" === this._config.display) && (F5.setDataAttribute(this._menu, "popper", "static"), t6.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t6, ...g5(this._config.popperConfig, [t6]) };
        }
        _selectMenuItem({ key: t6, target: e5 }) {
          const i5 = z4.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t7) => a4(t7));
          i5.length && b4(i5, e5, t6 === Ti2, !i5.includes(e5)).focus();
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = qi2.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6]) throw new TypeError(`No method named "${t6}"`);
              e5[t6]();
            }
          });
        }
        static clearMenus(t6) {
          if (2 === t6.button || "keyup" === t6.type && "Tab" !== t6.key) return;
          const e5 = z4.find(Ni2);
          for (const i5 of e5) {
            const e6 = qi2.getInstance(i5);
            if (!e6 || false === e6._config.autoClose) continue;
            const n4 = t6.composedPath(), s5 = n4.includes(e6._menu);
            if (n4.includes(e6._element) || "inside" === e6._config.autoClose && !s5 || "outside" === e6._config.autoClose && s5) continue;
            if (e6._menu.contains(t6.target) && ("keyup" === t6.type && "Tab" === t6.key || /input|select|option|textarea|form/i.test(t6.target.tagName))) continue;
            const o4 = { relatedTarget: e6._element };
            "click" === t6.type && (o4.clickEvent = t6), e6._completeHide(o4);
          }
        }
        static dataApiKeydownHandler(t6) {
          const e5 = /input|textarea/i.test(t6.target.tagName), i5 = "Escape" === t6.key, n4 = [Ei2, Ti2].includes(t6.key);
          if (!n4 && !i5) return;
          if (e5 && !i5) return;
          t6.preventDefault();
          const s5 = this.matches(Ii2) ? this : z4.prev(this, Ii2)[0] || z4.next(this, Ii2)[0] || z4.findOne(Ii2, t6.delegateTarget.parentNode), o4 = qi2.getOrCreateInstance(s5);
          if (n4) return t6.stopPropagation(), o4.show(), void o4._selectMenuItem(t6);
          o4._isShown() && (t6.stopPropagation(), o4.hide(), s5.focus());
        }
      }
      N4.on(document, Si2, Ii2, qi2.dataApiKeydownHandler), N4.on(document, Si2, Pi2, qi2.dataApiKeydownHandler), N4.on(document, Li2, qi2.clearMenus), N4.on(document, Di2, qi2.clearMenus), N4.on(document, Li2, Ii2, function(t6) {
        t6.preventDefault(), qi2.getOrCreateInstance(this).toggle();
      }), m5(qi2);
      const Vi2 = "backdrop", Ki2 = "show", Qi2 = `mousedown.bs.${Vi2}`, Xi2 = { className: "modal-backdrop", clickCallback: null, isAnimated: false, isVisible: true, rootElement: "body" }, Yi2 = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
      class Ui2 extends H4 {
        constructor(t6) {
          super(), this._config = this._getConfig(t6), this._isAppended = false, this._element = null;
        }
        static get Default() {
          return Xi2;
        }
        static get DefaultType() {
          return Yi2;
        }
        static get NAME() {
          return Vi2;
        }
        show(t6) {
          if (!this._config.isVisible) return void g5(t6);
          this._append();
          const e5 = this._getElement();
          this._config.isAnimated && d3(e5), e5.classList.add(Ki2), this._emulateAnimation(() => {
            g5(t6);
          });
        }
        hide(t6) {
          this._config.isVisible ? (this._getElement().classList.remove(Ki2), this._emulateAnimation(() => {
            this.dispose(), g5(t6);
          })) : g5(t6);
        }
        dispose() {
          this._isAppended && (N4.off(this._element, Qi2), this._element.remove(), this._isAppended = false);
        }
        _getElement() {
          if (!this._element) {
            const t6 = document.createElement("div");
            t6.className = this._config.className, this._config.isAnimated && t6.classList.add("fade"), this._element = t6;
          }
          return this._element;
        }
        _configAfterMerge(t6) {
          return t6.rootElement = r4(t6.rootElement), t6;
        }
        _append() {
          if (this._isAppended) return;
          const t6 = this._getElement();
          this._config.rootElement.append(t6), N4.on(t6, Qi2, () => {
            g5(this._config.clickCallback);
          }), this._isAppended = true;
        }
        _emulateAnimation(t6) {
          _4(t6, this._getElement(), this._config.isAnimated);
        }
      }
      const Gi2 = ".bs.focustrap", Ji2 = `focusin${Gi2}`, Zi2 = `keydown.tab${Gi2}`, tn3 = "backward", en3 = { autofocus: true, trapElement: null }, nn3 = { autofocus: "boolean", trapElement: "element" };
      class sn2 extends H4 {
        constructor(t6) {
          super(), this._config = this._getConfig(t6), this._isActive = false, this._lastTabNavDirection = null;
        }
        static get Default() {
          return en3;
        }
        static get DefaultType() {
          return nn3;
        }
        static get NAME() {
          return "focustrap";
        }
        activate() {
          this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N4.off(document, Gi2), N4.on(document, Ji2, (t6) => this._handleFocusin(t6)), N4.on(document, Zi2, (t6) => this._handleKeydown(t6)), this._isActive = true);
        }
        deactivate() {
          this._isActive && (this._isActive = false, N4.off(document, Gi2));
        }
        _handleFocusin(t6) {
          const { trapElement: e5 } = this._config;
          if (t6.target === document || t6.target === e5 || e5.contains(t6.target)) return;
          const i5 = z4.focusableChildren(e5);
          0 === i5.length ? e5.focus() : this._lastTabNavDirection === tn3 ? i5[i5.length - 1].focus() : i5[0].focus();
        }
        _handleKeydown(t6) {
          "Tab" === t6.key && (this._lastTabNavDirection = t6.shiftKey ? tn3 : "forward");
        }
      }
      const on2 = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", rn2 = ".sticky-top", an2 = "padding-right", ln2 = "margin-right";
      class cn2 {
        constructor() {
          this._element = document.body;
        }
        getWidth() {
          const t6 = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - t6);
        }
        hide() {
          const t6 = this.getWidth();
          this._disableOverFlow(), this._setElementAttributes(this._element, an2, (e5) => e5 + t6), this._setElementAttributes(on2, an2, (e5) => e5 + t6), this._setElementAttributes(rn2, ln2, (e5) => e5 - t6);
        }
        reset() {
          this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, an2), this._resetElementAttributes(on2, an2), this._resetElementAttributes(rn2, ln2);
        }
        isOverflowing() {
          return this.getWidth() > 0;
        }
        _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t6, e5, i5) {
          const n4 = this.getWidth();
          this._applyManipulationCallback(t6, (t7) => {
            if (t7 !== this._element && window.innerWidth > t7.clientWidth + n4) return;
            this._saveInitialAttribute(t7, e5);
            const s5 = window.getComputedStyle(t7).getPropertyValue(e5);
            t7.style.setProperty(e5, `${i5(Number.parseFloat(s5))}px`);
          });
        }
        _saveInitialAttribute(t6, e5) {
          const i5 = t6.style.getPropertyValue(e5);
          i5 && F5.setDataAttribute(t6, e5, i5);
        }
        _resetElementAttributes(t6, e5) {
          this._applyManipulationCallback(t6, (t7) => {
            const i5 = F5.getDataAttribute(t7, e5);
            null !== i5 ? (F5.removeDataAttribute(t7, e5), t7.style.setProperty(e5, i5)) : t7.style.removeProperty(e5);
          });
        }
        _applyManipulationCallback(t6, e5) {
          if (o3(t6)) e5(t6);
          else for (const i5 of z4.find(t6, this._element)) e5(i5);
        }
      }
      const hn2 = ".bs.modal", dn2 = `hide${hn2}`, un2 = `hidePrevented${hn2}`, fn2 = `hidden${hn2}`, pn2 = `show${hn2}`, mn2 = `shown${hn2}`, gn2 = `resize${hn2}`, _n2 = `click.dismiss${hn2}`, bn2 = `mousedown.dismiss${hn2}`, vn2 = `keydown.dismiss${hn2}`, yn2 = `click${hn2}.data-api`, wn2 = "modal-open", An2 = "show", En2 = "modal-static", Tn2 = { backdrop: true, focus: true, keyboard: true }, Cn2 = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
      class On2 extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._dialog = z4.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._isTransitioning = false, this._scrollBar = new cn2(), this._addEventListeners();
        }
        static get Default() {
          return Tn2;
        }
        static get DefaultType() {
          return Cn2;
        }
        static get NAME() {
          return "modal";
        }
        toggle(t6) {
          return this._isShown ? this.hide() : this.show(t6);
        }
        show(t6) {
          this._isShown || this._isTransitioning || N4.trigger(this._element, pn2, { relatedTarget: t6 }).defaultPrevented || (this._isShown = true, this._isTransitioning = true, this._scrollBar.hide(), document.body.classList.add(wn2), this._adjustDialog(), this._backdrop.show(() => this._showElement(t6)));
        }
        hide() {
          this._isShown && !this._isTransitioning && (N4.trigger(this._element, dn2).defaultPrevented || (this._isShown = false, this._isTransitioning = true, this._focustrap.deactivate(), this._element.classList.remove(An2), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
        }
        dispose() {
          N4.off(window, hn2), N4.off(this._dialog, hn2), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
          this._adjustDialog();
        }
        _initializeBackDrop() {
          return new Ui2({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
        }
        _initializeFocusTrap() {
          return new sn2({ trapElement: this._element });
        }
        _showElement(t6) {
          document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
          const e5 = z4.findOne(".modal-body", this._dialog);
          e5 && (e5.scrollTop = 0), d3(this._element), this._element.classList.add(An2), this._queueCallback(() => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = false, N4.trigger(this._element, mn2, { relatedTarget: t6 });
          }, this._dialog, this._isAnimated());
        }
        _addEventListeners() {
          N4.on(this._element, vn2, (t6) => {
            "Escape" === t6.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
          }), N4.on(window, gn2, () => {
            this._isShown && !this._isTransitioning && this._adjustDialog();
          }), N4.on(this._element, bn2, (t6) => {
            N4.one(this._element, _n2, (e5) => {
              this._element === t6.target && this._element === e5.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
            });
          });
        }
        _hideModal() {
          this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
            document.body.classList.remove(wn2), this._resetAdjustments(), this._scrollBar.reset(), N4.trigger(this._element, fn2);
          });
        }
        _isAnimated() {
          return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
          if (N4.trigger(this._element, un2).defaultPrevented) return;
          const t6 = this._element.scrollHeight > document.documentElement.clientHeight, e5 = this._element.style.overflowY;
          "hidden" === e5 || this._element.classList.contains(En2) || (t6 || (this._element.style.overflowY = "hidden"), this._element.classList.add(En2), this._queueCallback(() => {
            this._element.classList.remove(En2), this._queueCallback(() => {
              this._element.style.overflowY = e5;
            }, this._dialog);
          }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
          const t6 = this._element.scrollHeight > document.documentElement.clientHeight, e5 = this._scrollBar.getWidth(), i5 = e5 > 0;
          if (i5 && !t6) {
            const t7 = p4() ? "paddingLeft" : "paddingRight";
            this._element.style[t7] = `${e5}px`;
          }
          if (!i5 && t6) {
            const t7 = p4() ? "paddingRight" : "paddingLeft";
            this._element.style[t7] = `${e5}px`;
          }
        }
        _resetAdjustments() {
          this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(t6, e5) {
          return this.each(function() {
            const i5 = On2.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === i5[t6]) throw new TypeError(`No method named "${t6}"`);
              i5[t6](e5);
            }
          });
        }
      }
      N4.on(document, yn2, '[data-bs-toggle="modal"]', function(t6) {
        const e5 = z4.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && t6.preventDefault(), N4.one(e5, pn2, (t7) => {
          t7.defaultPrevented || N4.one(e5, fn2, () => {
            a4(this) && this.focus();
          });
        });
        const i5 = z4.findOne(".modal.show");
        i5 && On2.getInstance(i5).hide(), On2.getOrCreateInstance(e5).toggle(this);
      }), R2(On2), m5(On2);
      const xn2 = ".bs.offcanvas", kn2 = ".data-api", Ln2 = `load${xn2}${kn2}`, Sn2 = "show", Dn2 = "showing", $n2 = "hiding", In2 = ".offcanvas.show", Nn2 = `show${xn2}`, Pn2 = `shown${xn2}`, jn2 = `hide${xn2}`, Mn2 = `hidePrevented${xn2}`, Fn2 = `hidden${xn2}`, Hn2 = `resize${xn2}`, Wn2 = `click${xn2}${kn2}`, Bn2 = `keydown.dismiss${xn2}`, zn2 = { backdrop: true, keyboard: true, scroll: false }, Rn2 = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
      class qn2 extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get Default() {
          return zn2;
        }
        static get DefaultType() {
          return Rn2;
        }
        static get NAME() {
          return "offcanvas";
        }
        toggle(t6) {
          return this._isShown ? this.hide() : this.show(t6);
        }
        show(t6) {
          this._isShown || N4.trigger(this._element, Nn2, { relatedTarget: t6 }).defaultPrevented || (this._isShown = true, this._backdrop.show(), this._config.scroll || new cn2().hide(), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(Dn2), this._queueCallback(() => {
            this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Sn2), this._element.classList.remove(Dn2), N4.trigger(this._element, Pn2, { relatedTarget: t6 });
          }, this._element, true));
        }
        hide() {
          this._isShown && (N4.trigger(this._element, jn2).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.add($n2), this._backdrop.hide(), this._queueCallback(() => {
            this._element.classList.remove(Sn2, $n2), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new cn2().reset(), N4.trigger(this._element, Fn2);
          }, this._element, true)));
        }
        dispose() {
          this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _initializeBackDrop() {
          const t6 = Boolean(this._config.backdrop);
          return new Ui2({ className: "offcanvas-backdrop", isVisible: t6, isAnimated: true, rootElement: this._element.parentNode, clickCallback: t6 ? () => {
            "static" !== this._config.backdrop ? this.hide() : N4.trigger(this._element, Mn2);
          } : null });
        }
        _initializeFocusTrap() {
          return new sn2({ trapElement: this._element });
        }
        _addEventListeners() {
          N4.on(this._element, Bn2, (t6) => {
            "Escape" === t6.key && (this._config.keyboard ? this.hide() : N4.trigger(this._element, Mn2));
          });
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = qn2.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6] || t6.startsWith("_") || "constructor" === t6) throw new TypeError(`No method named "${t6}"`);
              e5[t6](this);
            }
          });
        }
      }
      N4.on(document, Wn2, '[data-bs-toggle="offcanvas"]', function(t6) {
        const e5 = z4.getElementFromSelector(this);
        if (["A", "AREA"].includes(this.tagName) && t6.preventDefault(), l4(this)) return;
        N4.one(e5, Fn2, () => {
          a4(this) && this.focus();
        });
        const i5 = z4.findOne(In2);
        i5 && i5 !== e5 && qn2.getInstance(i5).hide(), qn2.getOrCreateInstance(e5).toggle(this);
      }), N4.on(window, Ln2, () => {
        for (const t6 of z4.find(In2)) qn2.getOrCreateInstance(t6).show();
      }), N4.on(window, Hn2, () => {
        for (const t6 of z4.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t6).position && qn2.getOrCreateInstance(t6).hide();
      }), R2(qn2), m5(qn2);
      const Vn2 = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, Kn2 = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Qn2 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Xn2 = (t6, e5) => {
        const i5 = t6.nodeName.toLowerCase();
        return e5.includes(i5) ? !Kn2.has(i5) || Boolean(Qn2.test(t6.nodeValue)) : e5.filter((t7) => t7 instanceof RegExp).some((t7) => t7.test(i5));
      }, Yn2 = { allowList: Vn2, content: {}, extraClass: "", html: false, sanitize: true, sanitizeFn: null, template: "<div></div>" }, Un2 = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, Gn2 = { entry: "(string|element|function|null)", selector: "(string|element)" };
      class Jn2 extends H4 {
        constructor(t6) {
          super(), this._config = this._getConfig(t6);
        }
        static get Default() {
          return Yn2;
        }
        static get DefaultType() {
          return Un2;
        }
        static get NAME() {
          return "TemplateFactory";
        }
        getContent() {
          return Object.values(this._config.content).map((t6) => this._resolvePossibleFunction(t6)).filter(Boolean);
        }
        hasContent() {
          return this.getContent().length > 0;
        }
        changeContent(t6) {
          return this._checkContent(t6), this._config.content = { ...this._config.content, ...t6 }, this;
        }
        toHtml() {
          const t6 = document.createElement("div");
          t6.innerHTML = this._maybeSanitize(this._config.template);
          for (const [e6, i6] of Object.entries(this._config.content)) this._setContent(t6, i6, e6);
          const e5 = t6.children[0], i5 = this._resolvePossibleFunction(this._config.extraClass);
          return i5 && e5.classList.add(...i5.split(" ")), e5;
        }
        _typeCheckConfig(t6) {
          super._typeCheckConfig(t6), this._checkContent(t6.content);
        }
        _checkContent(t6) {
          for (const [e5, i5] of Object.entries(t6)) super._typeCheckConfig({ selector: e5, entry: i5 }, Gn2);
        }
        _setContent(t6, e5, i5) {
          const n4 = z4.findOne(i5, t6);
          n4 && ((e5 = this._resolvePossibleFunction(e5)) ? o3(e5) ? this._putElementInTemplate(r4(e5), n4) : this._config.html ? n4.innerHTML = this._maybeSanitize(e5) : n4.textContent = e5 : n4.remove());
        }
        _maybeSanitize(t6) {
          return this._config.sanitize ? function(t7, e5, i5) {
            if (!t7.length) return t7;
            if (i5 && "function" == typeof i5) return i5(t7);
            const n4 = new window.DOMParser().parseFromString(t7, "text/html"), s5 = [].concat(...n4.body.querySelectorAll("*"));
            for (const t8 of s5) {
              const i6 = t8.nodeName.toLowerCase();
              if (!Object.keys(e5).includes(i6)) {
                t8.remove();
                continue;
              }
              const n5 = [].concat(...t8.attributes), s6 = [].concat(e5["*"] || [], e5[i6] || []);
              for (const e6 of n5) Xn2(e6, s6) || t8.removeAttribute(e6.nodeName);
            }
            return n4.body.innerHTML;
          }(t6, this._config.allowList, this._config.sanitizeFn) : t6;
        }
        _resolvePossibleFunction(t6) {
          return g5(t6, [this]);
        }
        _putElementInTemplate(t6, e5) {
          if (this._config.html) return e5.innerHTML = "", void e5.append(t6);
          e5.textContent = t6.textContent;
        }
      }
      const Zn2 = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ts = "fade", es = "show", is = ".modal", ns = "hide.bs.modal", ss = "hover", os = "focus", rs = { AUTO: "auto", TOP: "top", RIGHT: p4() ? "left" : "right", BOTTOM: "bottom", LEFT: p4() ? "right" : "left" }, as = { allowList: Vn2, animation: true, boundary: "clippingParents", container: false, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: false, offset: [0, 6], placement: "top", popperConfig: null, sanitize: true, sanitizeFn: null, selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, ls = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
      class cs extends W3 {
        constructor(t6, e5) {
          if (void 0 === vi2) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
          super(t6, e5), this._isEnabled = true, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
        }
        static get Default() {
          return as;
        }
        static get DefaultType() {
          return ls;
        }
        static get NAME() {
          return "tooltip";
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        }
        toggle() {
          this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter());
        }
        dispose() {
          clearTimeout(this._timeout), N4.off(this._element.closest(is), ns, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
        }
        show() {
          if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
          if (!this._isWithContent() || !this._isEnabled) return;
          const t6 = N4.trigger(this._element, this.constructor.eventName("show")), e5 = (c4(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
          if (t6.defaultPrevented || !e5) return;
          this._disposePopper();
          const i5 = this._getTipElement();
          this._element.setAttribute("aria-describedby", i5.getAttribute("id"));
          const { container: n4 } = this._config;
          if (this._element.ownerDocument.documentElement.contains(this.tip) || (n4.append(i5), N4.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i5), i5.classList.add(es), "ontouchstart" in document.documentElement) for (const t7 of [].concat(...document.body.children)) N4.on(t7, "mouseover", h4);
          this._queueCallback(() => {
            N4.trigger(this._element, this.constructor.eventName("shown")), false === this._isHovered && this._leave(), this._isHovered = false;
          }, this.tip, this._isAnimated());
        }
        hide() {
          if (this._isShown() && !N4.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
            if (this._getTipElement().classList.remove(es), "ontouchstart" in document.documentElement) for (const t6 of [].concat(...document.body.children)) N4.off(t6, "mouseover", h4);
            this._activeTrigger.click = false, this._activeTrigger[os] = false, this._activeTrigger[ss] = false, this._isHovered = null, this._queueCallback(() => {
              this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N4.trigger(this._element, this.constructor.eventName("hidden")));
            }, this.tip, this._isAnimated());
          }
        }
        update() {
          this._popper && this._popper.update();
        }
        _isWithContent() {
          return Boolean(this._getTitle());
        }
        _getTipElement() {
          return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
        }
        _createTipElement(t6) {
          const e5 = this._getTemplateFactory(t6).toHtml();
          if (!e5) return null;
          e5.classList.remove(ts, es), e5.classList.add(`bs-${this.constructor.NAME}-auto`);
          const i5 = ((t7) => {
            do {
              t7 += Math.floor(1e6 * Math.random());
            } while (document.getElementById(t7));
            return t7;
          })(this.constructor.NAME).toString();
          return e5.setAttribute("id", i5), this._isAnimated() && e5.classList.add(ts), e5;
        }
        setContent(t6) {
          this._newContent = t6, this._isShown() && (this._disposePopper(), this.show());
        }
        _getTemplateFactory(t6) {
          return this._templateFactory ? this._templateFactory.changeContent(t6) : this._templateFactory = new Jn2({ ...this._config, content: t6, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory;
        }
        _getContentForTemplate() {
          return { ".tooltip-inner": this._getTitle() };
        }
        _getTitle() {
          return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
        }
        _initializeOnDelegatedTarget(t6) {
          return this.constructor.getOrCreateInstance(t6.delegateTarget, this._getDelegateConfig());
        }
        _isAnimated() {
          return this._config.animation || this.tip && this.tip.classList.contains(ts);
        }
        _isShown() {
          return this.tip && this.tip.classList.contains(es);
        }
        _createPopper(t6) {
          const e5 = g5(this._config.placement, [this, t6, this._element]), i5 = rs[e5.toUpperCase()];
          return bi2(this._element, t6, this._getPopperConfig(i5));
        }
        _getOffset() {
          const { offset: t6 } = this._config;
          return "string" == typeof t6 ? t6.split(",").map((t7) => Number.parseInt(t7, 10)) : "function" == typeof t6 ? (e5) => t6(e5, this._element) : t6;
        }
        _resolvePossibleFunction(t6) {
          return g5(t6, [this._element]);
        }
        _getPopperConfig(t6) {
          const e5 = { placement: t6, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: true, phase: "beforeMain", fn: (t7) => {
            this._getTipElement().setAttribute("data-popper-placement", t7.state.placement);
          } }] };
          return { ...e5, ...g5(this._config.popperConfig, [e5]) };
        }
        _setListeners() {
          const t6 = this._config.trigger.split(" ");
          for (const e5 of t6) if ("click" === e5) N4.on(this._element, this.constructor.eventName("click"), this._config.selector, (t7) => {
            this._initializeOnDelegatedTarget(t7).toggle();
          });
          else if ("manual" !== e5) {
            const t7 = e5 === ss ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i5 = e5 === ss ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
            N4.on(this._element, t7, this._config.selector, (t8) => {
              const e6 = this._initializeOnDelegatedTarget(t8);
              e6._activeTrigger["focusin" === t8.type ? os : ss] = true, e6._enter();
            }), N4.on(this._element, i5, this._config.selector, (t8) => {
              const e6 = this._initializeOnDelegatedTarget(t8);
              e6._activeTrigger["focusout" === t8.type ? os : ss] = e6._element.contains(t8.relatedTarget), e6._leave();
            });
          }
          this._hideModalHandler = () => {
            this._element && this.hide();
          }, N4.on(this._element.closest(is), ns, this._hideModalHandler);
        }
        _fixTitle() {
          const t6 = this._element.getAttribute("title");
          t6 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t6), this._element.setAttribute("data-bs-original-title", t6), this._element.removeAttribute("title"));
        }
        _enter() {
          this._isShown() || this._isHovered ? this._isHovered = true : (this._isHovered = true, this._setTimeout(() => {
            this._isHovered && this.show();
          }, this._config.delay.show));
        }
        _leave() {
          this._isWithActiveTrigger() || (this._isHovered = false, this._setTimeout(() => {
            this._isHovered || this.hide();
          }, this._config.delay.hide));
        }
        _setTimeout(t6, e5) {
          clearTimeout(this._timeout), this._timeout = setTimeout(t6, e5);
        }
        _isWithActiveTrigger() {
          return Object.values(this._activeTrigger).includes(true);
        }
        _getConfig(t6) {
          const e5 = F5.getDataAttributes(this._element);
          for (const t7 of Object.keys(e5)) Zn2.has(t7) && delete e5[t7];
          return t6 = { ...e5, ..."object" == typeof t6 && t6 ? t6 : {} }, t6 = this._mergeConfigObj(t6), t6 = this._configAfterMerge(t6), this._typeCheckConfig(t6), t6;
        }
        _configAfterMerge(t6) {
          return t6.container = false === t6.container ? document.body : r4(t6.container), "number" == typeof t6.delay && (t6.delay = { show: t6.delay, hide: t6.delay }), "number" == typeof t6.title && (t6.title = t6.title.toString()), "number" == typeof t6.content && (t6.content = t6.content.toString()), t6;
        }
        _getDelegateConfig() {
          const t6 = {};
          for (const [e5, i5] of Object.entries(this._config)) this.constructor.Default[e5] !== i5 && (t6[e5] = i5);
          return t6.selector = false, t6.trigger = "manual", t6;
        }
        _disposePopper() {
          this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = cs.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6]) throw new TypeError(`No method named "${t6}"`);
              e5[t6]();
            }
          });
        }
      }
      m5(cs);
      const hs = { ...cs.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, ds = { ...cs.DefaultType, content: "(null|string|element|function)" };
      class us extends cs {
        static get Default() {
          return hs;
        }
        static get DefaultType() {
          return ds;
        }
        static get NAME() {
          return "popover";
        }
        _isWithContent() {
          return this._getTitle() || this._getContent();
        }
        _getContentForTemplate() {
          return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() };
        }
        _getContent() {
          return this._resolvePossibleFunction(this._config.content);
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = us.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6]) throw new TypeError(`No method named "${t6}"`);
              e5[t6]();
            }
          });
        }
      }
      m5(us);
      const fs = ".bs.scrollspy", ps = `activate${fs}`, ms = `click${fs}`, gs = `load${fs}.data-api`, _s = "active", bs = "[href]", vs = ".nav-link", ys = `${vs}, .nav-item > ${vs}, .list-group-item`, ws = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: false, target: null, threshold: [0.1, 0.5, 1] }, As = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
      class Es extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh();
        }
        static get Default() {
          return ws;
        }
        static get DefaultType() {
          return As;
        }
        static get NAME() {
          return "scrollspy";
        }
        refresh() {
          this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
          for (const t6 of this._observableSections.values()) this._observer.observe(t6);
        }
        dispose() {
          this._observer.disconnect(), super.dispose();
        }
        _configAfterMerge(t6) {
          return t6.target = r4(t6.target) || document.body, t6.rootMargin = t6.offset ? `${t6.offset}px 0px -30%` : t6.rootMargin, "string" == typeof t6.threshold && (t6.threshold = t6.threshold.split(",").map((t7) => Number.parseFloat(t7))), t6;
        }
        _maybeEnableSmoothScroll() {
          this._config.smoothScroll && (N4.off(this._config.target, ms), N4.on(this._config.target, ms, bs, (t6) => {
            const e5 = this._observableSections.get(t6.target.hash);
            if (e5) {
              t6.preventDefault();
              const i5 = this._rootElement || window, n4 = e5.offsetTop - this._element.offsetTop;
              if (i5.scrollTo) return void i5.scrollTo({ top: n4, behavior: "smooth" });
              i5.scrollTop = n4;
            }
          }));
        }
        _getNewObserver() {
          const t6 = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
          return new IntersectionObserver((t7) => this._observerCallback(t7), t6);
        }
        _observerCallback(t6) {
          const e5 = (t7) => this._targetLinks.get(`#${t7.target.id}`), i5 = (t7) => {
            this._previousScrollData.visibleEntryTop = t7.target.offsetTop, this._process(e5(t7));
          }, n4 = (this._rootElement || document.documentElement).scrollTop, s5 = n4 >= this._previousScrollData.parentScrollTop;
          this._previousScrollData.parentScrollTop = n4;
          for (const o4 of t6) {
            if (!o4.isIntersecting) {
              this._activeTarget = null, this._clearActiveClass(e5(o4));
              continue;
            }
            const t7 = o4.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (s5 && t7) {
              if (i5(o4), !n4) return;
            } else s5 || t7 || i5(o4);
          }
        }
        _initializeTargetsAndObservables() {
          this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
          const t6 = z4.find(bs, this._config.target);
          for (const e5 of t6) {
            if (!e5.hash || l4(e5)) continue;
            const t7 = z4.findOne(decodeURI(e5.hash), this._element);
            a4(t7) && (this._targetLinks.set(decodeURI(e5.hash), e5), this._observableSections.set(e5.hash, t7));
          }
        }
        _process(t6) {
          this._activeTarget !== t6 && (this._clearActiveClass(this._config.target), this._activeTarget = t6, t6.classList.add(_s), this._activateParents(t6), N4.trigger(this._element, ps, { relatedTarget: t6 }));
        }
        _activateParents(t6) {
          if (t6.classList.contains("dropdown-item")) z4.findOne(".dropdown-toggle", t6.closest(".dropdown")).classList.add(_s);
          else for (const e5 of z4.parents(t6, ".nav, .list-group")) for (const t7 of z4.prev(e5, ys)) t7.classList.add(_s);
        }
        _clearActiveClass(t6) {
          t6.classList.remove(_s);
          const e5 = z4.find(`${bs}.${_s}`, t6);
          for (const t7 of e5) t7.classList.remove(_s);
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = Es.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6] || t6.startsWith("_") || "constructor" === t6) throw new TypeError(`No method named "${t6}"`);
              e5[t6]();
            }
          });
        }
      }
      N4.on(window, gs, () => {
        for (const t6 of z4.find('[data-bs-spy="scroll"]')) Es.getOrCreateInstance(t6);
      }), m5(Es);
      const Ts = ".bs.tab", Cs = `hide${Ts}`, Os = `hidden${Ts}`, xs = `show${Ts}`, ks = `shown${Ts}`, Ls = `click${Ts}`, Ss = `keydown${Ts}`, Ds = `load${Ts}`, $s = "ArrowLeft", Is = "ArrowRight", Ns = "ArrowUp", Ps = "ArrowDown", js = "Home", Ms = "End", Fs = "active", Hs = "fade", Ws = "show", Bs = ".dropdown-toggle", zs = `:not(${Bs})`, Rs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', qs = `.nav-link${zs}, .list-group-item${zs}, [role="tab"]${zs}, ${Rs}`, Vs = `.${Fs}[data-bs-toggle="tab"], .${Fs}[data-bs-toggle="pill"], .${Fs}[data-bs-toggle="list"]`;
      class Ks extends W3 {
        constructor(t6) {
          super(t6), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N4.on(this._element, Ss, (t7) => this._keydown(t7)));
        }
        static get NAME() {
          return "tab";
        }
        show() {
          const t6 = this._element;
          if (this._elemIsActive(t6)) return;
          const e5 = this._getActiveElem(), i5 = e5 ? N4.trigger(e5, Cs, { relatedTarget: t6 }) : null;
          N4.trigger(t6, xs, { relatedTarget: e5 }).defaultPrevented || i5 && i5.defaultPrevented || (this._deactivate(e5, t6), this._activate(t6, e5));
        }
        _activate(t6, e5) {
          t6 && (t6.classList.add(Fs), this._activate(z4.getElementFromSelector(t6)), this._queueCallback(() => {
            "tab" === t6.getAttribute("role") ? (t6.removeAttribute("tabindex"), t6.setAttribute("aria-selected", true), this._toggleDropDown(t6, true), N4.trigger(t6, ks, { relatedTarget: e5 })) : t6.classList.add(Ws);
          }, t6, t6.classList.contains(Hs)));
        }
        _deactivate(t6, e5) {
          t6 && (t6.classList.remove(Fs), t6.blur(), this._deactivate(z4.getElementFromSelector(t6)), this._queueCallback(() => {
            "tab" === t6.getAttribute("role") ? (t6.setAttribute("aria-selected", false), t6.setAttribute("tabindex", "-1"), this._toggleDropDown(t6, false), N4.trigger(t6, Os, { relatedTarget: e5 })) : t6.classList.remove(Ws);
          }, t6, t6.classList.contains(Hs)));
        }
        _keydown(t6) {
          if (![$s, Is, Ns, Ps, js, Ms].includes(t6.key)) return;
          t6.stopPropagation(), t6.preventDefault();
          const e5 = this._getChildren().filter((t7) => !l4(t7));
          let i5;
          if ([js, Ms].includes(t6.key)) i5 = e5[t6.key === js ? 0 : e5.length - 1];
          else {
            const n4 = [Is, Ps].includes(t6.key);
            i5 = b4(e5, t6.target, n4, true);
          }
          i5 && (i5.focus({ preventScroll: true }), Ks.getOrCreateInstance(i5).show());
        }
        _getChildren() {
          return z4.find(qs, this._parent);
        }
        _getActiveElem() {
          return this._getChildren().find((t6) => this._elemIsActive(t6)) || null;
        }
        _setInitialAttributes(t6, e5) {
          this._setAttributeIfNotExists(t6, "role", "tablist");
          for (const t7 of e5) this._setInitialAttributesOnChild(t7);
        }
        _setInitialAttributesOnChild(t6) {
          t6 = this._getInnerElement(t6);
          const e5 = this._elemIsActive(t6), i5 = this._getOuterElement(t6);
          t6.setAttribute("aria-selected", e5), i5 !== t6 && this._setAttributeIfNotExists(i5, "role", "presentation"), e5 || t6.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t6, "role", "tab"), this._setInitialAttributesOnTargetPanel(t6);
        }
        _setInitialAttributesOnTargetPanel(t6) {
          const e5 = z4.getElementFromSelector(t6);
          e5 && (this._setAttributeIfNotExists(e5, "role", "tabpanel"), t6.id && this._setAttributeIfNotExists(e5, "aria-labelledby", `${t6.id}`));
        }
        _toggleDropDown(t6, e5) {
          const i5 = this._getOuterElement(t6);
          if (!i5.classList.contains("dropdown")) return;
          const n4 = (t7, n5) => {
            const s5 = z4.findOne(t7, i5);
            s5 && s5.classList.toggle(n5, e5);
          };
          n4(Bs, Fs), n4(".dropdown-menu", Ws), i5.setAttribute("aria-expanded", e5);
        }
        _setAttributeIfNotExists(t6, e5, i5) {
          t6.hasAttribute(e5) || t6.setAttribute(e5, i5);
        }
        _elemIsActive(t6) {
          return t6.classList.contains(Fs);
        }
        _getInnerElement(t6) {
          return t6.matches(qs) ? t6 : z4.findOne(qs, t6);
        }
        _getOuterElement(t6) {
          return t6.closest(".nav-item, .list-group-item") || t6;
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = Ks.getOrCreateInstance(this);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6] || t6.startsWith("_") || "constructor" === t6) throw new TypeError(`No method named "${t6}"`);
              e5[t6]();
            }
          });
        }
      }
      N4.on(document, Ls, Rs, function(t6) {
        ["A", "AREA"].includes(this.tagName) && t6.preventDefault(), l4(this) || Ks.getOrCreateInstance(this).show();
      }), N4.on(window, Ds, () => {
        for (const t6 of z4.find(Vs)) Ks.getOrCreateInstance(t6);
      }), m5(Ks);
      const Qs = ".bs.toast", Xs = `mouseover${Qs}`, Ys = `mouseout${Qs}`, Us = `focusin${Qs}`, Gs = `focusout${Qs}`, Js = `hide${Qs}`, Zs = `hidden${Qs}`, to3 = `show${Qs}`, eo2 = `shown${Qs}`, io2 = "hide", no2 = "show", so = "showing", oo = { animation: "boolean", autohide: "boolean", delay: "number" }, ro = { animation: true, autohide: true, delay: 5e3 };
      class ao extends W3 {
        constructor(t6, e5) {
          super(t6, e5), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
        }
        static get Default() {
          return ro;
        }
        static get DefaultType() {
          return oo;
        }
        static get NAME() {
          return "toast";
        }
        show() {
          N4.trigger(this._element, to3).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(io2), d3(this._element), this._element.classList.add(no2, so), this._queueCallback(() => {
            this._element.classList.remove(so), N4.trigger(this._element, eo2), this._maybeScheduleHide();
          }, this._element, this._config.animation));
        }
        hide() {
          this.isShown() && (N4.trigger(this._element, Js).defaultPrevented || (this._element.classList.add(so), this._queueCallback(() => {
            this._element.classList.add(io2), this._element.classList.remove(so, no2), N4.trigger(this._element, Zs);
          }, this._element, this._config.animation)));
        }
        dispose() {
          this._clearTimeout(), this.isShown() && this._element.classList.remove(no2), super.dispose();
        }
        isShown() {
          return this._element.classList.contains(no2);
        }
        _maybeScheduleHide() {
          this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
        }
        _onInteraction(t6, e5) {
          switch (t6.type) {
            case "mouseover":
            case "mouseout":
              this._hasMouseInteraction = e5;
              break;
            case "focusin":
            case "focusout":
              this._hasKeyboardInteraction = e5;
          }
          if (e5) return void this._clearTimeout();
          const i5 = t6.relatedTarget;
          this._element === i5 || this._element.contains(i5) || this._maybeScheduleHide();
        }
        _setListeners() {
          N4.on(this._element, Xs, (t6) => this._onInteraction(t6, true)), N4.on(this._element, Ys, (t6) => this._onInteraction(t6, false)), N4.on(this._element, Us, (t6) => this._onInteraction(t6, true)), N4.on(this._element, Gs, (t6) => this._onInteraction(t6, false));
        }
        _clearTimeout() {
          clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(t6) {
          return this.each(function() {
            const e5 = ao.getOrCreateInstance(this, t6);
            if ("string" == typeof t6) {
              if (void 0 === e5[t6]) throw new TypeError(`No method named "${t6}"`);
              e5[t6](this);
            }
          });
        }
      }
      return R2(ao), m5(ao), { Alert: Q3, Button: Y2, Carousel: xt2, Collapse: Bt2, Dropdown: qi2, Modal: On2, Offcanvas: qn2, Popover: us, ScrollSpy: Es, Tab: Ks, Toast: ao, Tooltip: cs };
    });
  }
});

// node_modules/@rails/ujs/app/assets/javascripts/rails-ujs.esm.js
var linkClickSelector = "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]";
var buttonClickSelector = {
  selector: "button[data-remote]:not([form]), button[data-confirm]:not([form])",
  exclude: "form button"
};
var inputChangeSelector = "select[data-remote], input[data-remote], textarea[data-remote]";
var formSubmitSelector = "form:not([data-turbo=true])";
var formInputClickSelector = "form:not([data-turbo=true]) input[type=submit], form:not([data-turbo=true]) input[type=image], form:not([data-turbo=true]) button[type=submit], form:not([data-turbo=true]) button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])";
var formDisableSelector = "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled";
var formEnableSelector = "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled";
var fileInputSelector = "input[name][type=file]:not([disabled])";
var linkDisableSelector = "a[data-disable-with], a[data-disable]";
var buttonDisableSelector = "button[data-remote][data-disable-with], button[data-remote][data-disable]";
var nonce = null;
var loadCSPNonce = () => {
  const metaTag = document.querySelector("meta[name=csp-nonce]");
  return nonce = metaTag && metaTag.content;
};
var cspNonce = () => nonce || loadCSPNonce();
var m = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
var matches = function(element, selector) {
  if (selector.exclude) {
    return m.call(element, selector.selector) && !m.call(element, selector.exclude);
  } else {
    return m.call(element, selector);
  }
};
var EXPANDO = "_ujsData";
var getData = (element, key) => element[EXPANDO] ? element[EXPANDO][key] : void 0;
var setData = function(element, key, value) {
  if (!element[EXPANDO]) {
    element[EXPANDO] = {};
  }
  return element[EXPANDO][key] = value;
};
var $ = (selector) => Array.prototype.slice.call(document.querySelectorAll(selector));
var isContentEditable = function(element) {
  var isEditable = false;
  do {
    if (element.isContentEditable) {
      isEditable = true;
      break;
    }
    element = element.parentElement;
  } while (element);
  return isEditable;
};
var csrfToken = () => {
  const meta = document.querySelector("meta[name=csrf-token]");
  return meta && meta.content;
};
var csrfParam = () => {
  const meta = document.querySelector("meta[name=csrf-param]");
  return meta && meta.content;
};
var CSRFProtection = (xhr) => {
  const token = csrfToken();
  if (token) {
    return xhr.setRequestHeader("X-CSRF-Token", token);
  }
};
var refreshCSRFTokens = () => {
  const token = csrfToken();
  const param = csrfParam();
  if (token && param) {
    return $('form input[name="' + param + '"]').forEach((input) => input.value = token);
  }
};
var AcceptHeaders = {
  "*": "*/*",
  text: "text/plain",
  html: "text/html",
  xml: "application/xml, text/xml",
  json: "application/json, text/javascript",
  script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
};
var ajax = (options) => {
  options = prepareOptions(options);
  var xhr = createXHR(options, function() {
    const response = processResponse(xhr.response != null ? xhr.response : xhr.responseText, xhr.getResponseHeader("Content-Type"));
    if (Math.floor(xhr.status / 100) === 2) {
      if (typeof options.success === "function") {
        options.success(response, xhr.statusText, xhr);
      }
    } else {
      if (typeof options.error === "function") {
        options.error(response, xhr.statusText, xhr);
      }
    }
    return typeof options.complete === "function" ? options.complete(xhr, xhr.statusText) : void 0;
  });
  if (options.beforeSend && !options.beforeSend(xhr, options)) {
    return false;
  }
  if (xhr.readyState === XMLHttpRequest.OPENED) {
    return xhr.send(options.data);
  }
};
var prepareOptions = function(options) {
  options.url = options.url || location.href;
  options.type = options.type.toUpperCase();
  if (options.type === "GET" && options.data) {
    if (options.url.indexOf("?") < 0) {
      options.url += "?" + options.data;
    } else {
      options.url += "&" + options.data;
    }
  }
  if (!(options.dataType in AcceptHeaders)) {
    options.dataType = "*";
  }
  options.accept = AcceptHeaders[options.dataType];
  if (options.dataType !== "*") {
    options.accept += ", */*; q=0.01";
  }
  return options;
};
var createXHR = function(options, done) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.type, options.url, true);
  xhr.setRequestHeader("Accept", options.accept);
  if (typeof options.data === "string") {
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
  }
  if (!options.crossDomain) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    CSRFProtection(xhr);
  }
  xhr.withCredentials = !!options.withCredentials;
  xhr.onreadystatechange = function() {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      return done(xhr);
    }
  };
  return xhr;
};
var processResponse = function(response, type) {
  if (typeof response === "string" && typeof type === "string") {
    if (type.match(/\bjson\b/)) {
      try {
        response = JSON.parse(response);
      } catch (error2) {
      }
    } else if (type.match(/\b(?:java|ecma)script\b/)) {
      const script = document.createElement("script");
      script.setAttribute("nonce", cspNonce());
      script.text = response;
      document.head.appendChild(script).parentNode.removeChild(script);
    } else if (type.match(/\b(xml|html|svg)\b/)) {
      const parser = new DOMParser();
      type = type.replace(/;.+/, "");
      try {
        response = parser.parseFromString(response, type);
      } catch (error1) {
      }
    }
  }
  return response;
};
var href = (element) => element.href;
var isCrossDomain = function(url) {
  const originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  const urlAnchor = document.createElement("a");
  try {
    urlAnchor.href = url;
    return !((!urlAnchor.protocol || urlAnchor.protocol === ":") && !urlAnchor.host || originAnchor.protocol + "//" + originAnchor.host === urlAnchor.protocol + "//" + urlAnchor.host);
  } catch (e4) {
    return true;
  }
};
var preventDefault;
var { CustomEvent: CustomEvent2 } = window;
if (typeof CustomEvent2 !== "function") {
  CustomEvent2 = function(event2, params) {
    const evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event2, params.bubbles, params.cancelable, params.detail);
    return evt;
  };
  CustomEvent2.prototype = window.Event.prototype;
  ({ preventDefault } = CustomEvent2.prototype);
  CustomEvent2.prototype.preventDefault = function() {
    const result = preventDefault.call(this);
    if (this.cancelable && !this.defaultPrevented) {
      Object.defineProperty(this, "defaultPrevented", {
        get() {
          return true;
        }
      });
    }
    return result;
  };
}
var fire = (obj, name, data) => {
  const event2 = new CustomEvent2(name, {
    bubbles: true,
    cancelable: true,
    detail: data
  });
  obj.dispatchEvent(event2);
  return !event2.defaultPrevented;
};
var stopEverything = (e4) => {
  fire(e4.target, "ujs:everythingStopped");
  e4.preventDefault();
  e4.stopPropagation();
  e4.stopImmediatePropagation();
};
var delegate = (element, selector, eventType, handler) => element.addEventListener(eventType, function(e4) {
  let { target } = e4;
  while (!!(target instanceof Element) && !matches(target, selector)) {
    target = target.parentNode;
  }
  if (target instanceof Element && handler.call(target, e4) === false) {
    e4.preventDefault();
    e4.stopPropagation();
  }
});
var toArray = (e4) => Array.prototype.slice.call(e4);
var serializeElement = (element, additionalParam) => {
  let inputs = [element];
  if (matches(element, "form")) {
    inputs = toArray(element.elements);
  }
  const params = [];
  inputs.forEach(function(input) {
    if (!input.name || input.disabled) {
      return;
    }
    if (matches(input, "fieldset[disabled] *")) {
      return;
    }
    if (matches(input, "select")) {
      toArray(input.options).forEach(function(option) {
        if (option.selected) {
          params.push({
            name: input.name,
            value: option.value
          });
        }
      });
    } else if (input.checked || ["radio", "checkbox", "submit"].indexOf(input.type) === -1) {
      params.push({
        name: input.name,
        value: input.value
      });
    }
  });
  if (additionalParam) {
    params.push(additionalParam);
  }
  return params.map(function(param) {
    if (param.name) {
      return `${encodeURIComponent(param.name)}=${encodeURIComponent(param.value)}`;
    } else {
      return param;
    }
  }).join("&");
};
var formElements = (form2, selector) => {
  if (matches(form2, "form")) {
    return toArray(form2.elements).filter((el) => matches(el, selector));
  } else {
    return toArray(form2.querySelectorAll(selector));
  }
};
var handleConfirmWithRails = (rails) => function(e4) {
  if (!allowAction(this, rails)) {
    stopEverything(e4);
  }
};
var confirm2 = (message, element) => window.confirm(message);
var allowAction = function(element, rails) {
  let callback2;
  const message = element.getAttribute("data-confirm");
  if (!message) {
    return true;
  }
  let answer = false;
  if (fire(element, "confirm")) {
    try {
      answer = rails.confirm(message, element);
    } catch (error2) {
    }
    callback2 = fire(element, "confirm:complete", [answer]);
  }
  return answer && callback2;
};
var handleDisabledElement = function(e4) {
  const element = this;
  if (element.disabled) {
    stopEverything(e4);
  }
};
var enableElement = (e4) => {
  let element;
  if (e4 instanceof Event) {
    if (isXhrRedirect(e4)) {
      return;
    }
    element = e4.target;
  } else {
    element = e4;
  }
  if (isContentEditable(element)) {
    return;
  }
  if (matches(element, linkDisableSelector)) {
    return enableLinkElement(element);
  } else if (matches(element, buttonDisableSelector) || matches(element, formEnableSelector)) {
    return enableFormElement(element);
  } else if (matches(element, formSubmitSelector)) {
    return enableFormElements(element);
  }
};
var disableElement = (e4) => {
  const element = e4 instanceof Event ? e4.target : e4;
  if (isContentEditable(element)) {
    return;
  }
  if (matches(element, linkDisableSelector)) {
    return disableLinkElement(element);
  } else if (matches(element, buttonDisableSelector) || matches(element, formDisableSelector)) {
    return disableFormElement(element);
  } else if (matches(element, formSubmitSelector)) {
    return disableFormElements(element);
  }
};
var disableLinkElement = function(element) {
  if (getData(element, "ujs:disabled")) {
    return;
  }
  const replacement = element.getAttribute("data-disable-with");
  if (replacement != null) {
    setData(element, "ujs:enable-with", element.innerHTML);
    element.innerHTML = replacement;
  }
  element.addEventListener("click", stopEverything);
  return setData(element, "ujs:disabled", true);
};
var enableLinkElement = function(element) {
  const originalText = getData(element, "ujs:enable-with");
  if (originalText != null) {
    element.innerHTML = originalText;
    setData(element, "ujs:enable-with", null);
  }
  element.removeEventListener("click", stopEverything);
  return setData(element, "ujs:disabled", null);
};
var disableFormElements = (form2) => formElements(form2, formDisableSelector).forEach(disableFormElement);
var disableFormElement = function(element) {
  if (getData(element, "ujs:disabled")) {
    return;
  }
  const replacement = element.getAttribute("data-disable-with");
  if (replacement != null) {
    if (matches(element, "button")) {
      setData(element, "ujs:enable-with", element.innerHTML);
      element.innerHTML = replacement;
    } else {
      setData(element, "ujs:enable-with", element.value);
      element.value = replacement;
    }
  }
  element.disabled = true;
  return setData(element, "ujs:disabled", true);
};
var enableFormElements = (form2) => formElements(form2, formEnableSelector).forEach((element) => enableFormElement(element));
var enableFormElement = function(element) {
  const originalText = getData(element, "ujs:enable-with");
  if (originalText != null) {
    if (matches(element, "button")) {
      element.innerHTML = originalText;
    } else {
      element.value = originalText;
    }
    setData(element, "ujs:enable-with", null);
  }
  element.disabled = false;
  return setData(element, "ujs:disabled", null);
};
var isXhrRedirect = function(event2) {
  const xhr = event2.detail ? event2.detail[0] : void 0;
  return xhr && xhr.getResponseHeader("X-Xhr-Redirect");
};
var handleMethodWithRails = (rails) => function(e4) {
  const link = this;
  const method = link.getAttribute("data-method");
  if (!method) {
    return;
  }
  if (isContentEditable(this)) {
    return;
  }
  const href2 = rails.href(link);
  const csrfToken$1 = csrfToken();
  const csrfParam$1 = csrfParam();
  const form2 = document.createElement("form");
  let formContent = `<input name='_method' value='${method}' type='hidden' />`;
  if (csrfParam$1 && csrfToken$1 && !isCrossDomain(href2)) {
    formContent += `<input name='${csrfParam$1}' value='${csrfToken$1}' type='hidden' />`;
  }
  formContent += '<input type="submit" />';
  form2.method = "post";
  form2.action = href2;
  form2.target = link.target;
  form2.innerHTML = formContent;
  form2.style.display = "none";
  document.body.appendChild(form2);
  form2.querySelector('[type="submit"]').click();
  stopEverything(e4);
};
var isRemote = function(element) {
  const value = element.getAttribute("data-remote");
  return value != null && value !== "false";
};
var handleRemoteWithRails = (rails) => function(e4) {
  let data, method, url;
  const element = this;
  if (!isRemote(element)) {
    return true;
  }
  if (!fire(element, "ajax:before")) {
    fire(element, "ajax:stopped");
    return false;
  }
  if (isContentEditable(element)) {
    fire(element, "ajax:stopped");
    return false;
  }
  const withCredentials = element.getAttribute("data-with-credentials");
  const dataType = element.getAttribute("data-type") || "script";
  if (matches(element, formSubmitSelector)) {
    const button = getData(element, "ujs:submit-button");
    method = getData(element, "ujs:submit-button-formmethod") || element.getAttribute("method") || "get";
    url = getData(element, "ujs:submit-button-formaction") || element.getAttribute("action") || location.href;
    if (method.toUpperCase() === "GET") {
      url = url.replace(/\?.*$/, "");
    }
    if (element.enctype === "multipart/form-data") {
      data = new FormData(element);
      if (button != null) {
        data.append(button.name, button.value);
      }
    } else {
      data = serializeElement(element, button);
    }
    setData(element, "ujs:submit-button", null);
    setData(element, "ujs:submit-button-formmethod", null);
    setData(element, "ujs:submit-button-formaction", null);
  } else if (matches(element, buttonClickSelector) || matches(element, inputChangeSelector)) {
    method = element.getAttribute("data-method");
    url = element.getAttribute("data-url");
    data = serializeElement(element, element.getAttribute("data-params"));
  } else {
    method = element.getAttribute("data-method");
    url = rails.href(element);
    data = element.getAttribute("data-params");
  }
  ajax({
    type: method || "GET",
    url,
    data,
    dataType,
    beforeSend(xhr, options) {
      if (fire(element, "ajax:beforeSend", [xhr, options])) {
        return fire(element, "ajax:send", [xhr]);
      } else {
        fire(element, "ajax:stopped");
        return false;
      }
    },
    success(...args) {
      return fire(element, "ajax:success", args);
    },
    error(...args) {
      return fire(element, "ajax:error", args);
    },
    complete(...args) {
      return fire(element, "ajax:complete", args);
    },
    crossDomain: isCrossDomain(url),
    withCredentials: withCredentials != null && withCredentials !== "false"
  });
  stopEverything(e4);
};
var formSubmitButtonClick = function(e4) {
  const button = this;
  const { form: form2 } = button;
  if (!form2) {
    return;
  }
  if (button.name) {
    setData(form2, "ujs:submit-button", {
      name: button.name,
      value: button.value
    });
  }
  setData(form2, "ujs:formnovalidate-button", button.formNoValidate);
  setData(form2, "ujs:submit-button-formaction", button.getAttribute("formaction"));
  return setData(form2, "ujs:submit-button-formmethod", button.getAttribute("formmethod"));
};
var preventInsignificantClick = function(e4) {
  const link = this;
  const method = (link.getAttribute("data-method") || "GET").toUpperCase();
  const data = link.getAttribute("data-params");
  const metaClick = e4.metaKey || e4.ctrlKey;
  const insignificantMetaClick = metaClick && method === "GET" && !data;
  const nonPrimaryMouseClick = e4.button != null && e4.button !== 0;
  if (nonPrimaryMouseClick || insignificantMetaClick) {
    e4.stopImmediatePropagation();
  }
};
var Rails = {
  $,
  ajax,
  buttonClickSelector,
  buttonDisableSelector,
  confirm: confirm2,
  cspNonce,
  csrfToken,
  csrfParam,
  CSRFProtection,
  delegate,
  disableElement,
  enableElement,
  fileInputSelector,
  fire,
  formElements,
  formEnableSelector,
  formDisableSelector,
  formInputClickSelector,
  formSubmitButtonClick,
  formSubmitSelector,
  getData,
  handleDisabledElement,
  href,
  inputChangeSelector,
  isCrossDomain,
  linkClickSelector,
  linkDisableSelector,
  loadCSPNonce,
  matches,
  preventInsignificantClick,
  refreshCSRFTokens,
  serializeElement,
  setData,
  stopEverything
};
var handleConfirm = handleConfirmWithRails(Rails);
Rails.handleConfirm = handleConfirm;
var handleMethod = handleMethodWithRails(Rails);
Rails.handleMethod = handleMethod;
var handleRemote = handleRemoteWithRails(Rails);
Rails.handleRemote = handleRemote;
var start = function() {
  if (window._rails_loaded) {
    throw new Error("rails-ujs has already been loaded!");
  }
  window.addEventListener("pageshow", function() {
    $(formEnableSelector).forEach(function(el) {
      if (getData(el, "ujs:disabled")) {
        enableElement(el);
      }
    });
    $(linkDisableSelector).forEach(function(el) {
      if (getData(el, "ujs:disabled")) {
        enableElement(el);
      }
    });
  });
  delegate(document, linkDisableSelector, "ajax:complete", enableElement);
  delegate(document, linkDisableSelector, "ajax:stopped", enableElement);
  delegate(document, buttonDisableSelector, "ajax:complete", enableElement);
  delegate(document, buttonDisableSelector, "ajax:stopped", enableElement);
  delegate(document, linkClickSelector, "click", preventInsignificantClick);
  delegate(document, linkClickSelector, "click", handleDisabledElement);
  delegate(document, linkClickSelector, "click", handleConfirm);
  delegate(document, linkClickSelector, "click", disableElement);
  delegate(document, linkClickSelector, "click", handleRemote);
  delegate(document, linkClickSelector, "click", handleMethod);
  delegate(document, buttonClickSelector, "click", preventInsignificantClick);
  delegate(document, buttonClickSelector, "click", handleDisabledElement);
  delegate(document, buttonClickSelector, "click", handleConfirm);
  delegate(document, buttonClickSelector, "click", disableElement);
  delegate(document, buttonClickSelector, "click", handleRemote);
  delegate(document, inputChangeSelector, "change", handleDisabledElement);
  delegate(document, inputChangeSelector, "change", handleConfirm);
  delegate(document, inputChangeSelector, "change", handleRemote);
  delegate(document, formSubmitSelector, "submit", handleDisabledElement);
  delegate(document, formSubmitSelector, "submit", handleConfirm);
  delegate(document, formSubmitSelector, "submit", handleRemote);
  delegate(document, formSubmitSelector, "submit", (e4) => setTimeout(() => disableElement(e4), 13));
  delegate(document, formSubmitSelector, "ajax:send", disableElement);
  delegate(document, formSubmitSelector, "ajax:complete", enableElement);
  delegate(document, formInputClickSelector, "click", preventInsignificantClick);
  delegate(document, formInputClickSelector, "click", handleDisabledElement);
  delegate(document, formInputClickSelector, "click", handleConfirm);
  delegate(document, formInputClickSelector, "click", formSubmitButtonClick);
  document.addEventListener("DOMContentLoaded", refreshCSRFTokens);
  document.addEventListener("DOMContentLoaded", loadCSPNonce);
  return window._rails_loaded = true;
};
Rails.start = start;
if (typeof jQuery !== "undefined" && jQuery && jQuery.ajax) {
  if (jQuery.rails) {
    throw new Error("If you load both jquery_ujs and rails-ujs, use rails-ujs only.");
  }
  jQuery.rails = Rails;
  jQuery.ajaxPrefilter(function(options, originalOptions, xhr) {
    if (!options.crossDomain) {
      return CSRFProtection(xhr);
    }
  });
}

// node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
var turbo_es2017_esm_exports = {};
__export(turbo_es2017_esm_exports, {
  FetchEnctype: () => FetchEnctype,
  FetchMethod: () => FetchMethod,
  FetchRequest: () => FetchRequest,
  FetchResponse: () => FetchResponse,
  FrameElement: () => FrameElement,
  FrameLoadingStyle: () => FrameLoadingStyle,
  FrameRenderer: () => FrameRenderer,
  PageRenderer: () => PageRenderer,
  PageSnapshot: () => PageSnapshot,
  StreamActions: () => StreamActions,
  StreamElement: () => StreamElement,
  StreamSourceElement: () => StreamSourceElement,
  cache: () => cache,
  clearCache: () => clearCache,
  config: () => config,
  connectStreamSource: () => connectStreamSource,
  disconnectStreamSource: () => disconnectStreamSource,
  fetch: () => fetchWithTurboHeaders,
  fetchEnctypeFromString: () => fetchEnctypeFromString,
  fetchMethodFromString: () => fetchMethodFromString,
  isSafe: () => isSafe,
  navigator: () => navigator$1,
  registerAdapter: () => registerAdapter,
  renderStreamMessage: () => renderStreamMessage,
  session: () => session,
  setConfirmMethod: () => setConfirmMethod,
  setFormMode: () => setFormMode,
  setProgressBarDelay: () => setProgressBarDelay,
  start: () => start2,
  visit: () => visit
});
(function(prototype) {
  if (typeof prototype.requestSubmit == "function") return;
  prototype.requestSubmit = function(submitter2) {
    if (submitter2) {
      validateSubmitter(submitter2, this);
      submitter2.click();
    } else {
      submitter2 = document.createElement("input");
      submitter2.type = "submit";
      submitter2.hidden = true;
      this.appendChild(submitter2);
      submitter2.click();
      this.removeChild(submitter2);
    }
  };
  function validateSubmitter(submitter2, form2) {
    submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter2.form == form2 || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
var submittersByForm = /* @__PURE__ */ new WeakMap();
function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null;
}
function clickCaptured(event2) {
  const submitter2 = findSubmitterFromClickTarget(event2.target);
  if (submitter2 && submitter2.form) {
    submittersByForm.set(submitter2.form, submitter2);
  }
}
(function() {
  if ("submitter" in Event.prototype) return;
  let prototype = window.Event.prototype;
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return;
    }
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
var FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};
var FrameElement = class _FrameElement extends HTMLElement {
  static delegateConstructor = void 0;
  loaded = Promise.resolve();
  static get observedAttributes() {
    return ["disabled", "loading", "src"];
  }
  constructor() {
    super();
    this.delegate = new _FrameElement.delegateConstructor(this);
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }
  /**
   * Gets the URL to lazily load source HTML from
   */
  get src() {
    return this.getAttribute("src");
  }
  /**
   * Sets the URL to lazily load source HTML from
   */
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  /**
   * Gets the refresh mode for the frame.
   */
  get refresh() {
    return this.getAttribute("refresh");
  }
  /**
   * Sets the refresh mode for the frame.
   */
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }
  get shouldReloadWithMorph() {
    return this.src && this.refresh === "morph";
  }
  /**
   * Determines if the element is loading
   */
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }
  /**
   * Sets the value of if the element is loading
   */
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }
  /**
   * Gets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  get disabled() {
    return this.hasAttribute("disabled");
  }
  /**
   * Sets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }
  /**
   * Gets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }
  /**
   * Sets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }
  /**
   * Determines if the element has finished loading
   */
  get complete() {
    return !this.delegate.isLoading;
  }
  /**
   * Gets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }
  /**
   * Sets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
  }
};
function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
}
var drive = {
  enabled: true,
  progressBarDelay: 500,
  unvisitableExtensions: /* @__PURE__ */ new Set(
    [
      ".7z",
      ".aac",
      ".apk",
      ".avi",
      ".bmp",
      ".bz2",
      ".css",
      ".csv",
      ".deb",
      ".dmg",
      ".doc",
      ".docx",
      ".exe",
      ".gif",
      ".gz",
      ".heic",
      ".heif",
      ".ico",
      ".iso",
      ".jpeg",
      ".jpg",
      ".js",
      ".json",
      ".m4a",
      ".mkv",
      ".mov",
      ".mp3",
      ".mp4",
      ".mpeg",
      ".mpg",
      ".msi",
      ".ogg",
      ".ogv",
      ".pdf",
      ".pkg",
      ".png",
      ".ppt",
      ".pptx",
      ".rar",
      ".rtf",
      ".svg",
      ".tar",
      ".tif",
      ".tiff",
      ".txt",
      ".wav",
      ".webm",
      ".webp",
      ".wma",
      ".wmv",
      ".xls",
      ".xlsx",
      ".xml",
      ".zip"
    ]
  )
};
function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce2 = getCspNonce();
    if (cspNonce2) {
      createdScriptElement.nonce = cspNonce2;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
}
function copyElementAttributes(destinationElement, sourceElement) {
  for (const { name, value } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}
function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function dispatch(eventName, { target, cancelable, detail } = {}) {
  const event2 = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event2);
  } else {
    document.documentElement.dispatchEvent(event2);
  }
  return event2;
}
function cancelEvent(event2) {
  event2.preventDefault();
  event2.stopImmediatePropagation();
}
function nextRepaint() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick();
  } else {
    return nextAnimationFrame();
  }
}
function nextAnimationFrame() {
  return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
}
function nextEventLoopTick() {
  return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
}
function nextMicrotask() {
  return Promise.resolve();
}
function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
}
function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map((line) => line.slice(indent)).join("\n");
}
function interpolate(strings, values) {
  return strings.reduce((result, string, i4) => {
    const value = values[i4] == void 0 ? "" : values[i4];
    return result + string + value;
  }, "");
}
function uuid() {
  return Array.from({ length: 36 }).map((_4, i4) => {
    if (i4 == 8 || i4 == 13 || i4 == 18 || i4 == 23) {
      return "-";
    } else if (i4 == 14) {
      return "4";
    } else if (i4 == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
}
function getAttribute(attributeName, ...elements2) {
  for (const value of elements2.map((element) => element?.getAttribute(attributeName))) {
    if (typeof value == "string") return value;
  }
  return null;
}
function hasAttribute(attributeName, ...elements2) {
  return elements2.some((element) => element && element.hasAttribute(attributeName));
}
function markAsBusy(...elements2) {
  for (const element of elements2) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}
function clearBusyState(...elements2) {
  for (const element of elements2) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
}
function waitForLoad(element, timeoutInMilliseconds = 2e3) {
  return new Promise((resolve2) => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve2();
    };
    element.addEventListener("load", onComplete, { once: true });
    element.addEventListener("error", onComplete, { once: true });
    setTimeout(resolve2, timeoutInMilliseconds);
  });
}
function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
}
function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore";
}
function getVisitAction(...elements2) {
  const action = getAttribute("data-turbo-action", ...elements2);
  return isAction(action) ? action : null;
}
function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`);
}
function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content;
}
function getCspNonce() {
  const element = getMetaElement("csp-nonce");
  if (element) {
    const { nonce: nonce2, content } = element;
    return nonce2 == "" ? content : nonce2;
  }
}
function setMetaContent(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
}
function findClosestRecursively(element, selector) {
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
  }
}
function elementIsFocusable(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
}
function queryAutofocusableElement(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
}
async function around(callback2, reader) {
  const before = reader();
  callback2();
  await nextAnimationFrame();
  const after = reader();
  return [before, after];
}
function doesNotTargetIFrame(name) {
  if (name === "_blank") {
    return false;
  } else if (name) {
    for (const element of document.getElementsByName(name)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
    return true;
  } else {
    return true;
  }
}
function findLinkFromClickTarget(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
}
function getLocationForLink(link) {
  return expandURL(link.getAttribute("href") || "");
}
function debounce(fn2, delay) {
  let timeoutId = null;
  return (...args) => {
    const callback2 = () => fn2.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback2, delay);
  };
}
var submitter = {
  "aria-disabled": {
    beforeSubmit: (submitter2) => {
      submitter2.setAttribute("aria-disabled", "true");
      submitter2.addEventListener("click", cancelEvent);
    },
    afterSubmit: (submitter2) => {
      submitter2.removeAttribute("aria-disabled");
      submitter2.removeEventListener("click", cancelEvent);
    }
  },
  "disabled": {
    beforeSubmit: (submitter2) => submitter2.disabled = true,
    afterSubmit: (submitter2) => submitter2.disabled = false
  }
};
var Config = class {
  #submitter = null;
  constructor(config3) {
    Object.assign(this, config3);
  }
  get submitter() {
    return this.#submitter;
  }
  set submitter(value) {
    this.#submitter = submitter[value] || value;
  }
};
var forms = new Config({
  mode: "on",
  submitter: "disabled"
});
var config = {
  drive,
  forms
};
function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI);
}
function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
}
function getAction$1(form2, submitter2) {
  const action = submitter2?.getAttribute("formaction") || form2.getAttribute("action") || form2.action;
  return expandURL(action);
}
function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
}
function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
}
function locationIsVisitable(location2, rootLocation) {
  return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
}
function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
}
function toCacheKey(url) {
  return getRequestURL(url);
}
function urlsAreEqual(left, right) {
  return expandURL(left).href == expandURL(right).href;
}
function getPathComponents(url) {
  return url.pathname.split("/").slice(1);
}
function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0];
}
function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname);
}
function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/";
}
var FetchResponse = class {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(void 0);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
};
var LimitedSet = class extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }
  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
};
var recentRequests = new LimitedSet(20);
var nativeFetch = window.fetch;
function fetchWithTurboHeaders(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  });
}
function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
}
var FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};
function fetchEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart;
    case FetchEnctype.plain:
      return FetchEnctype.plain;
    default:
      return FetchEnctype.urlEncoded;
  }
}
var FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};
var FetchRequest = class {
  abortController = new AbortController();
  #resolveRequestPromise = (_value) => {
  };
  constructor(delegate2, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body2] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
    this.delegate = delegate2;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders },
      body: body2,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }
  get method() {
    return this.fetchOptions.method;
  }
  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
    this.url.search = "";
    const [url, body2] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
    this.url = url;
    this.fetchOptions.body = body2;
    this.fetchOptions.method = fetchMethod.toUpperCase();
  }
  get headers() {
    return this.fetchOptions.headers;
  }
  set headers(value) {
    this.fetchOptions.headers = value;
  }
  get body() {
    if (this.isSafe) {
      return this.url.searchParams;
    } else {
      return this.fetchOptions.body;
    }
  }
  set body(value) {
    this.fetchOptions.body = value;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const { fetchOptions } = this;
    this.delegate.prepareRequest(this);
    const event2 = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      if (event2.detail.fetchRequest) {
        this.response = event2.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }
      const response = await this.response;
      return await this.receive(response);
    } catch (error2) {
      if (error2.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error2)) {
          this.delegate.requestErrored(this, error2);
        }
        throw error2;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event2 = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: { fetchResponse },
      target: this.target
    });
    if (event2.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isSafe() {
    return isSafe(this.method);
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async #allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise((resolve2) => this.#resolveRequestPromise = resolve2);
    const event2 = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event2.detail.url;
    if (event2.defaultPrevented) await requestInterception;
    return event2;
  }
  #willDelegateErrorHandling(error2) {
    const event2 = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error: error2 }
    });
    return !event2.defaultPrevented;
  }
};
function isSafe(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get;
}
function buildResourceAndBody(resource, method, requestBody, enctype) {
  const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null];
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams];
  } else {
    return [resource, requestBody];
  }
}
function entriesExcludingFiles(requestBody) {
  const entries = [];
  for (const [name, value] of requestBody) {
    if (value instanceof File) continue;
    else entries.push([name, value]);
  }
  return entries;
}
function mergeIntoURLSearchParams(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
  url.search = searchParams.toString();
  return url;
}
var AppearanceObserver = class {
  started = false;
  constructor(delegate2, element) {
    this.delegate = delegate2;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
  intersect = (entries) => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
};
var StreamMessage = class {
  static contentType = "text/vnd.turbo-stream.html";
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
};
function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
}
var PREFETCH_DELAY = 100;
var PrefetchCache = class {
  #prefetchTimeout = null;
  #prefetched = null;
  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request;
    }
  }
  setLater(url, request, ttl) {
    this.clear();
    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }
  set(url, request, ttl) {
    this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
  }
  clear() {
    if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
};
var cacheTtl = 10 * 1e3;
var prefetchCache = new PrefetchCache();
var FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};
var FormSubmission = class _FormSubmission {
  state = FormSubmissionState.initialized;
  static confirmMethod(message) {
    return Promise.resolve(confirm(message));
  }
  constructor(delegate2, formElement, submitter2, mustRedirect = false) {
    const method = getMethod(formElement, submitter2);
    const action = getAction(getFormAction(formElement, submitter2), method);
    const body2 = buildFormData(formElement, submitter2);
    const enctype = getEnctype(formElement, submitter2);
    this.delegate = delegate2;
    this.formElement = formElement;
    this.submitter = submitter2;
    this.fetchRequest = new FetchRequest(this, method, action, body2, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }
  get method() {
    return this.fetchRequest.method;
  }
  set method(value) {
    this.fetchRequest.method = value;
  }
  get action() {
    return this.fetchRequest.url.toString();
  }
  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }
  get body() {
    return this.fetchRequest.body;
  }
  get enctype() {
    return this.fetchRequest.enctype;
  }
  get isSafe() {
    return this.fetchRequest.isSafe;
  }
  get location() {
    return this.fetchRequest.url;
  }
  // The submission process
  async start() {
    const { initialized, requesting } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const { stopping, stopped } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }
  // Fetch request delegate
  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: { formSubmission: this }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();
    this.result = { success: response.succeeded, fetchResponse: response };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return;
    }
    prefetchCache.clear();
    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error2 = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error2);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = { success: true, fetchResponse: response };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = { success: false, fetchResponse: response };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error2) {
    this.result = { success: false, error: error2 };
    this.delegate.formSubmissionErrored(this, error2);
  }
  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: { formSubmission: this, ...this.result }
    });
    this.delegate.formSubmissionFinished(this);
  }
  // Private
  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith) return;
    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }
  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText) return;
    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }
  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with");
  }
};
function buildFormData(formElement, submitter2) {
  const formData = new FormData(formElement);
  const name = submitter2?.getAttribute("name");
  const value = submitter2?.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
}
function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : void 0;
    }
  }
}
function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected;
}
function getFormAction(formElement, submitter2) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
  if (submitter2?.hasAttribute("formaction")) {
    return submitter2.getAttribute("formaction") || "";
  } else {
    return formElement.getAttribute("action") || formElementAction || "";
  }
}
function getAction(formAction, fetchMethod) {
  const action = expandURL(formAction);
  if (isSafe(fetchMethod)) {
    action.search = "";
  }
  return action;
}
function getMethod(formElement, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
}
function getEnctype(formElement, submitter2) {
  return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
}
var Snapshot = class {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element);
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id2) {
    return getPermanentElementById(this.element, id2);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const { id: id2 } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id2);
      if (newPermanentElement) {
        permanentElementMap[id2] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
};
function getPermanentElementById(node, id2) {
  return node.querySelector(`#${id2}[data-turbo-permanent]`);
}
function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
}
var FormSubmitObserver = class {
  started = false;
  constructor(delegate2, eventTarget) {
    this.delegate = delegate2;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  };
  submitBubbled = (event2) => {
    if (!event2.defaultPrevented) {
      const form2 = event2.target instanceof HTMLFormElement ? event2.target : void 0;
      const submitter2 = event2.submitter || void 0;
      if (form2 && submissionDoesNotDismissDialog(form2, submitter2) && submissionDoesNotTargetIFrame(form2, submitter2) && this.delegate.willSubmitForm(form2, submitter2)) {
        event2.preventDefault();
        event2.stopImmediatePropagation();
        this.delegate.formSubmitted(form2, submitter2);
      }
    }
  };
};
function submissionDoesNotDismissDialog(form2, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || form2.getAttribute("method");
  return method != "dialog";
}
function submissionDoesNotTargetIFrame(form2, submitter2) {
  const target = submitter2?.getAttribute("formtarget") || form2.getAttribute("target");
  return doesNotTargetIFrame(target);
}
var View = class {
  #resolveRenderPromise = (_value) => {
  };
  #resolveInterceptionPromise = (_value) => {
  };
  constructor(delegate2, element) {
    this.delegate = delegate2;
    this.element = element;
  }
  // Scrolling
  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({ x: 0, y: 0 });
    }
  }
  scrollToAnchorFromLocation(location2) {
    this.scrollToAnchor(getAnchor(location2));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({ x: x5, y: y4 }) {
    this.scrollRoot.scrollTo(x5, y4);
  }
  scrollToTop() {
    this.scrollToPosition({ x: 0, y: 0 });
  }
  get scrollRoot() {
    return window;
  }
  // Rendering
  async render(renderer) {
    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
    const shouldInvalidate = willRender;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise((resolve2) => this.#resolveRenderPromise = resolve2);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise((resolve2) => this.#resolveInterceptionPromise = resolve2);
        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender) await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(void 0);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }
  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
};
var FrameView = class extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
};
var LinkInterceptor = class {
  constructor(delegate2, element) {
    this.delegate = delegate2;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  clickBubbled = (event2) => {
    if (this.clickEventIsSignificant(event2)) {
      this.clickEvent = event2;
    } else {
      delete this.clickEvent;
    }
  };
  linkClicked = (event2) => {
    if (this.clickEvent && this.clickEventIsSignificant(event2)) {
      if (this.delegate.shouldInterceptLinkClick(event2.target, event2.detail.url, event2.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event2.preventDefault();
        this.delegate.linkClickIntercepted(event2.target, event2.detail.url, event2.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  };
  willVisit = (_event) => {
    delete this.clickEvent;
  };
  clickEventIsSignificant(event2) {
    const target = event2.composed ? event2.target?.parentElement : event2.target;
    const element = findLinkFromClickTarget(target) || target;
    return element instanceof Element && element.closest("turbo-frame, html") == this.element;
  }
};
var LinkClickObserver = class {
  started = false;
  constructor(delegate2, eventTarget) {
    this.delegate = delegate2;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  };
  clickBubbled = (event2) => {
    if (event2 instanceof MouseEvent && this.clickEventIsSignificant(event2)) {
      const target = event2.composedPath && event2.composedPath()[0] || event2.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link.target)) {
        const location2 = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location2, event2)) {
          event2.preventDefault();
          this.delegate.followedLinkToLocation(link, location2);
        }
      }
    }
  };
  clickEventIsSignificant(event2) {
    return !(event2.target && event2.target.isContentEditable || event2.defaultPrevented || event2.which > 1 || event2.altKey || event2.ctrlKey || event2.metaKey || event2.shiftKey);
  }
};
var FormLinkClickObserver = class {
  constructor(delegate2, element) {
    this.delegate = delegate2;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }
  // Link hover observer delegate
  canPrefetchRequestToLocation(link, location2) {
    return false;
  }
  prefetchAndCacheRequestToLocation(link, location2) {
    return;
  }
  // Link click observer delegate
  willFollowLinkToLocation(link, location2, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
  }
  followedLinkToLocation(link, location2) {
    const form2 = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location2.searchParams) {
      form2.append(Object.assign(document.createElement("input"), { type, name, value }));
    }
    const action = Object.assign(location2, { search: "" });
    form2.setAttribute("data-turbo", "true");
    form2.setAttribute("action", action.href);
    form2.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method) form2.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame) form2.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction) form2.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm) form2.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream) form2.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location2, form2);
    document.body.appendChild(form2);
    form2.addEventListener("turbo:submit-end", () => form2.remove(), { once: true });
    requestAnimationFrame(() => form2.requestSubmit());
  }
};
var Bardo = class {
  static async preservingPermanentElements(delegate2, permanentElementMap, callback2) {
    const bardo = new this(delegate2, permanentElementMap);
    bardo.enter();
    await callback2();
    bardo.leave();
  }
  constructor(delegate2, permanentElementMap) {
    this.delegate = delegate2;
    this.permanentElementMap = permanentElementMap;
  }
  enter() {
    for (const id2 in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id2];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id2 in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id2];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone3 = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone3);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }
  getPlaceholderById(id2) {
    return this.placeholders.find((element) => element.content == id2);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
};
function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
}
var Renderer = class {
  #activeElement = null;
  static renderElement(currentElement, newElement) {
  }
  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = this.constructor.renderElement;
    this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
  }
  get shouldRender() {
    return true;
  }
  get shouldAutofocus() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  render() {
  }
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback2) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback2);
  }
  focusFirstAutofocusableElement() {
    if (this.shouldAutofocus) {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
  }
  // Bardo delegate
  enteringBardo(currentPermanentElement) {
    if (this.#activeElement) return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();
      this.#activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
  get renderMethod() {
    return "replace";
  }
};
var FrameRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  constructor(delegate2, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate2;
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({ block, behavior });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
};
function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
}
function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
}
var Idiomorph = /* @__PURE__ */ function() {
  let EMPTY_SET = /* @__PURE__ */ new Set();
  let defaults2 = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp
    },
    head: {
      style: "merge",
      shouldPreserve: function(elt) {
        return elt.getAttribute("im-preserve") === "true";
      },
      shouldReAppend: function(elt) {
        return elt.getAttribute("im-re-append") === "true";
      },
      shouldRemove: noOp,
      afterHeadMorphed: noOp
    }
  };
  function morph(oldNode, newContent, config3 = {}) {
    if (oldNode instanceof Document) {
      oldNode = oldNode.documentElement;
    }
    if (typeof newContent === "string") {
      newContent = parseContent(newContent);
    }
    let normalizedContent = normalizeContent(newContent);
    let ctx = createMorphContext(oldNode, normalizedContent, config3);
    return morphNormalizedContent(oldNode, normalizedContent, ctx);
  }
  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
    if (ctx.head.block) {
      let oldHead = oldNode.querySelector("head");
      let newHead = normalizedNewContent.querySelector("head");
      if (oldHead && newHead) {
        let promises = handleHeadElement(newHead, oldHead, ctx);
        Promise.all(promises).then(function() {
          morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
            head: {
              block: false,
              ignore: true
            }
          }));
        });
        return;
      }
    }
    if (ctx.morphStyle === "innerHTML") {
      morphChildren2(normalizedNewContent, oldNode, ctx);
      return oldNode.children;
    } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
      let previousSibling = bestMatch?.previousSibling;
      let nextSibling = bestMatch?.nextSibling;
      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
      if (bestMatch) {
        return insertSiblings(previousSibling, morphedNode, nextSibling);
      } else {
        return [];
      }
    } else {
      throw "Do not understand how to morph style " + ctx.morphStyle;
    }
  }
  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
    return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
  }
  function morphOldNodeTo(oldNode, newContent, ctx) {
    if (ctx.ignoreActive && oldNode === document.activeElement) ;
    else if (newContent == null) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      oldNode.remove();
      ctx.callbacks.afterNodeRemoved(oldNode);
      return null;
    } else if (!isSoftMatch(oldNode, newContent)) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
      oldNode.parentElement.replaceChild(newContent, oldNode);
      ctx.callbacks.afterNodeAdded(newContent);
      ctx.callbacks.afterNodeRemoved(oldNode);
      return newContent;
    } else {
      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
      else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
        handleHeadElement(newContent, oldNode, ctx);
      } else {
        syncNodeFrom(newContent, oldNode, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          morphChildren2(newContent, oldNode, ctx);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }
  }
  function morphChildren2(newParent, oldParent, ctx) {
    let nextNewChild = newParent.firstChild;
    let insertionPoint = oldParent.firstChild;
    let newChild;
    while (nextNewChild) {
      newChild = nextNewChild;
      nextNewChild = newChild.nextSibling;
      if (insertionPoint == null) {
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.appendChild(newChild);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      if (isIdSetMatch(newChild, insertionPoint, ctx)) {
        morphOldNodeTo(insertionPoint, newChild, ctx);
        insertionPoint = insertionPoint.nextSibling;
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
      if (idSetMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
        morphOldNodeTo(idSetMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
      if (softMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
        morphOldNodeTo(softMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
      oldParent.insertBefore(newChild, insertionPoint);
      ctx.callbacks.afterNodeAdded(newChild);
      removeIdsFromConsideration(ctx, newChild);
    }
    while (insertionPoint !== null) {
      let tempNode = insertionPoint;
      insertionPoint = insertionPoint.nextSibling;
      removeNode(tempNode, ctx);
    }
  }
  function ignoreAttribute(attr, to3, updateType, ctx) {
    if (attr === "value" && ctx.ignoreActiveValue && to3 === document.activeElement) {
      return true;
    }
    return ctx.callbacks.beforeAttributeUpdated(attr, to3, updateType) === false;
  }
  function syncNodeFrom(from2, to3, ctx) {
    let type = from2.nodeType;
    if (type === 1) {
      const fromAttributes = from2.attributes;
      const toAttributes = to3.attributes;
      for (const fromAttribute of fromAttributes) {
        if (ignoreAttribute(fromAttribute.name, to3, "update", ctx)) {
          continue;
        }
        if (to3.getAttribute(fromAttribute.name) !== fromAttribute.value) {
          to3.setAttribute(fromAttribute.name, fromAttribute.value);
        }
      }
      for (let i4 = toAttributes.length - 1; 0 <= i4; i4--) {
        const toAttribute = toAttributes[i4];
        if (ignoreAttribute(toAttribute.name, to3, "remove", ctx)) {
          continue;
        }
        if (!from2.hasAttribute(toAttribute.name)) {
          to3.removeAttribute(toAttribute.name);
        }
      }
    }
    if (type === 8 || type === 3) {
      if (to3.nodeValue !== from2.nodeValue) {
        to3.nodeValue = from2.nodeValue;
      }
    }
    if (!ignoreValueOfActiveElement(to3, ctx)) {
      syncInputValue(from2, to3, ctx);
    }
  }
  function syncBooleanAttribute(from2, to3, attributeName, ctx) {
    if (from2[attributeName] !== to3[attributeName]) {
      let ignoreUpdate = ignoreAttribute(attributeName, to3, "update", ctx);
      if (!ignoreUpdate) {
        to3[attributeName] = from2[attributeName];
      }
      if (from2[attributeName]) {
        if (!ignoreUpdate) {
          to3.setAttribute(attributeName, from2[attributeName]);
        }
      } else {
        if (!ignoreAttribute(attributeName, to3, "remove", ctx)) {
          to3.removeAttribute(attributeName);
        }
      }
    }
  }
  function syncInputValue(from2, to3, ctx) {
    if (from2 instanceof HTMLInputElement && to3 instanceof HTMLInputElement && from2.type !== "file") {
      let fromValue = from2.value;
      let toValue = to3.value;
      syncBooleanAttribute(from2, to3, "checked", ctx);
      syncBooleanAttribute(from2, to3, "disabled", ctx);
      if (!from2.hasAttribute("value")) {
        if (!ignoreAttribute("value", to3, "remove", ctx)) {
          to3.value = "";
          to3.removeAttribute("value");
        }
      } else if (fromValue !== toValue) {
        if (!ignoreAttribute("value", to3, "update", ctx)) {
          to3.setAttribute("value", fromValue);
          to3.value = fromValue;
        }
      }
    } else if (from2 instanceof HTMLOptionElement) {
      syncBooleanAttribute(from2, to3, "selected", ctx);
    } else if (from2 instanceof HTMLTextAreaElement && to3 instanceof HTMLTextAreaElement) {
      let fromValue = from2.value;
      let toValue = to3.value;
      if (ignoreAttribute("value", to3, "update", ctx)) {
        return;
      }
      if (fromValue !== toValue) {
        to3.value = fromValue;
      }
      if (to3.firstChild && to3.firstChild.nodeValue !== fromValue) {
        to3.firstChild.nodeValue = fromValue;
      }
    }
  }
  function handleHeadElement(newHeadTag, currentHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];
    let headMergeStyle = ctx.head.style;
    let srcToNewHeadNodes = /* @__PURE__ */ new Map();
    for (const newHeadChild of newHeadTag.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }
    for (const currentHeadElt of currentHead.children) {
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          removed.push(currentHeadElt);
        } else {
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (headMergeStyle === "append") {
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }
    nodesToAppend.push(...srcToNewHeadNodes.values());
    let promises = [];
    for (const newNode of nodesToAppend) {
      let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if (newElt.href || newElt.src) {
          let resolve2 = null;
          let promise = new Promise(function(_resolve2) {
            resolve2 = _resolve2;
          });
          newElt.addEventListener("load", function() {
            resolve2();
          });
          promises.push(promise);
        }
        currentHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        currentHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }
    ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
    return promises;
  }
  function noOp() {
  }
  function mergeDefaults(config3) {
    let finalConfig = {};
    Object.assign(finalConfig, defaults2);
    Object.assign(finalConfig, config3);
    finalConfig.callbacks = {};
    Object.assign(finalConfig.callbacks, defaults2.callbacks);
    Object.assign(finalConfig.callbacks, config3.callbacks);
    finalConfig.head = {};
    Object.assign(finalConfig.head, defaults2.head);
    Object.assign(finalConfig.head, config3.head);
    return finalConfig;
  }
  function createMorphContext(oldNode, newContent, config3) {
    config3 = mergeDefaults(config3);
    return {
      target: oldNode,
      newContent,
      config: config3,
      morphStyle: config3.morphStyle,
      ignoreActive: config3.ignoreActive,
      ignoreActiveValue: config3.ignoreActiveValue,
      idMap: createIdMap(oldNode, newContent),
      deadIds: /* @__PURE__ */ new Set(),
      callbacks: config3.callbacks,
      head: config3.head
    };
  }
  function isIdSetMatch(node1, node2, ctx) {
    if (node1 == null || node2 == null) {
      return false;
    }
    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
      if (node1.id !== "" && node1.id === node2.id) {
        return true;
      } else {
        return getIdIntersectionCount(ctx, node1, node2) > 0;
      }
    }
    return false;
  }
  function isSoftMatch(node1, node2) {
    if (node1 == null || node2 == null) {
      return false;
    }
    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
  }
  function removeNodesBetween(startInclusive, endExclusive, ctx) {
    while (startInclusive !== endExclusive) {
      let tempNode = startInclusive;
      startInclusive = startInclusive.nextSibling;
      removeNode(tempNode, ctx);
    }
    removeIdsFromConsideration(ctx, endExclusive);
    return endExclusive.nextSibling;
  }
  function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
    let potentialMatch = null;
    if (newChildPotentialIdCount > 0) {
      let potentialMatch2 = insertionPoint;
      let otherMatchCount = 0;
      while (potentialMatch2 != null) {
        if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
          return potentialMatch2;
        }
        otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
        if (otherMatchCount > newChildPotentialIdCount) {
          return null;
        }
        potentialMatch2 = potentialMatch2.nextSibling;
      }
    }
    return potentialMatch;
  }
  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    let potentialSoftMatch = insertionPoint;
    let nextSibling = newChild.nextSibling;
    let siblingSoftMatchCount = 0;
    while (potentialSoftMatch != null) {
      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
        return null;
      }
      if (isSoftMatch(newChild, potentialSoftMatch)) {
        return potentialSoftMatch;
      }
      if (isSoftMatch(nextSibling, potentialSoftMatch)) {
        siblingSoftMatchCount++;
        nextSibling = nextSibling.nextSibling;
        if (siblingSoftMatchCount >= 2) {
          return null;
        }
      }
      potentialSoftMatch = potentialSoftMatch.nextSibling;
    }
    return potentialSoftMatch;
  }
  function parseContent(newContent) {
    let parser = new DOMParser();
    let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
    if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
      let content = parser.parseFromString(newContent, "text/html");
      if (contentWithSvgsRemoved.match(/<\/html>/)) {
        content.generatedByIdiomorph = true;
        return content;
      } else {
        let htmlElement = content.firstChild;
        if (htmlElement) {
          htmlElement.generatedByIdiomorph = true;
          return htmlElement;
        } else {
          return null;
        }
      }
    } else {
      let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
      let content = responseDoc.body.querySelector("template").content;
      content.generatedByIdiomorph = true;
      return content;
    }
  }
  function normalizeContent(newContent) {
    if (newContent == null) {
      const dummyParent = document.createElement("div");
      return dummyParent;
    } else if (newContent.generatedByIdiomorph) {
      return newContent;
    } else if (newContent instanceof Node) {
      const dummyParent = document.createElement("div");
      dummyParent.append(newContent);
      return dummyParent;
    } else {
      const dummyParent = document.createElement("div");
      for (const elt of [...newContent]) {
        dummyParent.append(elt);
      }
      return dummyParent;
    }
  }
  function insertSiblings(previousSibling, morphedNode, nextSibling) {
    let stack = [];
    let added = [];
    while (previousSibling != null) {
      stack.push(previousSibling);
      previousSibling = previousSibling.previousSibling;
    }
    while (stack.length > 0) {
      let node = stack.pop();
      added.push(node);
      morphedNode.parentElement.insertBefore(node, morphedNode);
    }
    added.push(morphedNode);
    while (nextSibling != null) {
      stack.push(nextSibling);
      added.push(nextSibling);
      nextSibling = nextSibling.nextSibling;
    }
    while (stack.length > 0) {
      morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
    }
    return added;
  }
  function findBestNodeMatch(newContent, oldNode, ctx) {
    let currentElement;
    currentElement = newContent.firstChild;
    let bestElement = currentElement;
    let score = 0;
    while (currentElement) {
      let newScore = scoreElement(currentElement, oldNode, ctx);
      if (newScore > score) {
        bestElement = currentElement;
        score = newScore;
      }
      currentElement = currentElement.nextSibling;
    }
    return bestElement;
  }
  function scoreElement(node1, node2, ctx) {
    if (isSoftMatch(node1, node2)) {
      return 0.5 + getIdIntersectionCount(ctx, node1, node2);
    }
    return 0;
  }
  function removeNode(tempNode, ctx) {
    removeIdsFromConsideration(ctx, tempNode);
    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
    tempNode.remove();
    ctx.callbacks.afterNodeRemoved(tempNode);
  }
  function isIdInConsideration(ctx, id2) {
    return !ctx.deadIds.has(id2);
  }
  function idIsWithinNode(ctx, id2, targetNode) {
    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
    return idSet.has(id2);
  }
  function removeIdsFromConsideration(ctx, node) {
    let idSet = ctx.idMap.get(node) || EMPTY_SET;
    for (const id2 of idSet) {
      ctx.deadIds.add(id2);
    }
  }
  function getIdIntersectionCount(ctx, node1, node2) {
    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
    let matchCount = 0;
    for (const id2 of sourceSet) {
      if (isIdInConsideration(ctx, id2) && idIsWithinNode(ctx, id2, node2)) {
        ++matchCount;
      }
    }
    return matchCount;
  }
  function populateIdMapForNode(node, idMap) {
    let nodeParent = node.parentElement;
    let idElements = node.querySelectorAll("[id]");
    for (const elt of idElements) {
      let current = elt;
      while (current !== nodeParent && current != null) {
        let idSet = idMap.get(current);
        if (idSet == null) {
          idSet = /* @__PURE__ */ new Set();
          idMap.set(current, idSet);
        }
        idSet.add(elt.id);
        current = current.parentElement;
      }
    }
  }
  function createIdMap(oldContent, newContent) {
    let idMap = /* @__PURE__ */ new Map();
    populateIdMapForNode(oldContent, idMap);
    populateIdMapForNode(newContent, idMap);
    return idMap;
  }
  return {
    morph,
    defaults: defaults2
  };
}();
function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
  Idiomorph.morph(currentElement, newElement, {
    ...options,
    callbacks: new DefaultIdiomorphCallbacks(callbacks)
  });
}
function morphChildren(currentElement, newElement) {
  morphElements(currentElement, newElement.children, {
    morphStyle: "innerHTML"
  });
}
var DefaultIdiomorphCallbacks = class {
  #beforeNodeMorphed;
  constructor({ beforeNodeMorphed } = {}) {
    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
  }
  beforeNodeAdded = (node) => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
  };
  beforeNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
        const event2 = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: currentElement,
          detail: { currentElement, newElement }
        });
        return !event2.defaultPrevented;
      } else {
        return false;
      }
    }
  };
  beforeAttributeUpdated = (attributeName, target, mutationType) => {
    const event2 = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: { attributeName, mutationType }
    });
    return !event2.defaultPrevented;
  };
  beforeNodeRemoved = (node) => {
    return this.beforeNodeMorphed(node);
  };
  afterNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      dispatch("turbo:morph-element", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
    }
  };
};
var MorphingFrameRenderer = class extends FrameRenderer {
  static renderElement(currentElement, newElement) {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: { currentElement, newElement }
    });
    morphChildren(currentElement, newElement);
  }
  async preservingPermanentElements(callback2) {
    return await callback2();
  }
};
var ProgressBar = class _ProgressBar {
  static animationDuration = 300;
  /*ms*/
  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  hiding = false;
  value = 0;
  visible = false;
  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }
  // Private
  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback2) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback2, _ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  };
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = _ProgressBar.defaultCSS;
    const cspNonce2 = getCspNonce();
    if (cspNonce2) {
      element.nonce = cspNonce2;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
};
var HeadSnapshot = class extends Snapshot {
  detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
    const { outerHTML } = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return {
      ...result,
      [outerHTML]: {
        ...details,
        elements: [...details.elements, element]
      }
    };
  }, {});
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const { type, tracked, elements: elements2 } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements2];
      } else if (elements2.length > 1) {
        return [...result, ...elements2.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, void 0 | void 0);
  }
};
function elementType(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
}
function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload";
}
function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script";
}
function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript";
}
function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
}
function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
}
function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
}
var PageSnapshot = class _PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({ documentElement, body: body2, head }) {
    return new this(documentElement, body2, new HeadSnapshot(head));
  }
  constructor(documentElement, body2, headSnapshot) {
    super(body2);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index4, source] of selectElements.entries()) {
      const clone3 = clonedSelectElements[index4];
      for (const option of clone3.selectedOptions) option.selected = false;
      for (const option of source.selectedOptions) clone3.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
  }
  get lang() {
    return this.documentElement.getAttribute("lang");
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
  }
  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph";
  }
  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve";
  }
  // Private
  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
};
var ViewTransitioner = class {
  #viewTransitionStarted = false;
  #lastOperation = Promise.resolve();
  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }
    return this.#lastOperation;
  }
  get viewTransitionsAvailable() {
    return document.startViewTransition;
  }
};
var defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {
  },
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
var TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};
var VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};
var SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};
var Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};
var Visit = class {
  identifier = uuid();
  // Required by turbo-ios
  timingMetrics = {};
  followedRedirect = false;
  historyChanged = false;
  scrolled = false;
  shouldCacheSnapshot = true;
  acceptsStreamResponse = false;
  snapshotCached = false;
  state = VisitState.initialized;
  viewTransitioner = new ViewTransitioner();
  constructor(delegate2, location2, restorationIdentifier, options = {}) {
    this.delegate = delegate2;
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }
  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const { statusCode } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const { statusCode, responseHTML } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot) this.cacheSnapshot();
        if (this.view.renderPromise) await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise) await this.view.renderPromise;
          await this.renderPageSnapshot(snapshot, isPreview);
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }
  // Fetch request delegate
  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {
  }
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == void 0) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : void 0;
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == void 0) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }
  // Scrolling
  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const { scrollPosition } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }
  // Instrumentation
  recordTimingMetric(metric) {
    this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
  }
  getTimingMetrics() {
    return { ...this.timingMetrics };
  }
  // Private
  getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback2) {
    this.cancelRender();
    await new Promise((resolve2) => {
      this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve2(), 0) : requestAnimationFrame(() => resolve2());
    });
    await callback2();
    delete this.frame;
  }
  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
};
function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300;
}
var BrowserAdapter = class {
  progressBar = new ProgressBar();
  constructor(session2) {
    this.session = session2;
  }
  visitProposedToLocation(location2, options) {
    if (locationIsVisitable(location2, this.navigator.rootLocation)) {
      this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location2.toString();
    }
  }
  visitStarted(visit2) {
    this.location = visit2.location;
    visit2.loadCachedSnapshot();
    visit2.issueRequest();
    visit2.goToSamePageAnchor();
  }
  visitRequestStarted(visit2) {
    this.progressBar.setValue(0);
    if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit2) {
    visit2.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit2, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit2.loadResponse();
    }
  }
  visitRequestFinished(_visit) {
  }
  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitRendered(_visit) {
  }
  // Form Submission Delegate
  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }
  // Private
  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  showProgressBar = () => {
    this.progressBar.show();
  };
  reload(reason) {
    dispatch("turbo:reload", { detail: reason });
    window.location.href = this.location?.toString() || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
};
var CacheObserver = class {
  selector = "[data-turbo-temporary]";
  deprecatedSelector = "[data-turbo-cache=false]";
  started = false;
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  removeTemporaryElements = (_event) => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  };
  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
  }
  get temporaryElementsWithDeprecation() {
    const elements2 = document.querySelectorAll(this.deprecatedSelector);
    if (elements2.length) {
      console.warn(
        `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
      );
    }
    return [...elements2];
  }
};
var FrameRedirector = class {
  constructor(session2, element) {
    this.session = session2;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }
  // Link interceptor delegate
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event2) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event2);
    }
  }
  // Form submit observer delegate
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter2);
    }
  }
  #shouldSubmit(form2, submitter2) {
    const action = getAction$1(form2, submitter2);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return this.#shouldRedirect(form2, submitter2) && locationIsVisitable(action, rootLocation);
  }
  #shouldRedirect(element, submitter2) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter2);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  #findFrameElement(element, submitter2) {
    const id2 = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id2 && id2 != "_top") {
      const frame = this.element.querySelector(`#${id2}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
};
var History = class {
  location;
  restorationIdentifier = uuid();
  restorationData = {};
  started = false;
  pageLoaded = false;
  currentIndex = 0;
  constructor(delegate2) {
    this.delegate = delegate2;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location2, restorationIdentifier) {
    this.update(history.pushState, location2, restorationIdentifier);
  }
  replace(location2, restorationIdentifier) {
    this.update(history.replaceState, location2, restorationIdentifier);
  }
  update(method, location2, restorationIdentifier = uuid()) {
    if (method === history.pushState) ++this.currentIndex;
    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
    method.call(history, state, "", location2.href);
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier;
  }
  // Restoration data
  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const { restorationIdentifier } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }
  // Scroll restoration
  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }
  // Event handlers
  onPopState = (event2) => {
    if (this.shouldHandlePopState()) {
      const { turbo } = event2.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const { restorationIdentifier, restorationIndex } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  };
  onPageLoad = async (_event) => {
    await nextMicrotask();
    this.pageLoaded = true;
  };
  // Private
  shouldHandlePopState() {
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
};
var LinkPrefetchObserver = class {
  started = false;
  #prefetchedLink = null;
  constructor(delegate2, eventTarget) {
    this.delegate = delegate2;
    this.eventTarget = eventTarget;
  }
  start() {
    if (this.started) return;
    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
    } else {
      this.#enable();
    }
  }
  stop() {
    if (!this.started) return;
    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }
  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  };
  #tryToPrefetchRequest = (event2) => {
    if (getMetaContent("turbo-prefetch") === "false") return;
    const target = event2.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location2 = getLocationForLink(link);
      if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
        this.#prefetchedLink = link;
        const fetchRequest = new FetchRequest(
          this,
          FetchMethod.get,
          location2,
          new URLSearchParams(),
          target
        );
        prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  };
  #cancelRequestIfObsolete = (event2) => {
    if (event2.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
  };
  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  };
  #tryToUsePrefetchedRequest = (event2) => {
    if (event2.target.tagName !== "FORM" && event2.detail.fetchOptions.method === "GET") {
      const cached = prefetchCache.get(event2.detail.url.toString());
      if (cached) {
        event2.detail.fetchRequest = cached;
      }
      prefetchCache.clear();
    }
  };
  prepareRequest(request) {
    const link = request.target;
    request.headers["X-Sec-Purpose"] = "prefetch";
    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }
  // Fetch request interface
  requestSucceededWithResponse() {
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  }
  #isPrefetchable(link) {
    const href2 = link.getAttribute("href");
    if (!href2) return false;
    if (unfetchableLink(link)) return false;
    if (linkToTheSamePage(link)) return false;
    if (linkOptsOut(link)) return false;
    if (nonSafeLink(link)) return false;
    if (eventPrevented(link)) return false;
    return true;
  }
};
var unfetchableLink = (link) => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
};
var linkToTheSamePage = (link) => {
  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
};
var linkOptsOut = (link) => {
  if (link.getAttribute("data-turbo-prefetch") === "false") return true;
  if (link.getAttribute("data-turbo") === "false") return true;
  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
  return false;
};
var nonSafeLink = (link) => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
  if (isUJS(link)) return true;
  if (link.hasAttribute("data-turbo-confirm")) return true;
  if (link.hasAttribute("data-turbo-stream")) return true;
  return false;
};
var isUJS = (link) => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
};
var eventPrevented = (link) => {
  const event2 = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
  return event2.defaultPrevented;
};
var Navigator = class {
  constructor(delegate2) {
    this.delegate = delegate2;
  }
  proposeVisit(location2, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
      this.delegate.visitProposedToLocation(location2, options);
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }
  submitForm(form2, submitter2) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form2, submitter2, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get rootLocation() {
    return this.view.snapshot.rootLocation;
  }
  get history() {
    return this.delegate.history;
  }
  // Form submission delegate
  formSubmissionStarted(formSubmission) {
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const { statusCode, redirected } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: { statusCode, responseHTML, redirected }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if (!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error2) {
    console.error(error2);
  }
  formSubmissionFinished(formSubmission) {
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }
  // Visit delegate
  visitStarted(visit2) {
    this.delegate.visitStarted(visit2);
  }
  visitCompleted(visit2) {
    this.delegate.visitCompleted(visit2);
    delete this.currentVisit;
  }
  locationWithActionIsSamePage(location2, action) {
    const anchor = getAnchor(location2);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }
  // Visits
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const { submitter: submitter2, formElement } = formSubmission;
    return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
  }
  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  }
};
var PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};
var PageObserver = class {
  stage = PageStage.initial;
  started = false;
  constructor(delegate2) {
    this.delegate = delegate2;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  interpretReadyState = () => {
    const { readyState } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  };
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  };
  get readyState() {
    return document.readyState;
  }
};
var ScrollObserver = class {
  started = false;
  constructor(delegate2) {
    this.delegate = delegate2;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  onScroll = () => {
    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
  };
  // Private
  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
};
var StreamMessageRenderer = class {
  render({ fragment }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }
  // Bardo delegate
  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {
  }
};
function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const { id: id2 } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id2);
      if (elementInStream) {
        permanentElementMap[id2] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
}
async function withAutofocusFromFragment(fragment, callback2) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;
  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }
    elementWithAutofocus.id = willAutofocusId;
  }
  callback2();
  await nextRepaint();
  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);
    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}
async function withPreservedFocus(callback2) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback2, () => document.activeElement);
  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);
    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}
function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
    if (elementWithAutofocus) return elementWithAutofocus;
  }
  return null;
}
var StreamObserver = class {
  sources = /* @__PURE__ */ new Set();
  #started = false;
  constructor(delegate2) {
    this.delegate = delegate2;
  }
  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  inspectFetchResponse = (event2) => {
    const response = fetchResponseFromEvent(event2);
    if (response && fetchResponseIsStream(response)) {
      event2.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  receiveMessageEvent = (event2) => {
    if (this.#started && typeof event2.data == "string") {
      this.receiveMessageHTML(event2.data);
    }
  };
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
};
function fetchResponseFromEvent(event2) {
  const fetchResponse = event2.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
}
function fetchResponseIsStream(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType);
}
var ErrorRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    const { documentElement, body: body2 } = document;
    documentElement.replaceChild(newElement, body2);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const { documentElement, head } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
};
var PageRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  #setLanguage() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index4, newElement] of elementList.entries()) {
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index4, 1);
          return true;
        }
      }
      if (newElement.isEqualNode(element)) {
        elementList.splice(index4, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter((element) => {
      return element.getAttribute("data-turbo-track") === "dynamic";
    });
  }
  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
};
var MorphingPageRenderer = class extends PageRenderer {
  static renderElement(currentElement, newElement) {
    morphElements(currentElement, newElement, {
      callbacks: {
        beforeNodeMorphed: (element) => !canRefreshFrame(element)
      }
    });
    for (const frame of currentElement.querySelectorAll("turbo-frame")) {
      if (canRefreshFrame(frame)) frame.reload();
    }
    dispatch("turbo:morph", { detail: { currentElement, newElement } });
  }
  async preservingPermanentElements(callback2) {
    return await callback2();
  }
  get renderMethod() {
    return "morph";
  }
  get shouldAutofocus() {
    return false;
  }
};
function canRefreshFrame(frame) {
  return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
}
var SnapshotCache = class {
  keys = [];
  snapshots = {};
  constructor(size) {
    this.size = size;
  }
  has(location2) {
    return toCacheKey(location2) in this.snapshots;
  }
  get(location2) {
    if (this.has(location2)) {
      const snapshot = this.read(location2);
      this.touch(location2);
      return snapshot;
    }
  }
  put(location2, snapshot) {
    this.write(location2, snapshot);
    this.touch(location2);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }
  // Private
  read(location2) {
    return this.snapshots[toCacheKey(location2)];
  }
  write(location2, snapshot) {
    this.snapshots[toCacheKey(location2)] = snapshot;
  }
  touch(location2) {
    const key = toCacheKey(location2);
    const index4 = this.keys.indexOf(key);
    if (index4 > -1) this.keys.splice(index4, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
};
var PageView = class extends View {
  snapshotCache = new SnapshotCache(10);
  lastRenderedLocation = new URL(location.href);
  forceReloaded = false;
  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit2) {
    const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit2?.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit2) {
    visit2?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const { lastRenderedLocation: location2 } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location2, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location2) {
    return this.snapshotCache.get(location2);
  }
  isPageRefresh(visit2) {
    return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
  }
  shouldPreserveScrollPosition(visit2) {
    return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
};
var Preloader = class {
  selector = "a[data-turbo-preload]";
  constructor(delegate2, snapshotCache) {
    this.delegate = delegate2;
    this.snapshotCache = snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }
  async preloadURL(link) {
    const location2 = new URL(link.href);
    if (this.snapshotCache.has(location2)) {
      return;
    }
    const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
    await fetchRequest.perform();
  }
  // Fetch request delegate
  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }
  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_4) {
    }
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  };
};
var Cache = class {
  constructor(session2) {
    this.session = session2;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.#setCacheControl("");
  }
  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }
  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
};
var Session = class {
  navigator = new Navigator(this);
  history = new History(this);
  view = new PageView(this, document.documentElement);
  adapter = new BrowserAdapter(this);
  pageObserver = new PageObserver(this);
  cacheObserver = new CacheObserver();
  linkPrefetchObserver = new LinkPrefetchObserver(this, document);
  linkClickObserver = new LinkClickObserver(this, window);
  formSubmitObserver = new FormSubmitObserver(this, document);
  scrollObserver = new ScrollObserver(this);
  streamObserver = new StreamObserver(this);
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  frameRedirector = new FrameRedirector(this, document.documentElement);
  streamMessageRenderer = new StreamMessageRenderer();
  cache = new Cache(this);
  enabled = true;
  started = false;
  #pageRefreshDebouncePeriod = 150;
  constructor(recentRequests2) {
    this.recentRequests = recentRequests2;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location2, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);
      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location2.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
  }
  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    if (!isRecentRequest && !this.navigator.currentVisit) {
      this.visit(url, { action: "replace", shouldCacheSnapshot: false });
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    console.warn(
      "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
    );
    this.progressBarDelay = delay;
  }
  set progressBarDelay(delay) {
    config.drive.progressBarDelay = delay;
  }
  get progressBarDelay() {
    return config.drive.progressBarDelay;
  }
  set drive(value) {
    config.drive.enabled = value;
  }
  get drive() {
    return config.drive.enabled;
  }
  set formMode(value) {
    config.forms.mode = value;
  }
  get formMode() {
    return config.forms.mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod;
  }
  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }
  // Preloader delegate
  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false;
    } else {
      const location2 = new URL(element.href);
      return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
  }
  // History delegate
  historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location2, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }
  // Scroll observer delegate
  scrollPositionChanged(position) {
    this.history.updateRestorationData({ scrollPosition: position });
  }
  // Form click observer delegate
  willSubmitFormLinkToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {
  }
  // Link hover observer delegate
  canPrefetchRequestToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  // Link click observer delegate
  willFollowLinkToLocation(link, location2, event2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event2);
  }
  followedLinkToLocation(link, location2) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location2.href, { action, acceptsStreamResponse });
  }
  // Navigator delegate
  allowsVisitingLocationWithAction(location2, action) {
    return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
  }
  visitProposedToLocation(location2, options) {
    extendURLWithDeprecatedProperties(location2);
    this.adapter.visitProposedToLocation(location2, options);
  }
  // Visit delegate
  visitStarted(visit2) {
    if (!visit2.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit2.direction);
    }
    extendURLWithDeprecatedProperties(visit2.location);
    if (!visit2.silent) {
      this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
    }
  }
  visitCompleted(visit2) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
  }
  locationWithActionIsSamePage(location2, action) {
    return this.navigator.locationWithActionIsSamePage(location2, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }
  // Form submit observer delegate
  willSubmitForm(form2, submitter2) {
    const action = getAction$1(form2, submitter2);
    return this.submissionIsNavigatable(form2, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form2, submitter2) {
    this.navigator.submitForm(form2, submitter2);
  }
  // Page observer delegate
  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }
  // Stream observer delegate
  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }
  // Page view delegate
  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({ element }, options) {
    const event2 = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: { render }
    } = event2;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }
  // Frame element
  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }
  // Application events
  applicationAllowsFollowingLinkToLocation(link, location2, ev) {
    const event2 = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
    return !event2.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location2) {
    const event2 = this.notifyApplicationBeforeVisitingLocation(location2);
    return !event2.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location2, event2) {
    return dispatch("turbo:click", {
      target: link,
      detail: { url: location2.href, originalEvent: event2 },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location2) {
    return dispatch("turbo:before-visit", {
      detail: { url: location2.href },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location2, action) {
    return dispatch("turbo:visit", { detail: { url: location2.href, action } });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: { newBody, ...options },
      cancelable: true
    });
  }
  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", { detail: { renderMethod } });
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: { url: this.location.href, timing }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(
      new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      })
    );
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", { target: frame });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: { fetchResponse },
      target: frame,
      cancelable: true
    });
  }
  // Helpers
  submissionIsNavigatable(form2, submitter2) {
    if (config.forms.mode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
      if (config.forms.mode == "optin") {
        return submitterIsNavigatable && form2.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form2);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");
    if (config.drive.enabled || withinFrame) {
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }
  // Private
  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
};
function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}
var deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
var session = new Session(recentRequests);
var { cache, navigator: navigator$1 } = session;
function start2() {
  session.start();
}
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}
function visit(location2, options) {
  session.visit(location2, options);
}
function connectStreamSource(source) {
  session.connectStreamSource(source);
}
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}
function clearCache() {
  console.warn(
    "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  session.clearCache();
}
function setProgressBarDelay(delay) {
  console.warn(
    "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.drive.progressBarDelay = delay;
}
function setConfirmMethod(confirmMethod) {
  console.warn(
    "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.confirm = confirmMethod;
}
function setFormMode(mode) {
  console.warn(
    "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.mode = mode;
}
var Turbo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session,
  cache,
  PageRenderer,
  PageSnapshot,
  FrameRenderer,
  fetch: fetchWithTurboHeaders,
  config,
  start: start2,
  registerAdapter,
  visit,
  connectStreamSource,
  disconnectStreamSource,
  renderStreamMessage,
  clearCache,
  setProgressBarDelay,
  setConfirmMethod,
  setFormMode
});
var TurboFrameMissingError = class extends Error {
};
var FrameController = class {
  fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
  #currentFetchRequest = null;
  #resolveVisitPromise = () => {
  };
  #connected = false;
  #hasBeenLoaded = false;
  #ignoredAttributes = /* @__PURE__ */ new Set();
  #shouldMorphFrame = false;
  action = null;
  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }
  // Frame delegate
  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src")) return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const { refresh, src } = this.element;
    this.#shouldMorphFrame = src && refresh === "morph";
    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }
  async #loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document2 = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document2);
        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document2);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.#shouldMorphFrame = false;
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }
  // Appearance observer delegate
  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }
  // Form link click observer delegate
  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form2) {
    const frame = this.#findFrameElement(link);
    if (frame) form2.setAttribute("data-turbo-frame", frame.id);
  }
  // Link interceptor delegate
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location2) {
    this.#navigateFrame(element, location2);
  }
  // Form submit observer delegate
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter2);
    const { fetchRequest } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }
  // Fetch request delegate
  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;
    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  requestErrored(request, error2) {
    console.error(error2);
    this.#resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }
  // Form submission delegate
  formSubmissionStarted({ formElement }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);
    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }
  formSubmissionErrored(formSubmission, error2) {
    console.error(error2);
  }
  formSubmissionFinished({ formElement }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }
  // View delegate
  allowsImmediateRender({ element: newFrame }, options) {
    const event2 = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: { newFrame, ...options },
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: { render }
    } = event2;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
  }
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {
  }
  // Frame renderer delegate
  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  visitCachedSnapshot = ({ element }) => {
    const frame = element.querySelector("#" + this.element.id);
    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };
  // Private
  async #loadFrameResponse(fetchResponse, document2) {
    const newFrameElement = await this.extractForeignFrameElement(document2.body);
    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
      if (this.view.renderPromise) await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }
  async #visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;
    return new Promise((resolve2) => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {
        };
        this.#currentFetchRequest = null;
        resolve2();
      };
      request.perform();
    });
  }
  #navigateFrame(element, url, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const { visitCachedSnapshot } = frame.delegate;
      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
        if (frame.src) {
          const { statusCode, redirected } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = { statusCode, redirected, responseHTML };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action) options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  async #handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(
      `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
    );
    await this.#visitResponse(fetchResponse.response);
  }
  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit2 = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event2 = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit: visit2 },
      cancelable: true
    });
    return !event2.defaultPrevented;
  }
  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }
  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  }
  async #visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const { location: location2, redirected, statusCode } = wrapped;
    return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
  }
  #findFrameElement(element, submitter2) {
    const id2 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    return getFrameElementById(id2) ?? this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id2 = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id2}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id2}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error2) {
      console.error(error2);
      return new FrameElement();
    }
    return null;
  }
  #formActionIsVisitable(form2, submitter2) {
    const action = getAction$1(form2, submitter2);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  #shouldInterceptNavigation(element, submitter2) {
    const id2 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
      return false;
    }
    if (!this.enabled || id2 == "_top") {
      return false;
    }
    if (id2) {
      const frameElement = getFrameElementById(id2);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter2 && !session.elementIsNavigatable(submitter2)) {
      return false;
    }
    return true;
  }
  // Computed properties
  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }
  get isActive() {
    return this.element.isActive && this.#connected;
  }
  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root);
  }
  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName);
  }
  #ignoringChangesToAttribute(attributeName, callback2) {
    this.#ignoredAttributes.add(attributeName);
    callback2();
    this.#ignoredAttributes.delete(attributeName);
  }
  #withCurrentNavigationElement(element, callback2) {
    this.currentNavigationElement = element;
    callback2();
    delete this.currentNavigationElement;
  }
};
function getFrameElementById(id2) {
  if (id2 != null) {
    const element = document.getElementById(id2);
    if (element instanceof FrameElement) {
      return element;
    }
  }
}
function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
}
var StreamActions = {
  after() {
    this.targetElements.forEach((e4) => e4.parentElement?.insertBefore(this.templateContent, e4.nextSibling));
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e4) => e4.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach((e4) => e4.parentElement?.insertBefore(this.templateContent, e4));
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e4) => e4.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach((e4) => e4.remove());
  },
  replace() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphElements(targetElement, this.templateContent);
      } else {
        targetElement.replaceWith(this.templateContent);
      }
    });
  },
  update() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphChildren(targetElement, this.templateContent);
      } else {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      }
    });
  },
  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};
var StreamElement = class _StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error2) {
      console.error(error2);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    return this.renderPromise ??= (async () => {
      const event2 = this.beforeRenderEvent;
      if (this.dispatchEvent(event2)) {
        await nextRepaint();
        await event2.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
    } catch {
    }
  }
  /**
   * Removes duplicate children (by ID)
   */
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach((c4) => c4.remove());
  }
  /**
   * Gets the list of duplicate children (i.e. those with the same ID)
   */
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap((e4) => [...e4.children]).filter((c4) => !!c4.id);
    const newChildrenIds = [...this.templateContent?.children || []].filter((c4) => !!c4.id).map((c4) => c4.id);
    return existingChildren.filter((c4) => newChildrenIds.includes(c4.id));
  }
  /**
   * Gets the action function to be performed.
   */
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }
  /**
   * Gets the target elements which the template will be rendered to.
   */
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }
  /**
   * Gets the contents of the main `<template>`.
   */
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }
  /**
   * Gets the main `<template>` used for rendering
   */
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.#raise("first child element must be a <template> element");
  }
  /**
   * Gets the current action.
   */
  get action() {
    return this.getAttribute("action");
  }
  /**
   * Gets the current target (an element ID) to which the result will
   * be rendered.
   */
  get target() {
    return this.getAttribute("target");
  }
  /**
   * Gets the current "targets" selector (a CSS selector)
   */
  get targets() {
    return this.getAttribute("targets");
  }
  /**
   * Reads the request-id attribute
   */
  get requestId() {
    return this.getAttribute("request-id");
  }
  #raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: { newStream: this, render: _StreamElement.renderElement }
    });
  }
  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    const elements2 = this.ownerDocument?.querySelectorAll(this.targets);
    if (elements2.length !== 0) {
      return Array.prototype.slice.call(elements2);
    } else {
      return [];
    }
  }
};
var StreamSourceElement = class extends HTMLElement {
  streamSource = null;
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
};
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === void 0) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === void 0) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === void 0) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element) return;
  if (element.hasAttribute("data-turbo-suppress-warning")) return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(
        unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
        element.outerHTML
      );
    }
    element = element.parentElement;
  }
})();
window.Turbo = { ...Turbo, StreamActions };
start2();

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
var consumer;
async function getConsumer() {
  return consumer || setConsumer(createConsumer2().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer = newConsumer;
}
async function createConsumer2() {
  const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
  return createConsumer3();
}
async function subscribeTo(channel, mixin) {
  const { subscriptions } = await getConsumer();
  return subscriptions.create(channel, mixin);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
function walk(obj) {
  if (!obj || typeof obj !== "object") return obj;
  if (obj instanceof Date || obj instanceof RegExp) return obj;
  if (Array.isArray(obj)) return obj.map(walk);
  return Object.keys(obj).reduce(function(acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m5, x5) {
      return "_" + x5.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
var TurboCableStreamSourceElement = class extends HTMLElement {
  static observedAttributes = ["channel", "signed-stream-name"];
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this),
      connected: this.subscriptionConnected.bind(this),
      disconnected: this.subscriptionDisconnected.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription) this.subscription.unsubscribe();
    this.subscriptionDisconnected();
  }
  attributeChangedCallback() {
    if (this.subscription) {
      this.disconnectedCallback();
      this.connectedCallback();
    }
  }
  dispatchMessageEvent(data) {
    const event2 = new MessageEvent("message", { data });
    return this.dispatchEvent(event2);
  }
  subscriptionConnected() {
    this.setAttribute("connected", "");
  }
  subscriptionDisconnected() {
    this.removeAttribute("connected");
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
  }
};
if (customElements.get("turbo-cable-stream-source") === void 0) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
function encodeMethodIntoRequestBody(event2) {
  if (event2.target instanceof HTMLFormElement) {
    const { target: form2, detail: { fetchOptions } } = event2;
    form2.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
      const body2 = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
      const method = determineFetchMethod(submitter2, body2, form2);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body2.delete("_method");
        } else {
          body2.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, { once: true });
  }
}
function determineFetchMethod(submitter2, body2, form2) {
  const formMethod = determineFormMethod(submitter2);
  const overrideMethod = body2.get("_method");
  const method = form2.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
}
function determineFormMethod(submitter2) {
  if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
    if (submitter2.name === "_method") {
      return submitter2.value;
    } else if (submitter2.hasAttribute("formmethod")) {
      return submitter2.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
}
function isBodyInit(body2) {
  return body2 instanceof FormData || body2 instanceof URLSearchParams;
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
window.Turbo = turbo_es2017_esm_exports;
addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

// node_modules/@hotwired/stimulus/dist/stimulus.js
var EventListener = class {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = /* @__PURE__ */ new Set();
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event2) {
    const extendedEvent = extendEvent(event2);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left, right) => {
      const leftIndex = left.index, rightIndex = right.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
};
function extendEvent(event2) {
  if ("immediatePropagationStopped" in event2) {
    return event2;
  } else {
    const { stopImmediatePropagation } = event2;
    return Object.assign(event2, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
}
var Dispatcher = class {
  constructor(application2) {
    this.application = application2;
    this.eventListenerMaps = /* @__PURE__ */ new Map();
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach((eventListener) => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach((eventListener) => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map3) => listeners.concat(Array.from(map3.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners)
      this.clearEventListenersForBinding(binding);
  }
  handleError(error2, message, detail = {}) {
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0)
      this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = /* @__PURE__ */ new Map();
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach((key) => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
};
var defaultActionDescriptorFilters = {
  stop({ event: event2, value }) {
    if (value)
      event2.stopPropagation();
    return true;
  },
  prevent({ event: event2, value }) {
    if (value)
      event2.preventDefault();
    return true;
  },
  self({ event: event2, value, element }) {
    if (value) {
      return element === event2.target;
    } else {
      return true;
    }
  }
};
var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
  const source = descriptorString.trim();
  const matches2 = source.match(descriptorPattern) || [];
  let eventName = matches2[2];
  let keyFilter = matches2[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches2[4]),
    eventName,
    eventOptions: matches2[7] ? parseEventOptions(matches2[7]) : {},
    identifier: matches2[5],
    methodName: matches2[6],
    keyFilter: matches2[1] || keyFilter
  };
}
function parseEventTarget(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
}
function parseEventOptions(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
}
function camelize(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_4, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
  return value.replace(/([A-Z])/g, (_4, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
  return value.match(/[^\s]+/g) || [];
}
function isSomething(object) {
  return object !== null && object !== void 0;
}
function hasProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
var allModifiers = ["meta", "ctrl", "alt", "shift"];
var Action = class {
  constructor(element, index4, descriptor, schema) {
    this.element = element;
    this.index = index4;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event2) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event2, filters)) {
      return true;
    }
    const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event2.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event2) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event2, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
    for (const { name, value } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event2, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
    return event2.metaKey !== meta || event2.ctrlKey !== ctrl || event2.altKey !== alt || event2.shiftKey !== shift;
  }
};
var defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: (e4) => e4.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};
function getDefaultEventNameForElement(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
}
function error(message) {
  throw new Error(message);
}
function typecast(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
}
var Binding = class {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event2) {
    const actionEvent = this.prepareActionEvent(event2);
    if (this.willBeInvokedByEvent(event2) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event2) {
    const { element } = this.action;
    const { actionDescriptorFilters } = this.context.application;
    const { controller } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({ name, value, event: event2, element, controller });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event2) {
    return Object.assign(event2, { params: this.action.params });
  }
  invokeWithEvent(event2) {
    const { target, currentTarget } = event2;
    try {
      this.method.call(this.controller, event2);
      this.context.logDebugActivity(this.methodName, { event: event2, target, currentTarget, action: this.methodName });
    } catch (error2) {
      const { identifier, controller, element, index: index4 } = this;
      const detail = { identifier, controller, element, index: index4, event: event2 };
      this.context.handleError(error2, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event2) {
    const eventTarget = event2.target;
    if (event2 instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event2)) {
      return false;
    }
    if (event2 instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event2)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
};
var ElementObserver = class {
  constructor(element, delegate2) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate2;
    this.elements = /* @__PURE__ */ new Set();
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback2) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback2();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches2 = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches2.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches2)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
};
var AttributeObserver = class {
  constructor(element, attributeName, delegate2) {
    this.attributeName = attributeName;
    this.delegate = delegate2;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback2) {
    this.elementObserver.pause(callback2);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches2 = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches2);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
};
function add(map3, key, value) {
  fetch2(map3, key).add(value);
}
function del(map3, key, value) {
  fetch2(map3, key).delete(value);
  prune(map3, key);
}
function fetch2(map3, key) {
  let values = map3.get(key);
  if (!values) {
    values = /* @__PURE__ */ new Set();
    map3.set(key, values);
  }
  return values;
}
function prune(map3, key) {
  const values = map3.get(key);
  if (values != null && values.size == 0) {
    map3.delete(key);
  }
}
var Multimap = class {
  constructor() {
    this.valuesByKey = /* @__PURE__ */ new Map();
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set2) => values.concat(Array.from(set2)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set2) => size + set2.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some((set2) => set2.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
};
var SelectorObserver = class {
  constructor(element, selector, delegate2, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate2;
    this.matchesByElement = new Multimap();
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback2) {
    this.elementObserver.pause(callback2);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const { selector } = this;
    if (selector) {
      const matches2 = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches2 && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches2;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const { selector } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches2);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const { selector } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const { selector } = this;
    if (selector) {
      const matches2 = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches2 && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches2 && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
};
var StringMapObserver = class {
  constructor(element, delegate2) {
    this.element = element;
    this.delegate = delegate2;
    this.started = false;
    this.stringMap = /* @__PURE__ */ new Map();
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue2 = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue2)
          this.stringMapKeyRemoved(key, attributeName, oldValue2);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map((attribute) => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
};
var TokenListObserver = class {
  constructor(element, attributeName, delegate2) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate2;
    this.tokensByElement = new Multimap();
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback2) {
    this.attributeObserver.pause(callback2);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach((token) => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach((token) => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
};
function parseTokenString(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index4) => ({ element, attributeName, content, index: index4 }));
}
function zip(left, right) {
  const length = Math.max(left.length, right.length);
  return Array.from({ length }, (_4, index4) => [left[index4], right[index4]]);
}
function tokensAreEqual(left, right) {
  return left && right && left.index == right.index && left.content == right.content;
}
var ValueListObserver = class {
  constructor(element, attributeName, delegate2) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate2;
    this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
    this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = /* @__PURE__ */ new Map();
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return { value };
    } catch (error2) {
      return { error: error2 };
    }
  }
};
var BindingObserver = class {
  constructor(context, delegate2) {
    this.context = context;
    this.delegate = delegate2;
    this.bindingsByAction = /* @__PURE__ */ new Map();
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
};
var ValueObserver = class {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
      return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
      if (defaultValue != void 0 && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), void 0);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error2) {
        if (error2 instanceof TypeError) {
          error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
        }
        throw error2;
      }
    }
  }
  get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors2 = {};
    Object.keys(this.valueDescriptorMap).forEach((key) => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors2[descriptor.name] = descriptor;
    });
    return descriptors2;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
};
var TargetObserver = class {
  constructor(context, delegate2) {
    this.context = context;
    this.delegate = delegate2;
    this.targetsByName = new Multimap();
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
};
function readInheritableStaticArrayValues(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor2) => {
    getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
    return values;
  }, /* @__PURE__ */ new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor2) => {
    pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
    return pairs;
  }, []);
}
function getAncestorsForConstructor(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}
var OutletObserver = class {
  constructor(context, delegate2) {
    this.started = false;
    this.context = context;
    this.delegate = delegate2;
    this.outletsByName = new Multimap();
    this.outletElementsByName = new Multimap();
    this.selectorObserverMap = /* @__PURE__ */ new Map();
    this.attributeObserverMap = /* @__PURE__ */ new Map();
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach((outletName) => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach((context) => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach((observer) => observer.refresh());
    this.attributeObserverMap.forEach((observer) => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach((observer) => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach((observer) => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, { outletName }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, { outletName }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, { outletName }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap();
    this.router.modules.forEach((module) => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
};
var Context = class {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error2) {
      this.handleError(error2, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error2) {
      this.handleError(error2, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error2) {
      this.handleError(error2, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error2, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
};
function bless(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
  const shadowConstructor = extend2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
}
function getBlessedProperties(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
}
function getShadowProperties(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
  }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
}
var getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
var extend2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a4 = function() {
      this.a.call(this);
    };
    const b4 = extendWithReflect(a4);
    b4.prototype.a = function() {
    };
    return new b4();
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error2) {
    return (constructor) => class extended extends constructor {
    };
  }
})();
function blessDefinition(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
}
var Module = class {
  constructor(application2, definition) {
    this.application = application2;
    this.definition = blessDefinition(definition);
    this.contextsByScope = /* @__PURE__ */ new WeakMap();
    this.connectedContexts = /* @__PURE__ */ new Set();
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
};
var ClassMap = class {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
};
var DataMap = class {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
};
var Guide = class {
  constructor(logger) {
    this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = /* @__PURE__ */ new Set();
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
};
function attributeValueContainsToken(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
}
var TargetSet = class {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [
      ...targets,
      ...this.findAllTargets(targetName),
      ...this.findAllLegacyTargets(targetName)
    ], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const { identifier } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
};
var OutletSet = class {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector)
      return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements2 = this.scope.queryElements(selector);
    return elements2.filter((element) => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements2 = this.scope.queryElements(selector);
    return elements2.filter((element) => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
};
var Scope = class _Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element2) => {
      return element2.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [
      ...this.element.matches(selector) ? [this.element] : [],
      ...this.queryElements(selector).filter(this.containsElement)
    ];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
};
var ScopeObserver = class {
  constructor(element, schema, delegate2) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate2;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
    this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const { element, content: identifier } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = /* @__PURE__ */ new Map();
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
};
var Router = class {
  constructor(application2) {
    this.application = application2;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap();
    this.modulesByIdentifier = /* @__PURE__ */ new Map();
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find((context) => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error2, message, detail) {
    this.application.handleError(error2, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.disconnectContextForScope(scope));
  }
};
var defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: (identifier) => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c4) => [c4, c4]))), objectFromEntries("0123456789".split("").map((n3) => [n3, n3])))
};
function objectFromEntries(array) {
  return array.reduce((memo, [k4, v4]) => Object.assign(Object.assign({}, memo), { [k4]: v4 }), {});
}
var Application = class {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application2 = new this(element, schema);
    application2.start();
    return application2;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach((definition) => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map((context) => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error2, message, detail) {
    var _a;
    this.logger.error(`%s

%o

%o`, message, error2, detail);
    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
};
function domReady() {
  return new Promise((resolve2) => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve2());
    } else {
      resolve2();
    }
  });
}
function ClassPropertiesBlessing(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
}
function propertiesForClassDefinition(key) {
  return {
    [`${key}Class`]: {
      get() {
        const { classes } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
}
function OutletPropertiesBlessing(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
}
function getOutletController(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
}
function propertiesForOutletDefinition(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController)
            return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map((outletElement) => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter((controller) => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
}
function TargetPropertiesBlessing(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
}
function propertiesForTargetDefinition(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
}
function ValuePropertiesBlessing(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, { [attributeName]: valueDescriptor });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const { key, name, reader: read, writer: write } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === void 0) {
          this.data.delete(key);
        } else {
          this.data.set(key, write(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
}
function parseValueTypeConstant(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
}
function parseValueTypeDefault(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue))
    return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]")
    return "object";
}
function parseValueTypeObject(payload) {
  const { controller, token, typeObject } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType)
    return typeFromObject;
  if (onlyDefault)
    return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject)
    return typeFromObject;
}
function parseValueTypeDefinition(payload) {
  const { controller, token, typeDefinition } = payload;
  const typeObject = { controller, token, typeObject: typeDefinition };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type)
    return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant)
    return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault)
    return typeObject.default;
  if (hasType) {
    const { type } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType)
      return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
  const { token, typeDefinition } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== void 0;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
}
var defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
var readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
var writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};
function writeJSON(value) {
  return JSON.stringify(value);
}
function writeString(value) {
  return `${value}`;
}
var Controller = class {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {
  }
  connect() {
  }
  disconnect() {
  }
  dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event2 = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event2);
    return event2;
  }
};
Controller.blessings = [
  ClassPropertiesBlessing,
  TargetPropertiesBlessing,
  ValuePropertiesBlessing,
  OutletPropertiesBlessing
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

// app/javascript/controllers/application.js
var application = Application.start();
application.debug = false;
window.Stimulus = application;

// app/javascript/controllers/hello_controller.js
var hello_controller_default = class extends Controller {
  connect() {
    this.element.textContent = "Hello World!";
  }
};

// app/javascript/controllers/index.js
application.register("hello", hello_controller_default);

// app/javascript/application.js
var import_jquery = __toESM(require_jquery());
var import_bootstrap_bundle = __toESM(require_bootstrap_bundle_min());

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n3, l4) {
  for (var u4 in l4) n3[u4] = l4[u4];
  return n3;
}
function v(n3) {
  var l4 = n3.parentNode;
  l4 && l4.removeChild(n3);
}
function y(l4, u4, i4) {
  var t5, r4, o3, f4 = {};
  for (o3 in u4) "key" == o3 ? t5 = u4[o3] : "ref" == o3 ? r4 = u4[o3] : f4[o3] = u4[o3];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i4), "function" == typeof l4 && null != l4.defaultProps) for (o3 in l4.defaultProps) void 0 === f4[o3] && (f4[o3] = l4.defaultProps[o3]);
  return p(l4, f4, t5, r4, null);
}
function p(n3, i4, t5, r4, o3) {
  var f4 = { type: n3, props: i4, key: t5, ref: r4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o3 ? ++u : o3 };
  return null == o3 && null != l.vnode && l.vnode(f4), f4;
}
function d() {
  return { current: null };
}
function _(n3) {
  return n3.children;
}
function k(n3, l4, u4, i4, t5) {
  var r4;
  for (r4 in u4) "children" === r4 || "key" === r4 || r4 in l4 || g(n3, r4, null, u4[r4], i4);
  for (r4 in l4) t5 && "function" != typeof l4[r4] || "children" === r4 || "key" === r4 || "value" === r4 || "checked" === r4 || u4[r4] === l4[r4] || g(n3, r4, l4[r4], u4[r4], i4);
}
function b(n3, l4, u4) {
  "-" === l4[0] ? n3.setProperty(l4, null == u4 ? "" : u4) : n3[l4] = null == u4 ? "" : "number" != typeof u4 || a.test(l4) ? u4 : u4 + "px";
}
function g(n3, l4, u4, i4, t5) {
  var r4;
  n: if ("style" === l4) if ("string" == typeof u4) n3.style.cssText = u4;
  else {
    if ("string" == typeof i4 && (n3.style.cssText = i4 = ""), i4) for (l4 in i4) u4 && l4 in u4 || b(n3.style, l4, "");
    if (u4) for (l4 in u4) i4 && u4[l4] === i4[l4] || b(n3.style, l4, u4[l4]);
  }
  else if ("o" === l4[0] && "n" === l4[1]) r4 = l4 !== (l4 = l4.replace(/Capture$/, "")), l4 = l4.toLowerCase() in n3 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + r4] = u4, u4 ? i4 || n3.addEventListener(l4, r4 ? w : m2, r4) : n3.removeEventListener(l4, r4 ? w : m2, r4);
  else if ("dangerouslySetInnerHTML" !== l4) {
    if (t5) l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && l4 in n3) try {
      n3[l4] = null == u4 ? "" : u4;
      break n;
    } catch (n4) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && -1 == l4.indexOf("-") ? n3.removeAttribute(l4) : n3.setAttribute(l4, u4));
  }
}
function m2(n3) {
  t = true;
  try {
    return this.l[n3.type + false](l.event ? l.event(n3) : n3);
  } finally {
    t = false;
  }
}
function w(n3) {
  t = true;
  try {
    return this.l[n3.type + true](l.event ? l.event(n3) : n3);
  } finally {
    t = false;
  }
}
function x(n3, l4) {
  this.props = n3, this.context = l4;
}
function A(n3, l4) {
  if (null == l4) return n3.__ ? A(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u4; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) return u4.__e;
  return "function" == typeof n3.type ? A(n3) : null;
}
function P(n3) {
  var l4, u4;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++) if (null != (u4 = n3.__k[l4]) && null != u4.__e) {
      n3.__e = n3.__c.base = u4.__e;
      break;
    }
    return P(n3);
  }
}
function C(n3) {
  t ? setTimeout(n3) : f(n3);
}
function T(n3) {
  (!n3.__d && (n3.__d = true) && r.push(n3) && !$2.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($2);
}
function $2() {
  var n3, l4, u4, i4, t5, o3, f4, e4;
  for (r.sort(function(n4, l5) {
    return n4.__v.__b - l5.__v.__b;
  }); n3 = r.shift(); ) n3.__d && (l4 = r.length, i4 = void 0, t5 = void 0, f4 = (o3 = (u4 = n3).__v).__e, (e4 = u4.__P) && (i4 = [], (t5 = h({}, o3)).__v = o3.__v + 1, M(e4, o3, t5, u4.__n, void 0 !== e4.ownerSVGElement, null != o3.__h ? [f4] : null, i4, null == f4 ? A(o3) : f4, o3.__h), N(i4, o3), o3.__e != f4 && P(o3)), r.length > l4 && r.sort(function(n4, l5) {
    return n4.__v.__b - l5.__v.__b;
  }));
  $2.__r = 0;
}
function H(n3, l4, u4, i4, t5, r4, o3, f4, e4, a4) {
  var h4, v4, y4, d3, k4, b4, g5, m5 = i4 && i4.__k || s, w5 = m5.length;
  for (u4.__k = [], h4 = 0; h4 < l4.length; h4++) if (null != (d3 = u4.__k[h4] = null == (d3 = l4[h4]) || "boolean" == typeof d3 ? null : "string" == typeof d3 || "number" == typeof d3 || "bigint" == typeof d3 ? p(null, d3, null, null, d3) : Array.isArray(d3) ? p(_, { children: d3 }, null, null, null) : d3.__b > 0 ? p(d3.type, d3.props, d3.key, d3.ref ? d3.ref : null, d3.__v) : d3)) {
    if (d3.__ = u4, d3.__b = u4.__b + 1, null === (y4 = m5[h4]) || y4 && d3.key == y4.key && d3.type === y4.type) m5[h4] = void 0;
    else for (v4 = 0; v4 < w5; v4++) {
      if ((y4 = m5[v4]) && d3.key == y4.key && d3.type === y4.type) {
        m5[v4] = void 0;
        break;
      }
      y4 = null;
    }
    M(n3, d3, y4 = y4 || c, t5, r4, o3, f4, e4, a4), k4 = d3.__e, (v4 = d3.ref) && y4.ref != v4 && (g5 || (g5 = []), y4.ref && g5.push(y4.ref, null, d3), g5.push(v4, d3.__c || k4, d3)), null != k4 ? (null == b4 && (b4 = k4), "function" == typeof d3.type && d3.__k === y4.__k ? d3.__d = e4 = I(d3, e4, n3) : e4 = z(n3, d3, y4, m5, k4, e4), "function" == typeof u4.type && (u4.__d = e4)) : e4 && y4.__e == e4 && e4.parentNode != n3 && (e4 = A(y4));
  }
  for (u4.__e = b4, h4 = w5; h4--; ) null != m5[h4] && ("function" == typeof u4.type && null != m5[h4].__e && m5[h4].__e == u4.__d && (u4.__d = L(i4).nextSibling), q(m5[h4], m5[h4]));
  if (g5) for (h4 = 0; h4 < g5.length; h4++) S(g5[h4], g5[++h4], g5[++h4]);
}
function I(n3, l4, u4) {
  for (var i4, t5 = n3.__k, r4 = 0; t5 && r4 < t5.length; r4++) (i4 = t5[r4]) && (i4.__ = n3, l4 = "function" == typeof i4.type ? I(i4, l4, u4) : z(u4, i4, i4, t5, i4.__e, l4));
  return l4;
}
function j(n3, l4) {
  return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (Array.isArray(n3) ? n3.some(function(n4) {
    j(n4, l4);
  }) : l4.push(n3)), l4;
}
function z(n3, l4, u4, i4, t5, r4) {
  var o3, f4, e4;
  if (void 0 !== l4.__d) o3 = l4.__d, l4.__d = void 0;
  else if (null == u4 || t5 != r4 || null == t5.parentNode) n: if (null == r4 || r4.parentNode !== n3) n3.appendChild(t5), o3 = null;
  else {
    for (f4 = r4, e4 = 0; (f4 = f4.nextSibling) && e4 < i4.length; e4 += 1) if (f4 == t5) break n;
    n3.insertBefore(t5, r4), o3 = r4;
  }
  return void 0 !== o3 ? o3 : t5.nextSibling;
}
function L(n3) {
  var l4, u4, i4;
  if (null == n3.type || "string" == typeof n3.type) return n3.__e;
  if (n3.__k) {
    for (l4 = n3.__k.length - 1; l4 >= 0; l4--) if ((u4 = n3.__k[l4]) && (i4 = L(u4))) return i4;
  }
  return null;
}
function M(n3, u4, i4, t5, r4, o3, f4, e4, c4) {
  var s4, a4, v4, y4, p4, d3, k4, b4, g5, m5, w5, A4, P4, C4, T5, $6 = u4.type;
  if (void 0 !== u4.constructor) return null;
  null != i4.__h && (c4 = i4.__h, e4 = u4.__e = i4.__e, u4.__h = null, o3 = [e4]), (s4 = l.__b) && s4(u4);
  try {
    n: if ("function" == typeof $6) {
      if (b4 = u4.props, g5 = (s4 = $6.contextType) && t5[s4.__c], m5 = s4 ? g5 ? g5.props.value : s4.__ : t5, i4.__c ? k4 = (a4 = u4.__c = i4.__c).__ = a4.__E : ("prototype" in $6 && $6.prototype.render ? u4.__c = a4 = new $6(b4, m5) : (u4.__c = a4 = new x(b4, m5), a4.constructor = $6, a4.render = B), g5 && g5.sub(a4), a4.props = b4, a4.state || (a4.state = {}), a4.context = m5, a4.__n = t5, v4 = a4.__d = true, a4.__h = [], a4._sb = []), null == a4.__s && (a4.__s = a4.state), null != $6.getDerivedStateFromProps && (a4.__s == a4.state && (a4.__s = h({}, a4.__s)), h(a4.__s, $6.getDerivedStateFromProps(b4, a4.__s))), y4 = a4.props, p4 = a4.state, a4.__v = u4, v4) null == $6.getDerivedStateFromProps && null != a4.componentWillMount && a4.componentWillMount(), null != a4.componentDidMount && a4.__h.push(a4.componentDidMount);
      else {
        if (null == $6.getDerivedStateFromProps && b4 !== y4 && null != a4.componentWillReceiveProps && a4.componentWillReceiveProps(b4, m5), !a4.__e && null != a4.shouldComponentUpdate && false === a4.shouldComponentUpdate(b4, a4.__s, m5) || u4.__v === i4.__v) {
          for (u4.__v !== i4.__v && (a4.props = b4, a4.state = a4.__s, a4.__d = false), u4.__e = i4.__e, u4.__k = i4.__k, u4.__k.forEach(function(n4) {
            n4 && (n4.__ = u4);
          }), w5 = 0; w5 < a4._sb.length; w5++) a4.__h.push(a4._sb[w5]);
          a4._sb = [], a4.__h.length && f4.push(a4);
          break n;
        }
        null != a4.componentWillUpdate && a4.componentWillUpdate(b4, a4.__s, m5), null != a4.componentDidUpdate && a4.__h.push(function() {
          a4.componentDidUpdate(y4, p4, d3);
        });
      }
      if (a4.context = m5, a4.props = b4, a4.__P = n3, A4 = l.__r, P4 = 0, "prototype" in $6 && $6.prototype.render) {
        for (a4.state = a4.__s, a4.__d = false, A4 && A4(u4), s4 = a4.render(a4.props, a4.state, a4.context), C4 = 0; C4 < a4._sb.length; C4++) a4.__h.push(a4._sb[C4]);
        a4._sb = [];
      } else do {
        a4.__d = false, A4 && A4(u4), s4 = a4.render(a4.props, a4.state, a4.context), a4.state = a4.__s;
      } while (a4.__d && ++P4 < 25);
      a4.state = a4.__s, null != a4.getChildContext && (t5 = h(h({}, t5), a4.getChildContext())), v4 || null == a4.getSnapshotBeforeUpdate || (d3 = a4.getSnapshotBeforeUpdate(y4, p4)), T5 = null != s4 && s4.type === _ && null == s4.key ? s4.props.children : s4, H(n3, Array.isArray(T5) ? T5 : [T5], u4, i4, t5, r4, o3, f4, e4, c4), a4.base = u4.__e, u4.__h = null, a4.__h.length && f4.push(a4), k4 && (a4.__E = a4.__ = null), a4.__e = false;
    } else null == o3 && u4.__v === i4.__v ? (u4.__k = i4.__k, u4.__e = i4.__e) : u4.__e = O(i4.__e, u4, i4, t5, r4, o3, f4, c4);
    (s4 = l.diffed) && s4(u4);
  } catch (n4) {
    u4.__v = null, (c4 || null != o3) && (u4.__e = e4, u4.__h = !!c4, o3[o3.indexOf(e4)] = null), l.__e(n4, u4, i4);
  }
}
function N(n3, u4) {
  l.__c && l.__c(u4, n3), n3.some(function(u5) {
    try {
      n3 = u5.__h, u5.__h = [], n3.some(function(n4) {
        n4.call(u5);
      });
    } catch (n4) {
      l.__e(n4, u5.__v);
    }
  });
}
function O(l4, u4, i4, t5, r4, o3, f4, e4) {
  var s4, a4, h4, y4 = i4.props, p4 = u4.props, d3 = u4.type, _4 = 0;
  if ("svg" === d3 && (r4 = true), null != o3) {
    for (; _4 < o3.length; _4++) if ((s4 = o3[_4]) && "setAttribute" in s4 == !!d3 && (d3 ? s4.localName === d3 : 3 === s4.nodeType)) {
      l4 = s4, o3[_4] = null;
      break;
    }
  }
  if (null == l4) {
    if (null === d3) return document.createTextNode(p4);
    l4 = r4 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p4.is && p4), o3 = null, e4 = false;
  }
  if (null === d3) y4 === p4 || e4 && l4.data === p4 || (l4.data = p4);
  else {
    if (o3 = o3 && n.call(l4.childNodes), a4 = (y4 = i4.props || c).dangerouslySetInnerHTML, h4 = p4.dangerouslySetInnerHTML, !e4) {
      if (null != o3) for (y4 = {}, _4 = 0; _4 < l4.attributes.length; _4++) y4[l4.attributes[_4].name] = l4.attributes[_4].value;
      (h4 || a4) && (h4 && (a4 && h4.__html == a4.__html || h4.__html === l4.innerHTML) || (l4.innerHTML = h4 && h4.__html || ""));
    }
    if (k(l4, p4, y4, r4, e4), h4) u4.__k = [];
    else if (_4 = u4.props.children, H(l4, Array.isArray(_4) ? _4 : [_4], u4, i4, t5, r4 && "foreignObject" !== d3, o3, f4, o3 ? o3[0] : i4.__k && A(i4, 0), e4), null != o3) for (_4 = o3.length; _4--; ) null != o3[_4] && v(o3[_4]);
    e4 || ("value" in p4 && void 0 !== (_4 = p4.value) && (_4 !== l4.value || "progress" === d3 && !_4 || "option" === d3 && _4 !== y4.value) && g(l4, "value", _4, y4.value, false), "checked" in p4 && void 0 !== (_4 = p4.checked) && _4 !== l4.checked && g(l4, "checked", _4, y4.checked, false));
  }
  return l4;
}
function S(n3, u4, i4) {
  try {
    "function" == typeof n3 ? n3(u4) : n3.current = u4;
  } catch (n4) {
    l.__e(n4, i4);
  }
}
function q(n3, u4, i4) {
  var t5, r4;
  if (l.unmount && l.unmount(n3), (t5 = n3.ref) && (t5.current && t5.current !== n3.__e || S(t5, null, u4)), null != (t5 = n3.__c)) {
    if (t5.componentWillUnmount) try {
      t5.componentWillUnmount();
    } catch (n4) {
      l.__e(n4, u4);
    }
    t5.base = t5.__P = null, n3.__c = void 0;
  }
  if (t5 = n3.__k) for (r4 = 0; r4 < t5.length; r4++) t5[r4] && q(t5[r4], u4, i4 || "function" != typeof n3.type);
  i4 || null == n3.__e || v(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
function B(n3, l4, u4) {
  return this.constructor(n3, u4);
}
function D(u4, i4, t5) {
  var r4, o3, f4;
  l.__ && l.__(u4, i4), o3 = (r4 = "function" == typeof t5) ? null : t5 && t5.__k || i4.__k, f4 = [], M(i4, u4 = (!r4 && t5 || i4).__k = y(_, null, [u4]), o3 || c, c, void 0 !== i4.ownerSVGElement, !r4 && t5 ? [t5] : o3 ? null : i4.firstChild ? n.call(i4.childNodes) : null, f4, !r4 && t5 ? t5 : o3 ? o3.__e : i4.firstChild, r4), N(f4, u4);
}
function G(n3, l4) {
  var u4 = { __c: l4 = "__cC" + e++, __: n3, Consumer: function(n4, l5) {
    return n4.children(l5);
  }, Provider: function(n4) {
    var u5, i4;
    return this.getChildContext || (u5 = [], (i4 = {})[l4] = this, this.getChildContext = function() {
      return i4;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u5.some(function(n6) {
        n6.__e = true, T(n6);
      });
    }, this.sub = function(n5) {
      u5.push(n5);
      var l5 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u5.splice(u5.indexOf(n5), 1), l5 && l5.call(n5);
      };
    }), n4.children;
  } };
  return u4.Provider.__ = u4.Consumer.contextType = u4;
}
n = s.slice, l = { __e: function(n3, l4, u4, i4) {
  for (var t5, r4, o3; l4 = l4.__; ) if ((t5 = l4.__c) && !t5.__) try {
    if ((r4 = t5.constructor) && null != r4.getDerivedStateFromError && (t5.setState(r4.getDerivedStateFromError(n3)), o3 = t5.__d), null != t5.componentDidCatch && (t5.componentDidCatch(n3, i4 || {}), o3 = t5.__d), o3) return t5.__E = t5;
  } catch (l5) {
    n3 = l5;
  }
  throw n3;
} }, u = 0, i = function(n3) {
  return null != n3 && void 0 === n3.constructor;
}, t = false, x.prototype.setState = function(n3, l4) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n3 && (n3 = n3(h({}, u4), this.props)), n3 && h(u4, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), T(this));
}, x.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $2.__r = 0, e = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m3 = l.unmount;
function b2() {
  for (var t5; t5 = f2.shift(); ) if (t5.__P && t5.__H) try {
    t5.__H.__h.forEach(k2), t5.__H.__h.forEach(w2), t5.__H.__h = [];
  } catch (r4) {
    t5.__H.__h = [], l.__e(r4, t5.__v);
  }
}
l.__b = function(n3) {
  r2 = null, e2 && e2(n3);
}, l.__r = function(n3) {
  a2 && a2(n3), t2 = 0;
  var i4 = (r2 = n3.__c).__H;
  i4 && (u2 === r2 ? (i4.__h = [], r2.__h = [], i4.__.forEach(function(n4) {
    n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
  })) : (i4.__h.forEach(k2), i4.__h.forEach(w2), i4.__h = [])), u2 = r2;
}, l.diffed = function(t5) {
  v2 && v2(t5);
  var o3 = t5.__c;
  o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t5, r4) {
  r4.some(function(t6) {
    try {
      t6.__h.forEach(k2), t6.__h = t6.__h.filter(function(n3) {
        return !n3.__ || w2(n3);
      });
    } catch (u4) {
      r4.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), r4 = [], l.__e(u4, t6.__v);
    }
  }), l2 && l2(t5, r4);
}, l.unmount = function(t5) {
  m3 && m3(t5);
  var r4, u4 = t5.__c;
  u4 && u4.__H && (u4.__H.__.forEach(function(n3) {
    try {
      k2(n3);
    } catch (n4) {
      r4 = n4;
    }
  }), u4.__H = void 0, r4 && l.__e(r4, u4.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n3) {
  var t5, r4 = function() {
    clearTimeout(u4), g2 && cancelAnimationFrame(t5), setTimeout(n3);
  }, u4 = setTimeout(r4, 100);
  g2 && (t5 = requestAnimationFrame(r4));
}
function k2(n3) {
  var t5 = r2, u4 = n3.__c;
  "function" == typeof u4 && (n3.__c = void 0, u4()), r2 = t5;
}
function w2(n3) {
  var t5 = r2;
  n3.__c = n3.__(), r2 = t5;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n3, t5) {
  for (var e4 in t5) n3[e4] = t5[e4];
  return n3;
}
function C2(n3, t5) {
  for (var e4 in n3) if ("__source" !== e4 && !(e4 in t5)) return true;
  for (var r4 in t5) if ("__source" !== r4 && n3[r4] !== t5[r4]) return true;
  return false;
}
function w3(n3) {
  this.props = n3;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n3, t5) {
  return C2(this.props, n3) || C2(this.state, t5);
};
var x3 = l.__b;
l.__b = function(n3) {
  n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), x3 && x3(n3);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n3, t5, e4, r4) {
  if (n3.then) {
    for (var u4, o3 = t5; o3 = o3.__; ) if ((u4 = o3.__c) && u4.__c) return null == t5.__e && (t5.__e = e4.__e, t5.__k = e4.__k), u4.__c(n3, t5);
  }
  T3(n3, t5, e4, r4);
};
var I2 = l.unmount;
function L2(n3, t5, e4) {
  return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
    "function" == typeof n4.__c && n4.__c();
  }), n3.__c.__H = null), null != (n3 = g3({}, n3)).__c && (n3.__c.__P === e4 && (n3.__c.__P = t5), n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
    return L2(n4, t5, e4);
  })), n3;
}
function U(n3, t5, e4) {
  return n3 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
    return U(n4, t5, e4);
  }), n3.__c && n3.__c.__P === t5 && (n3.__e && e4.insertBefore(n3.__e, n3.__d), n3.__c.__e = true, n3.__c.__P = e4)), n3;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n3) {
  var t5 = n3.__.__c;
  return t5 && t5.__a && t5.__a(n3);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n3) {
  var t5 = n3.__c;
  t5 && t5.__R && t5.__R(), t5 && true === n3.__h && (n3.type = null), I2 && I2(n3);
}, (D2.prototype = new x()).__c = function(n3, t5) {
  var e4 = t5.__c, r4 = this;
  null == r4.t && (r4.t = []), r4.t.push(e4);
  var u4 = F3(r4.__v), o3 = false, i4 = function() {
    o3 || (o3 = true, e4.__R = null, u4 ? u4(l4) : l4());
  };
  e4.__R = i4;
  var l4 = function() {
    if (!--r4.__u) {
      if (r4.state.__a) {
        var n4 = r4.state.__a;
        r4.__v.__k[0] = U(n4, n4.__c.__P, n4.__c.__O);
      }
      var t6;
      for (r4.setState({ __a: r4.__b = null }); t6 = r4.t.pop(); ) t6.forceUpdate();
    }
  }, c4 = true === t5.__h;
  r4.__u++ || c4 || r4.setState({ __a: r4.__b = r4.__v.__k[0] }), n3.then(i4, i4);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n3, e4) {
  if (this.__b) {
    if (this.__v.__k) {
      var r4 = document.createElement("div"), o3 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r4, o3.__O = o3.__P);
    }
    this.__b = null;
  }
  var i4 = e4.__a && y(_, null, n3.fallback);
  return i4 && (i4.__h = null), [y(_, null, e4.__a ? null : n3.children), i4];
};
var W = function(n3, t5, e4) {
  if (++e4[1] === e4[0] && n3.o.delete(t5), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size)) for (e4 = n3.u; e4; ) {
    for (; e4.length > 3; ) e4.pop()();
    if (e4[1] < e4[0]) break;
    n3.u = e4 = e4[2];
  }
};
function P2(n3) {
  return this.getChildContext = function() {
    return n3.context;
  }, n3.children;
}
function $3(n3) {
  var e4 = this, r4 = n3.i;
  e4.componentWillUnmount = function() {
    D(null, e4.l), e4.l = null, e4.i = null;
  }, e4.i && e4.i !== r4 && e4.componentWillUnmount(), n3.__v ? (e4.l || (e4.i = r4, e4.l = { nodeType: 1, parentNode: r4, childNodes: [], appendChild: function(n4) {
    this.childNodes.push(n4), e4.i.appendChild(n4);
  }, insertBefore: function(n4, t5) {
    this.childNodes.push(n4), e4.i.appendChild(n4);
  }, removeChild: function(n4) {
    this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), e4.i.removeChild(n4);
  } }), D(y(P2, { context: e4.context }, n3.__v), e4.l)) : e4.l && e4.componentWillUnmount();
}
function j3(n3, e4) {
  var r4 = y($3, { __v: n3, i: e4 });
  return r4.containerInfo = e4, r4;
}
(V2.prototype = new x()).__a = function(n3) {
  var t5 = this, e4 = F3(t5.__v), r4 = t5.o.get(n3);
  return r4[0]++, function(u4) {
    var o3 = function() {
      t5.props.revealOrder ? (r4.push(u4), W(t5, n3, r4)) : u4();
    };
    e4 ? e4(o3) : o3();
  };
}, V2.prototype.render = function(n3) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t5 = j(n3.children);
  n3.revealOrder && "b" === n3.revealOrder[0] && t5.reverse();
  for (var e4 = t5.length; e4--; ) this.o.set(t5[e4], this.u = [1, 0, this.u]);
  return n3.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n3 = this;
  this.o.forEach(function(t5, e4) {
    W(n3, e4, t5);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n3) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n3);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t5) {
  Object.defineProperty(x.prototype, t5, { configurable: true, get: function() {
    return this["UNSAFE_" + t5];
  }, set: function(n3) {
    Object.defineProperty(this, t5, { configurable: true, writable: true, value: n3 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n3) {
  return G2 && (n3 = G2(n3)), n3.persist = J, n3.isPropagationStopped = K, n3.isDefaultPrevented = Q, n3.nativeEvent = n3;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n3) {
  var t5 = n3.type, e4 = n3.props, u4 = e4;
  if ("string" == typeof t5) {
    var o3 = -1 === t5.indexOf("-");
    for (var i4 in u4 = {}, e4) {
      var l4 = e4[i4];
      H2 && "children" === i4 && "noscript" === t5 || "value" === i4 && "defaultValue" in e4 && null == l4 || ("defaultValue" === i4 && "value" in e4 && null == e4.value ? i4 = "value" : "download" === i4 && true === l4 ? l4 = "" : /ondoubleclick/i.test(i4) ? i4 = "ondblclick" : /^onchange(textarea|input)/i.test(i4 + t5) && !Z(e4.type) ? i4 = "oninput" : /^onfocus$/i.test(i4) ? i4 = "onfocusin" : /^onblur$/i.test(i4) ? i4 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i4) ? i4 = i4.toLowerCase() : o3 && B2.test(i4) ? i4 = i4.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l4 && (l4 = void 0), /^oninput$/i.test(i4) && (i4 = i4.toLowerCase(), u4[i4] && (i4 = "oninputCapture")), u4[i4] = l4);
    }
    "select" == t5 && u4.multiple && Array.isArray(u4.value) && (u4.value = j(e4.children).forEach(function(n4) {
      n4.props.selected = -1 != u4.value.indexOf(n4.props.value);
    })), "select" == t5 && null != u4.defaultValue && (u4.value = j(e4.children).forEach(function(n4) {
      n4.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n4.props.value) : u4.defaultValue == n4.props.value;
    })), n3.props = u4, e4.class != e4.className && (nn.enumerable = "className" in e4, null != e4.className && (u4.class = e4.className), Object.defineProperty(u4, "className", nn));
  }
  n3.$$typeof = z2, tn && tn(n3);
};
var en = l.__r;
l.__r = function(n3) {
  en && en(n3), X = n3.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce2 = getNonceValue();
      if (nonce2) {
        styleEl.nonce = nonce2;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i4) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i4);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i4 = 0; i4 < containers.length; i4 += 1) {
    let matches2 = containers[i4].querySelectorAll(selector);
    for (let j5 = 0; j5 < matches2.length; j5 += 1) {
      allMatches.push(matches2[j5]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault2(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback2) {
  let realCallback = (ev) => {
    callback2(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault2);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault2);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault2);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault2);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens = [];
  let i4;
  let token;
  if (typeof input === "string") {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }
  for (i4 = 0; i4 < tokens.length; i4 += 1) {
    token = tokens[i4];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i4;
  let cmp;
  for (i4 = 0; i4 < fieldSpecs.length; i4 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i4]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a4, b4) {
  if (!a4 && !b4) {
    return 0;
  }
  if (b4 == null) {
    return -1;
  }
  if (a4 == null) {
    return 1;
  }
  if (typeof a4 === "string" || typeof b4 === "string") {
    return String(a4).localeCompare(String(b4));
  }
  return a4 - b4;
}
function padStart(val, len) {
  let s4 = String(val);
  return "000".substr(0, len - s4.length) + s4;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index4) => str.replace("$" + index4, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a4, b4) {
  return a4 - b4;
}
function isInt(n3) {
  return n3 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s4) {
  let m5 = PARSE_RE.exec(s4);
  if (m5) {
    let sign2 = m5[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign2 * (m5[2] ? parseInt(m5[2], 10) : 0),
      milliseconds: sign2 * ((m5[3] ? parseInt(m5[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m5[4] ? parseInt(m5[4], 10) : 0) * 60 * 1e3 + // minutes
      (m5[5] ? parseInt(m5[5], 10) : 0) * 1e3 + // seconds
      (m5[6] ? parseInt(m5[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i4;
  if (len !== a1.length) {
    return false;
  }
  for (i4 = 0; i4 < len; i4 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i4], a1[i4]) : a0[i4] === a1[i4])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m5, n3) {
  let a4 = dateToUtcArray(m5);
  a4[2] += n3 * 7;
  return arrayToUtcDate(a4);
}
function addDays(m5, n3) {
  let a4 = dateToUtcArray(m5);
  a4[2] += n3;
  return arrayToUtcDate(a4);
}
function addMs(m5, n3) {
  let a4 = dateToUtcArray(m5);
  a4[6] += n3;
  return arrayToUtcDate(a4);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d3 = diffWholeDays(m0, m1);
  if (d3 !== null && d3 % 7 === 0) {
    return d3 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m5) {
  return arrayToUtcDate([
    m5.getUTCFullYear(),
    m5.getUTCMonth(),
    m5.getUTCDate()
  ]);
}
function startOfHour(m5) {
  return arrayToUtcDate([
    m5.getUTCFullYear(),
    m5.getUTCMonth(),
    m5.getUTCDate(),
    m5.getUTCHours()
  ]);
}
function startOfMinute(m5) {
  return arrayToUtcDate([
    m5.getUTCFullYear(),
    m5.getUTCMonth(),
    m5.getUTCDate(),
    m5.getUTCHours(),
    m5.getUTCMinutes()
  ]);
}
function startOfSecond(m5) {
  return arrayToUtcDate([
    m5.getUTCFullYear(),
    m5.getUTCMonth(),
    m5.getUTCDate(),
    m5.getUTCHours(),
    m5.getUTCMinutes(),
    m5.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y4 = marker.getUTCFullYear();
  let w5 = weekOfGivenYear(marker, y4, dow, doy);
  if (w5 < 1) {
    return weekOfGivenYear(marker, y4 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y4 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w5, nextW);
  }
  return w5;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a4) {
  return new Date(
    a4[0],
    a4[1] || 0,
    a4[2] == null ? 1 : a4[2],
    // day of month
    a4[3] || 0,
    a4[4] || 0,
    a4[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a4) {
  if (a4.length === 1) {
    a4 = a4.concat([0]);
  }
  return new Date(Date.UTC(...a4));
}
function isValidDate(m5) {
  return !isNaN(m5.valueOf());
}
function timeAsMs(m5) {
  return m5.getUTCHours() * 1e3 * 60 * 60 + m5.getUTCMinutes() * 1e3 * 60 + m5.getUTCSeconds() * 1e3 + m5.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s4 = marker.toISOString();
  s4 = s4.replace(".000", "");
  if (stripZeroTime) {
    s4 = s4.replace("T00:00:00Z", "");
  }
  if (s4.length > 10) {
    if (timeZoneOffset == null) {
      s4 = s4.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s4 = s4.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s4;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign2 = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign2 + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign2}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start4, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start4.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start4, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start4, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start4);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s4 = format.format(marker);
    return postProcess(s4, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s4, date, standardDateProps, extendedSettings, context) {
  s4 = s4.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s4 = injectTzoStr(s4, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s4 = s4.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s4 = s4.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s4 = s4.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s4 = s4.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s4 = s4.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s4 = s4.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s4 = s4.replace(MULTI_SPACE_RE, " ");
  s4 = s4.trim();
  return s4;
}
function injectTzoStr(s4, tzoStr) {
  let replaced = false;
  s4 = s4.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s4 += ` ${tzoStr}`;
  }
  return s4;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
  let parts = [];
  if (display === "long") {
    parts.push(weekTextLong);
  } else if (display === "short" || display === "narrow") {
    parts.push(weekText);
  }
  if (display === "long" || display === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a4 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a4,
    year: a4[0],
    month: a4[1],
    day: a4[2],
    hour: a4[3],
    minute: a4[4],
    second: a4[5],
    millisecond: a4[6]
  };
}
function createVerboseFormattingArg(start4, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start4, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start4, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start4, end, context, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start4, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start4, end, context, betterDefaultSeparator));
  }
};
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a4, b4) {
  if (typeof a4 === "object" && typeof b4 === "object" && a4 && b4) {
    return isPropsEqual(a4, b4);
  }
  return a4 === b4;
}
function isMaybeArraysEqual(a4, b4) {
  if (Array.isArray(a4) && Array.isArray(b4)) {
    return isArraysEqual(a4, b4);
  }
  return a4 === b4;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i4 = propObjs.length - 1; i4 >= 0; i4 -= 1) {
          let val = propObjs[i4][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i4 = propObjs.length - 1; i4 >= 0; i4 -= 1) {
    let props = propObjs[i4];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a4) {
  let hash = {};
  for (let item of a4) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a4 = [];
  for (let key in obj) {
    a4.push(obj[key]);
  }
  return a4;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i4 = startIndex; i4 < endIndex; i4 += step) {
    let val = hash[i4];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d3) {
    return d3.getUTCFullYear();
  }
  getMarkerMonth(d3) {
    return d3.getUTCMonth();
  }
  getMarkerDay(d3) {
    return d3.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m5 = ISO_RE.exec(str);
  if (m5) {
    let marker = new Date(Date.UTC(Number(m5[1]), m5[3] ? Number(m5[3]) - 1 : 0, Number(m5[5] || 1), Number(m5[7] || 0), Number(m5[8] || 0), Number(m5[10] || 0), m5[12] ? Number(`0.${m5[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m5[13]) {
        timeZoneOffset = (m5[15] === "-" ? -1 : 1) * (Number(m5[16] || 0) * 60 + Number(m5[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m5[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker((/* @__PURE__ */ new Date()).valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(/* @__PURE__ */ new Date()));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s4) {
    let parts = parse(s4);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a4 = this.calendarSystem.markerToArray(marker);
    a4[0] += dur.years;
    a4[1] += dur.months;
    a4[2] += dur.days;
    a4[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a4);
  }
  subtract(marker, dur) {
    let a4 = this.calendarSystem.markerToArray(marker);
    a4[0] -= dur.years;
    a4[1] -= dur.months;
    a4[2] -= dur.days;
    a4[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a4);
  }
  addYears(marker, n3) {
    let a4 = this.calendarSystem.markerToArray(marker);
    a4[0] += n3;
    return this.calendarSystem.arrayToMarker(a4);
  }
  addMonths(marker, n3) {
    let a4 = this.calendarSystem.markerToArray(marker);
    a4[1] += n3;
    return this.calendarSystem.arrayToMarker(a4);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n3 = this.diffWholeYears(m0, m1);
    if (n3 !== null) {
      return { unit: "year", value: n3 };
    }
    n3 = this.diffWholeMonths(m0, m1);
    if (n3 !== null) {
      return { unit: "month", value: n3 };
    }
    n3 = diffWholeWeeks(m0, m1);
    if (n3 !== null) {
      return { unit: "week", value: n3 };
    }
    n3 = diffWholeDays(m0, m1);
    if (n3 !== null) {
      return { unit: "day", value: n3 };
    }
    n3 = diffHours(m0, m1);
    if (isInt(n3)) {
      return { unit: "hour", value: n3 };
    }
    n3 = diffMinutes(m0, m1);
    if (isInt(n3)) {
      return { unit: "minute", value: n3 };
    }
    n3 = diffSeconds(m0, m1);
    if (isInt(n3)) {
      return { unit: "second", value: n3 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d3) {
    let diff;
    if (d3.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d3);
      }
    }
    if (d3.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d3);
      }
    }
    if (d3.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d3);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d3);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m5, unit) {
    if (unit === "year") {
      return this.startOfYear(m5);
    }
    if (unit === "month") {
      return this.startOfMonth(m5);
    }
    if (unit === "week") {
      return this.startOfWeek(m5);
    }
    if (unit === "day") {
      return startOfDay(m5);
    }
    if (unit === "hour") {
      return startOfHour(m5);
    }
    if (unit === "minute") {
      return startOfMinute(m5);
    }
    if (unit === "second") {
      return startOfSecond(m5);
    }
    return null;
  }
  startOfYear(m5) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m5)
    ]);
  }
  startOfMonth(m5) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m5),
      this.calendarSystem.getMarkerMonth(m5)
    ]);
  }
  startOfWeek(m5) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m5),
      this.calendarSystem.getMarkerMonth(m5),
      m5.getUTCDate() - (m5.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start4, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start4,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start4)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m5) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m5)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m5));
    }
    return null;
  }
  // Conversion
  toDate(m5, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m5));
    }
    if (this.timeZone === "UTC") {
      return new Date(m5.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m5.valueOf() - (forcedTzo || 0));
    }
    return new Date(m5.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m5)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className2) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className2.indexOf(prefix) !== 0) {
      className2 = prefix + className2;
    }
    return className2;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className2;
    if (isRtl && this.rtlIconClasses) {
      className2 = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className2 = this.iconClasses[buttonName];
    }
    if (className2) {
      return `${this.baseIconClass} ${className2}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className2;
    if (this.iconOverrideCustomButtonOption) {
      className2 = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className2) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className2)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback2) {
    callbackQ.push(callback2);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c4) => {
            c4.context = _props.value;
            c4.forceUpdate();
          });
        }
      };
      this.sub = (c4) => {
        subs.push(c4);
        let old = c4.componentWillUnmount;
        c4.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c4), 1);
          old && old.call(c4);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch2, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch: dispatch2,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start4 = null;
  let end = null;
  if (input.start) {
    start4 = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start4 && !end) {
    return null;
  }
  if (start4 && end && end < start4) {
    return null;
  }
  return { start: start4, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start: start4 } = constraintRange;
  let i4;
  let dateRange;
  ranges.sort(compareRanges);
  for (i4 = 0; i4 < ranges.length; i4 += 1) {
    dateRange = ranges[i4];
    if (dateRange.start > start4) {
      invertedRanges.push({ start: start4, end: dateRange.start });
    }
    if (dateRange.end > start4) {
      start4 = dateRange.end;
    }
  }
  if (start4 < constraintRange.end) {
    invertedRanges.push({ start: start4, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start: start4, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start4 === null) {
      start4 = range1.start;
    } else {
      start4 = new Date(Math.max(start4.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start4 === null || end === null || start4 < end) {
    newRange = { start: start4, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range, date) {
  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
}
function constrainMarkerToRange(date, range) {
  if (range.start != null && date < range.start) {
    return range.start;
  }
  if (range.end != null && date >= range.end) {
    return new Date(range.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start4 = startOfDay(timedRange.start);
  let end = addDays(start4, dayCnt);
  return { start: start4, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start: start4, end } = range;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start4 = startOfDay(start4);
        start4 = dateEnv.add(start4, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start: start4, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start4;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start4)) {
        start4 = this.skipHiddenDays(start4, direction);
        start4 = startOfDay(start4);
      }
    }
    function computeRes() {
      start4 = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start4, duration);
      res = { start: start4, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start4 = date;
    let end;
    if (dateAlignment) {
      start4 = dateEnv.startOf(start4, dateAlignment);
    }
    start4 = startOfDay(start4);
    start4 = this.skipHiddenDays(start4, direction);
    end = start4;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start: start4, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range = this.refineRange(simpleInput);
    if (range && (range.start == null || range.end == null)) {
      return null;
    }
    return range;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range = parseRange(rangeInput, this.props.dateEnv);
      if (range) {
        range = computeVisibleDayRange(range);
      }
      return range;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i4;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i4 = 0; i4 < 7; i4 += 1) {
      if (!(isHiddenDayHash[i4] = hiddenDays.indexOf(i4) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range) {
    let { start: start4, end } = range;
    if (start4) {
      start4 = this.skipHiddenDays(start4);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start4 == null || end == null || start4 < end) {
      return { start: start4, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i4 = 0; i4 < recurringTypes.length; i4 += 1) {
    let parsed = recurringTypes[i4].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i4
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances: instances2 } = eventStore;
  instances2 = filterHash(instances2, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start4 of starts) {
        let instance = createEventInstance(defId, {
          start: start4,
          end: dateEnv.add(start4, duration)
        });
        instances2[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances: instances2 };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances2 = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances: instances2 };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances: instances2 } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances2) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances2[instanceId].defId]) {
      filteredInstances[instanceId] = instances2[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i4 = defs.length - 1; i4 >= 0; i4 -= 1) {
    let def = defs[i4];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i4, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    // TODO: how do we track all actions that affect dateProfile :(
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances2 = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances: instances2 };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances: instances2 } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances2) {
    const instance = instances2[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class _EventImpl {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui2 = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui2 = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui2 = { startEditable: val, durationEditable: val };
      } else {
        ui2 = { [name]: val };
      }
      this.mutate({
        standardProps: { ui: ui2 }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start4 = dateEnv.createMarker(startInput);
    if (start4 && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start4, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start4 = dateEnv.createMarker(startInput);
    let end;
    if (!start4) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start4, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new _EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui: ui2 } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui2.display && ui2.display !== "auto") {
      res.display = ui2.display;
    }
    if (settings.collapseColor && ui2.backgroundColor && ui2.backgroundColor === ui2.borderColor) {
      res.color = ui2.backgroundColor;
    } else {
      if (ui2.backgroundColor) {
        res.backgroundColor = ui2.backgroundColor;
      }
      if (ui2.borderColor) {
        res.borderColor = ui2.borderColor;
      }
    }
    if (ui2.textColor) {
      res.textColor = ui2.textColor;
    }
    if (ui2.classNames.length) {
      res.classNames = ui2.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances: instances2 } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id2 in instances2) {
    let instance = instances2[id2];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui2 = eventUis[def.defId];
    if (ui2.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui2 = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui2.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui2.display !== "none") {
        (ui2.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui: ui2,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui2 = eventUis[def.defId];
      bgRanges.push({
        def,
        ui: ui2,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c4) => c4._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start4 = range.start ? range.start.valueOf() : 0;
  let end = range.end ? range.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start: start4,
    end,
    duration: end - start4,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui: ui2 } = seg.eventRange;
  let val = ui2.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui2, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range } = span;
  if (!range.start) {
    return null;
  }
  if (!range.end) {
    if (defaultDuration == null) {
      return null;
    }
    range.end = dateEnv.add(range.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range.start),
    end: dateEnv.toDate(range.end),
    startStr: dateEnv.formatIso(range.start, { omitTime }),
    endStr: dateEnv.formatIso(range.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error2) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error2);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback2) {
    callback2();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i4;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i4 = 0; i4 < viewTypes.length; i4 += 1) {
      spec = viewSpecs[viewTypes[i4]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d3, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d3), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d3, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d3), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id2) {
    let state = this.getCurrentData();
    let { defs, instances: instances2 } = state.eventStore;
    id2 = String(id2);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id2) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances2) {
          let instance = instances2[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id2) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id2 = String(id2);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id2) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i4;
    for (i4 = 0; i4 < len; i4 += 1) {
      if (leftPosition >= lefts[i4] && leftPosition < rights[i4]) {
        return i4;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i4;
    for (i4 = 0; i4 < len; i4 += 1) {
      if (topPosition >= tops[i4] && topPosition < bottoms[i4]) {
        return i4;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a4, b4) {
  const len = a4.length;
  if (len !== b4.length) {
    return false;
  }
  for (let i4 = 0; i4 < len; i4++) {
    if (Math.round(a4[i4]) !== Math.round(b4[i4])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n3) {
    window.scroll(window.scrollX, n3);
  }
  setScrollLeft(n3) {
    window.scroll(n3, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function intersectSpans(span0, span1) {
  let start4 = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start4 < end) {
    return { start: start4, end };
  }
  return null;
}
function insertAt(arr, index4, item) {
  arr.splice(index4, 0, item);
}
function binarySearch(a4, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a4.length;
  if (!endIndex || searchVal < getItemVal(a4[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a4[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a4[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config2 = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(/* @__PURE__ */ new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context) {
    super(props, context);
    this.initialNowDate = getNow(context.options.now, context.dateEnv);
    this.initialNowQueriedMs = (/* @__PURE__ */ new Date()).valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = addMs(this.initialNowDate, (/* @__PURE__ */ new Date()).valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start4 = startOfDay(date);
  let end = addDays(start4, 1);
  return { start: start4, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range, dateProfileGenerator) {
    let date = range.start;
    let { end } = range;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range) {
    let firstIndex = this.getDateDayIndex(range.start);
    let lastIndex = this.getDateDayIndex(addDays(range.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index4 = firstIndex;
      while (index4 <= lastIndex) {
        let row = Math.floor(index4 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index4 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index4 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index4 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range;
  }
  return {
    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances: instances2 } = interaction.mutatedEvents;
  for (let instanceId in instances2) {
    if (!rangeContainsRange(dateProfile.validRange, instances2[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances: instances2 } = eventStore;
  let ranges = [];
  for (let instanceId in instances2) {
    ranges.push(instances2[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className2 = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className2.push("fc-scroller-liquid-absolute");
      } else {
        className2.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className2.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i4 = 0; i4 < children.length; i4 += 1) {
      let childEl = children[i4];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i4 = 0; i4 < children.length; i4 += 1) {
      let childEl = children[i4];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i4 = 0; i4 < span; i4 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a4) => a4, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui: ui2 } = eventRange;
    const renderProps = {
      event: new EventImpl(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui2.textColor,
      backgroundColor: ui2.backgroundColor,
      borderColor: ui2.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui: ui2 } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui2.borderColor,
      backgroundColor: ui2.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range.start),
          end: context.dateEnv.toDate(range.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i4 = 0; i4 < codes.length; i4 += 1) {
    let parts = codes[i4].toLocaleLowerCase().split("-");
    for (let j5 = parts.length; j5 > 0; j5 -= 1) {
      let simpleId = parts.slice(0, j5).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    // TODO: how do we track all actions that affect dateProfile :(
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error2) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error2);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error2);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error2.message, error2);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error: error2
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range.start);
  params[endParam] = dateEnv.formatIso(range.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i4 = 0; i4 < unfoundSources.length; i4 += 1) {
      if (unfoundSources[i4]._raw === input) {
        unfoundSources.splice(i4, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range = dateProfile.currentRange;
  } else {
    range = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback2 of optionsData.pluginHooks.contextInit) {
      callback2(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now2, title) {
  let todayInfo = dateProfileGenerator.build(now2, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now2),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className2 of this.currentClassNames) {
        classList.remove(className2);
      }
      for (let className2 of classNames) {
        classList.add(className2);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i4 = 0; i4 < rowCnt; i4 += 1) {
    byRow[i4] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i4 = 0; i4 < colCnt; i4 += 1) {
    byCol[i4] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui2, rowCnt) {
  let byRow = [];
  if (!ui2) {
    for (let i4 = 0; i4 < rowCnt; i4 += 1) {
      byRow[i4] = null;
    }
  } else {
    for (let i4 = 0; i4 < rowCnt; i4 += 1) {
      byRow[i4] = {
        affectedInstances: ui2.affectedInstances,
        isEvent: ui2.isEvent,
        segs: []
      };
    }
    for (let seg of ui2.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display } = seg.eventRange.ui;
  return display === "list-item" || display === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i4 = 0; i4 < segs.length; i4 += 1) {
    let seg = segs[i4];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i4,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start4 = this.props.cells[row][col].date;
    let end = addDays(start4, 1);
    return { start: start4, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start: start4, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start4 = dateEnv.startOfWeek(start4);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start: start4, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config2.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config2.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback2) {
    let done = () => {
      this.cleanup();
      callback2();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback2, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback2();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now2 = getTime();
          this.handleSide(edge, (now2 - this.msSinceRequest) / 1e3);
          this.requestAnimation(now2);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now2) {
    this.msSinceRequest = now2;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign2 = 1;
    switch (edge.name) {
      case "left":
        sign2 = -1;
      // falls through
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign2);
        break;
      case "top":
        sign2 = -1;
      // falls through
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign2);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id2 in offsetTrackers) {
      offsetTrackers[id2].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id2 in droppableStore) {
      let component = droppableStore[id2].component;
      let offsetTracker = offsetTrackers[id2];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id2;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class _EventDragging extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = _EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config2.dataAttrPrefix = "";
var index2 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@kurkle/color/dist/color.esm.js
function round(v4) {
  return v4 + 0.5 | 0;
}
var lim = (v4, l4, h4) => Math.max(Math.min(v4, h4), l4);
function p2b(v4) {
  return lim(round(v4 * 2.55), 0, 255);
}
function n2b(v4) {
  return lim(round(v4 * 255), 0, 255);
}
function b2n(v4) {
  return lim(round(v4 / 2.55) / 100, 0, 1);
}
function n2p(v4) {
  return lim(round(v4 * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b4) => hex[b4 & 15];
var h22 = (b4) => hex[(b4 & 240) >> 4] + hex[b4 & 15];
var eq = (b4) => (b4 & 240) >> 4 === (b4 & 15);
var isShort = (v4) => eq(v4.r) && eq(v4.g) && eq(v4.b) && eq(v4.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a4, f4) => a4 < 255 ? f4(a4) : "";
function hexString(v4) {
  var f4 = isShort(v4) ? h1 : h22;
  return v4 ? "#" + f4(v4.r) + f4(v4.g) + f4(v4.b) + alpha(v4.a, f4) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h4, s4, l4) {
  const a4 = s4 * Math.min(l4, 1 - l4);
  const f4 = (n3, k4 = (n3 + h4 / 30) % 12) => l4 - a4 * Math.max(Math.min(k4 - 3, 9 - k4, 1), -1);
  return [f4(0), f4(8), f4(4)];
}
function hsv2rgbn(h4, s4, v4) {
  const f4 = (n3, k4 = (n3 + h4 / 60) % 6) => v4 - v4 * s4 * Math.max(Math.min(k4, 4 - k4, 1), 0);
  return [f4(5), f4(3), f4(1)];
}
function hwb2rgbn(h4, w5, b4) {
  const rgb = hsl2rgbn(h4, 1, 0.5);
  let i4;
  if (w5 + b4 > 1) {
    i4 = 1 / (w5 + b4);
    w5 *= i4;
    b4 *= i4;
  }
  for (i4 = 0; i4 < 3; i4++) {
    rgb[i4] *= 1 - w5 - b4;
    rgb[i4] += w5;
  }
  return rgb;
}
function hueValue(r4, g5, b4, d3, max) {
  if (r4 === max) {
    return (g5 - b4) / d3 + (g5 < b4 ? 6 : 0);
  }
  if (g5 === max) {
    return (b4 - r4) / d3 + 2;
  }
  return (r4 - g5) / d3 + 4;
}
function rgb2hsl(v4) {
  const range = 255;
  const r4 = v4.r / range;
  const g5 = v4.g / range;
  const b4 = v4.b / range;
  const max = Math.max(r4, g5, b4);
  const min = Math.min(r4, g5, b4);
  const l4 = (max + min) / 2;
  let h4, s4, d3;
  if (max !== min) {
    d3 = max - min;
    s4 = l4 > 0.5 ? d3 / (2 - max - min) : d3 / (max + min);
    h4 = hueValue(r4, g5, b4, d3, max);
    h4 = h4 * 60 + 0.5;
  }
  return [h4 | 0, s4 || 0, l4];
}
function calln(f4, a4, b4, c4) {
  return (Array.isArray(a4) ? f4(a4[0], a4[1], a4[2]) : f4(a4, b4, c4)).map(n2b);
}
function hsl2rgb(h4, s4, l4) {
  return calln(hsl2rgbn, h4, s4, l4);
}
function hwb2rgb(h4, w5, b4) {
  return calln(hwb2rgbn, h4, w5, b4);
}
function hsv2rgb(h4, s4, v4) {
  return calln(hsv2rgbn, h4, s4, v4);
}
function hue(h4) {
  return (h4 % 360 + 360) % 360;
}
function hueParse(str) {
  const m5 = HUE_RE.exec(str);
  let a4 = 255;
  let v4;
  if (!m5) {
    return;
  }
  if (m5[5] !== v4) {
    a4 = m5[6] ? p2b(+m5[5]) : n2b(+m5[5]);
  }
  const h4 = hue(+m5[2]);
  const p1 = +m5[3] / 100;
  const p22 = +m5[4] / 100;
  if (m5[1] === "hwb") {
    v4 = hwb2rgb(h4, p1, p22);
  } else if (m5[1] === "hsv") {
    v4 = hsv2rgb(h4, p1, p22);
  } else {
    v4 = hsl2rgb(h4, p1, p22);
  }
  return {
    r: v4[0],
    g: v4[1],
    b: v4[2],
    a: a4
  };
}
function rotate(v4, deg) {
  var h4 = rgb2hsl(v4);
  h4[0] = hue(h4[0] + deg);
  h4 = hsl2rgb(h4);
  v4.r = h4[0];
  v4.g = h4[1];
  v4.b = h4[2];
}
function hslString(v4) {
  if (!v4) {
    return;
  }
  const a4 = rgb2hsl(v4);
  const h4 = a4[0];
  const s4 = n2p(a4[1]);
  const l4 = n2p(a4[2]);
  return v4.a < 255 ? `hsla(${h4}, ${s4}%, ${l4}%, ${b2n(v4.a)})` : `hsl(${h4}, ${s4}%, ${l4}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i4, j5, k4, ok, nk;
  for (i4 = 0; i4 < keys.length; i4++) {
    ok = nk = keys[i4];
    for (j5 = 0; j5 < tkeys.length; j5++) {
      k4 = tkeys[j5];
      nk = nk.replace(k4, map[k4]);
    }
    k4 = parseInt(names$1[ok], 16);
    unpacked[nk] = [k4 >> 16 & 255, k4 >> 8 & 255, k4 & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a4 = names[str.toLowerCase()];
  return a4 && {
    r: a4[0],
    g: a4[1],
    b: a4[2],
    a: a4.length === 4 ? a4[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m5 = RGB_RE.exec(str);
  let a4 = 255;
  let r4, g5, b4;
  if (!m5) {
    return;
  }
  if (m5[7] !== r4) {
    const v4 = +m5[7];
    a4 = m5[8] ? p2b(v4) : lim(v4 * 255, 0, 255);
  }
  r4 = +m5[1];
  g5 = +m5[3];
  b4 = +m5[5];
  r4 = 255 & (m5[2] ? p2b(r4) : lim(r4, 0, 255));
  g5 = 255 & (m5[4] ? p2b(g5) : lim(g5, 0, 255));
  b4 = 255 & (m5[6] ? p2b(b4) : lim(b4, 0, 255));
  return {
    r: r4,
    g: g5,
    b: b4,
    a: a4
  };
}
function rgbString(v4) {
  return v4 && (v4.a < 255 ? `rgba(${v4.r}, ${v4.g}, ${v4.b}, ${b2n(v4.a)})` : `rgb(${v4.r}, ${v4.g}, ${v4.b})`);
}
var to = (v4) => v4 <= 31308e-7 ? v4 * 12.92 : Math.pow(v4, 1 / 2.4) * 1.055 - 0.055;
var from = (v4) => v4 <= 0.04045 ? v4 / 12.92 : Math.pow((v4 + 0.055) / 1.055, 2.4);
function interpolate2(rgb1, rgb2, t5) {
  const r4 = from(b2n(rgb1.r));
  const g5 = from(b2n(rgb1.g));
  const b4 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r4 + t5 * (from(b2n(rgb2.r)) - r4))),
    g: n2b(to(g5 + t5 * (from(b2n(rgb2.g)) - g5))),
    b: n2b(to(b4 + t5 * (from(b2n(rgb2.b)) - b4))),
    a: rgb1.a + t5 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v4, i4, ratio) {
  if (v4) {
    let tmp = rgb2hsl(v4);
    tmp[i4] = Math.max(0, Math.min(tmp[i4] + tmp[i4] * ratio, i4 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v4.r = tmp[0];
    v4.g = tmp[1];
    v4.b = tmp[2];
  }
}
function clone(v4, proto) {
  return v4 ? Object.assign(proto || {}, v4) : v4;
}
function fromObject(input) {
  var v4 = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v4 = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v4.a = n2b(input[3]);
      }
    }
  } else {
    v4 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v4.a = n2b(v4.a);
  }
  return v4;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v4;
    if (type === "object") {
      v4 = fromObject(input);
    } else if (type === "string") {
      v4 = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v4;
    this._valid = !!v4;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v4 = clone(this._rgb);
    if (v4) {
      v4.a = b2n(v4.a);
    }
    return v4;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c22 = color2.rgb;
      let w22;
      const p4 = weight === w22 ? 0.5 : weight;
      const w5 = 2 * p4 - 1;
      const a4 = c1.a - c22.a;
      const w1 = ((w5 * a4 === -1 ? w5 : (w5 + a4) / (1 + w5 * a4)) + 1) / 2;
      w22 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w22 * c22.r + 0.5;
      c1.g = 255 & w1 * c1.g + w22 * c22.g + 0.5;
      c1.b = 255 & w1 * c1.b + w22 * c22.b + 0.5;
      c1.a = p4 * c1.a + (1 - p4) * c22.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t5) {
    if (color2) {
      this._rgb = interpolate2(this._rgb, color2._rgb, t5);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a4) {
    this._rgb.a = n2b(a4);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v4 = this._rgb;
    v4.r = 255 - v4.r;
    v4.g = 255 - v4.g;
    v4.b = 255 - v4.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = /* @__PURE__ */ (() => {
  let id2 = 0;
  return () => id2++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn2, args, thisArg) {
  if (fn2 && typeof fn2.call === "function") {
    return fn2.apply(thisArg, args);
  }
}
function each(loopable, fn2, thisArg, reverse) {
  let i4, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i4 = len - 1; i4 >= 0; i4--) {
        fn2.call(thisArg, loopable[i4], i4);
      }
    } else {
      for (i4 = 0; i4 < len; i4++) {
        fn2.call(thisArg, loopable[i4], i4);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i4 = 0; i4 < len; i4++) {
      fn2.call(thisArg, loopable[keys[i4]], keys[i4]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i4, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i4 = 0, ilen = a0.length; i4 < ilen; ++i4) {
    v0 = a0[i4];
    v1 = a1[i4];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k4 = 0;
    for (; k4 < klen; ++k4) {
      target[keys[k4]] = clone2(source[keys[k4]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i4 = 0; i4 < ilen; ++i4) {
    current = sources[i4];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k4 = 0, klen = keys.length; k4 < klen; ++k4) {
      merger(keys[k4], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v4) => v4,
  // default resolvers
  x: (o3) => o3.x,
  y: (o3) => o3.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k4 of keys) {
      if (k4 === "") {
        break;
      }
      obj = obj && obj[k4];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a4, b4) => {
  if (a4.size !== b4.size) {
    return false;
  }
  for (const item of a4) {
    if (!b4.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e4) {
  return e4.type === "mouseup" || e4.type === "click" || e4.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x5, y4, epsilon) {
  return Math.abs(x5 - y4) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i4;
  for (i4 = 1; i4 < sqrt; i4++) {
    if (value % i4 === 0) {
      result.push(i4);
      result.push(value / i4);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a4, b4) => a4 - b4).pop();
  return result;
}
function isNumber(n3) {
  return !isNaN(parseFloat(n3)) && isFinite(n3);
}
function almostWhole(x5, epsilon) {
  const rounded = Math.round(x5);
  return rounded - epsilon <= x5 && rounded + epsilon >= x5;
}
function _setMinAndMaxByKey(array, target, property) {
  let i4, ilen, value;
  for (i4 = 0, ilen = array.length; i4 < ilen; i4++) {
    value = array[i4][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x5) {
  if (!isNumberFinite(x5)) {
    return;
  }
  let e4 = 1;
  let p4 = 0;
  while (Math.round(x5 * e4) / e4 !== x5) {
    e4 *= 10;
    p4++;
  }
  return p4;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a4, b4) {
  return (a4 - b4 + PITAU) % TAU - PI;
}
function _normalizeAngle(a4) {
  return (a4 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start4, end, sameAngleIsFullCircle) {
  const a4 = _normalizeAngle(angle);
  const s4 = _normalizeAngle(start4);
  const e4 = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s4 - a4);
  const angleToEnd = _normalizeAngle(e4 - a4);
  const startToAngle = _normalizeAngle(a4 - s4);
  const endToAngle = _normalizeAngle(a4 - e4);
  return a4 === s4 || a4 === e4 || sameAngleIsFullCircle && s4 === e4 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start4, end, epsilon = 1e-6) {
  return value >= Math.min(start4, end) - epsilon && value <= Math.max(start4, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index4) => table[index4] < value);
  let hi2 = table.length - 1;
  let lo = 0;
  let mid;
  while (hi2 - lo > 1) {
    mid = lo + hi2 >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi2 = mid;
    }
  }
  return {
    lo,
    hi: hi2
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index4) => {
  const ti2 = table[index4][key];
  return ti2 < value || ti2 === value && table[index4 + 1][key] === value;
} : (index4) => table[index4][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index4) => table[index4][key] >= value);
function _filterBetween(values, min, max) {
  let start4 = 0;
  let end = values.length;
  while (start4 < end && values[start4] < min) {
    start4++;
  }
  while (end > start4 && values[end - 1] > max) {
    end--;
  }
  return start4 > 0 || end < values.length ? values.slice(start4, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index4 = listeners.indexOf(listener);
  if (index4 !== -1) {
    listeners.splice(index4, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn2, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn2.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce2(fn2, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn2, delay, args);
    } else {
      fn2.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start4, end) => align === "start" ? start4 : align === "end" ? end : (start4 + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start4 = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start4 = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start4, pointCount) - start4;
    } else {
      count = pointCount - start4;
    }
  }
  return {
    start: start4,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t5) => t5 === 0 || t5 === 1;
var elasticIn = (t5, s4, p4) => -(Math.pow(2, 10 * (t5 -= 1)) * Math.sin((t5 - s4) * TAU / p4));
var elasticOut = (t5, s4, p4) => Math.pow(2, -10 * t5) * Math.sin((t5 - s4) * TAU / p4) + 1;
var effects = {
  linear: (t5) => t5,
  easeInQuad: (t5) => t5 * t5,
  easeOutQuad: (t5) => -t5 * (t5 - 2),
  easeInOutQuad: (t5) => (t5 /= 0.5) < 1 ? 0.5 * t5 * t5 : -0.5 * (--t5 * (t5 - 2) - 1),
  easeInCubic: (t5) => t5 * t5 * t5,
  easeOutCubic: (t5) => (t5 -= 1) * t5 * t5 + 1,
  easeInOutCubic: (t5) => (t5 /= 0.5) < 1 ? 0.5 * t5 * t5 * t5 : 0.5 * ((t5 -= 2) * t5 * t5 + 2),
  easeInQuart: (t5) => t5 * t5 * t5 * t5,
  easeOutQuart: (t5) => -((t5 -= 1) * t5 * t5 * t5 - 1),
  easeInOutQuart: (t5) => (t5 /= 0.5) < 1 ? 0.5 * t5 * t5 * t5 * t5 : -0.5 * ((t5 -= 2) * t5 * t5 * t5 - 2),
  easeInQuint: (t5) => t5 * t5 * t5 * t5 * t5,
  easeOutQuint: (t5) => (t5 -= 1) * t5 * t5 * t5 * t5 + 1,
  easeInOutQuint: (t5) => (t5 /= 0.5) < 1 ? 0.5 * t5 * t5 * t5 * t5 * t5 : 0.5 * ((t5 -= 2) * t5 * t5 * t5 * t5 + 2),
  easeInSine: (t5) => -Math.cos(t5 * HALF_PI) + 1,
  easeOutSine: (t5) => Math.sin(t5 * HALF_PI),
  easeInOutSine: (t5) => -0.5 * (Math.cos(PI * t5) - 1),
  easeInExpo: (t5) => t5 === 0 ? 0 : Math.pow(2, 10 * (t5 - 1)),
  easeOutExpo: (t5) => t5 === 1 ? 1 : -Math.pow(2, -10 * t5) + 1,
  easeInOutExpo: (t5) => atEdge(t5) ? t5 : t5 < 0.5 ? 0.5 * Math.pow(2, 10 * (t5 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t5 * 2 - 1)) + 2),
  easeInCirc: (t5) => t5 >= 1 ? t5 : -(Math.sqrt(1 - t5 * t5) - 1),
  easeOutCirc: (t5) => Math.sqrt(1 - (t5 -= 1) * t5),
  easeInOutCirc: (t5) => (t5 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t5 * t5) - 1) : 0.5 * (Math.sqrt(1 - (t5 -= 2) * t5) + 1),
  easeInElastic: (t5) => atEdge(t5) ? t5 : elasticIn(t5, 0.075, 0.3),
  easeOutElastic: (t5) => atEdge(t5) ? t5 : elasticOut(t5, 0.075, 0.3),
  easeInOutElastic(t5) {
    const s4 = 0.1125;
    const p4 = 0.45;
    return atEdge(t5) ? t5 : t5 < 0.5 ? 0.5 * elasticIn(t5 * 2, s4, p4) : 0.5 + 0.5 * elasticOut(t5 * 2 - 1, s4, p4);
  },
  easeInBack(t5) {
    const s4 = 1.70158;
    return t5 * t5 * ((s4 + 1) * t5 - s4);
  },
  easeOutBack(t5) {
    const s4 = 1.70158;
    return (t5 -= 1) * t5 * ((s4 + 1) * t5 + s4) + 1;
  },
  easeInOutBack(t5) {
    let s4 = 1.70158;
    if ((t5 /= 0.5) < 1) {
      return 0.5 * (t5 * t5 * (((s4 *= 1.525) + 1) * t5 - s4));
    }
    return 0.5 * ((t5 -= 2) * t5 * (((s4 *= 1.525) + 1) * t5 + s4) + 2);
  },
  easeInBounce: (t5) => 1 - effects.easeOutBounce(1 - t5),
  easeOutBounce(t5) {
    const m5 = 7.5625;
    const d3 = 2.75;
    if (t5 < 1 / d3) {
      return m5 * t5 * t5;
    }
    if (t5 < 2 / d3) {
      return m5 * (t5 -= 1.5 / d3) * t5 + 0.75;
    }
    if (t5 < 2.5 / d3) {
      return m5 * (t5 -= 2.25 / d3) * t5 + 0.9375;
    }
    return m5 * (t5 -= 2.625 / d3) * t5 + 0.984375;
  },
  easeInOutBounce: (t5) => t5 < 0.5 ? effects.easeInBounce(t5 * 2) * 0.5 : effects.easeOutBounce(t5 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v4) => v4 | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index4, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index4, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index4].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index4 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index4, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i4 = 0, n3 = keys.length; i4 < n3; ++i4) {
    const k4 = keys[i4];
    node = node[k4] || (node[k4] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache2) {
  cache2 = cache2 || {};
  let data = cache2.data = cache2.data || {};
  let gc = cache2.garbageCollect = cache2.garbageCollect || [];
  if (cache2.font !== font) {
    data = cache2.data = {};
    gc = cache2.garbageCollect = [];
    cache2.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i4, j5, jlen, thing, nestedThing;
  for (i4 = 0; i4 < ilen; i4++) {
    thing = arrayOfThings[i4];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j5 = 0, jlen = thing.length; j5 < jlen; j5++) {
        nestedThing = thing[j5];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i4 = 0; i4 < gcLen; i4++) {
      delete data[gc[i4]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x5, y4) {
  drawPointLegend(ctx, options, x5, y4, null);
}
function drawPointLegend(ctx, options, x5, y4, w5) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x5, y4);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    // Default includes circle
    default:
      if (w5) {
        ctx.ellipse(x5, y4, w5 / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x5, y4, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w5 ? w5 / 2 : radius;
      ctx.moveTo(x5 + Math.sin(rad) * width, y4 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x5 + Math.sin(rad) * width, y4 - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x5 + Math.sin(rad) * width, y4 - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w5 ? w5 / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w5 ? w5 / 2 - cornerRadius : size);
      ctx.arc(x5 - xOffsetW, y4 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x5 + yOffsetW, y4 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x5 + xOffsetW, y4 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x5 - yOffsetW, y4 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w5 ? w5 / 2 : size;
        ctx.rect(x5 - width, y4 - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    /* falls through */
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w5 ? w5 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w5 ? w5 / 2 : radius);
      ctx.moveTo(x5 - xOffsetW, y4 - yOffset);
      ctx.lineTo(x5 + yOffsetW, y4 - xOffset);
      ctx.lineTo(x5 + xOffsetW, y4 + yOffset);
      ctx.lineTo(x5 - yOffsetW, y4 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    /* falls through */
    case "cross":
      xOffsetW = Math.cos(rad) * (w5 ? w5 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w5 ? w5 / 2 : radius);
      ctx.moveTo(x5 - xOffsetW, y4 - yOffset);
      ctx.lineTo(x5 + xOffsetW, y4 + yOffset);
      ctx.moveTo(x5 + yOffsetW, y4 - xOffset);
      ctx.lineTo(x5 - yOffsetW, y4 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w5 ? w5 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w5 ? w5 / 2 : radius);
      ctx.moveTo(x5 - xOffsetW, y4 - yOffset);
      ctx.lineTo(x5 + xOffsetW, y4 + yOffset);
      ctx.moveTo(x5 + yOffsetW, y4 - xOffset);
      ctx.lineTo(x5 - yOffsetW, y4 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w5 ? w5 / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w5 ? w5 / 2 : radius);
      ctx.moveTo(x5 - xOffsetW, y4 - yOffset);
      ctx.lineTo(x5 + xOffsetW, y4 + yOffset);
      ctx.moveTo(x5 + yOffsetW, y4 - xOffset);
      ctx.lineTo(x5 - yOffsetW, y4 + xOffset);
      break;
    case "line":
      xOffset = w5 ? w5 / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x5 - xOffset, y4 - yOffset);
      ctx.lineTo(x5 + xOffset, y4 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x5, y4);
      ctx.lineTo(x5 + Math.cos(rad) * (w5 ? w5 / 2 : radius), y4 + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x5, y4, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x5 - metrics.actualBoundingBoxLeft;
    const right = x5 + metrics.actualBoundingBoxRight;
    const top = y4 - metrics.actualBoundingBoxAscent;
    const bottom = y4 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x5, y4, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i4, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i4 = 0; i4 < lines.length; ++i4) {
    line = lines[i4];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x5, y4, opts.maxWidth);
    }
    ctx.fillText(line, x5, y4, opts.maxWidth);
    decorateText(ctx, x5, y4, line, opts);
    y4 += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x: x5, y: y4, w: w5, h: h4, radius } = rect;
  ctx.arc(x5 + radius.topLeft, y4 + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x5, y4 + h4 - radius.bottomLeft);
  ctx.arc(x5 + radius.bottomLeft, y4 + h4 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x5 + w5 - radius.bottomRight, y4 + h4);
  ctx.arc(x5 + w5 - radius.bottomRight, y4 + h4 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x5 + w5, y4 + radius.topRight);
  ctx.arc(x5 + w5 - radius.topRight, y4 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x5 + radius.topLeft, y4);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches2 = ("" + value).match(LINE_HEIGHT);
  if (!matches2 || matches2[1] === "normal") {
    return size * 1.2;
  }
  value = +matches2[2];
  switch (matches2[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v4) => +v4 || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index4, info) {
  let cacheable = true;
  let i4, ilen, value;
  for (i4 = 0, ilen = inputs.length; i4 < ilen; ++i4) {
    value = inputs[i4];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index4 !== void 0 && isArray(value)) {
      value = value[index4 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext2(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache2 = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache2, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache2 = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache2, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s4) => s4 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k4) => !k4.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start4, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i4, ilen, index4, item;
  for (i4 = 0, ilen = count; i4 < ilen; ++i4) {
    index4 = i4 + start4;
    item = data[index4];
    parsed[i4] = {
      r: iScale.parse(resolveObjectKey(item, key), index4)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i4) => i4 < points.length && !points[i4].skip && points[i4];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t5) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t5 * s01;
  const fb = t5 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i4 = 0; i4 < pointsLen - 1; ++i4) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i4 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i4], 0, EPSILON)) {
      mK[i4] = mK[i4 + 1] = 0;
      continue;
    }
    alphaK = mK[i4] / deltaK[i4];
    betaK = mK[i4 + 1] / deltaK[i4];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i4] = alphaK * tauK * deltaK[i4];
    mK[i4 + 1] = betaK * tauK * deltaK[i4];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i4 = 0; i4 < pointsLen; ++i4) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i4 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i4];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i4];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i4, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i4 = 0; i4 < pointsLen; ++i4) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i4 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i4] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i4] = !pointBefore ? deltaK[i4] : !pointAfter ? deltaK[i4 - 1] : sign(deltaK[i4 - 1]) !== sign(deltaK[i4]) ? 0 : (deltaK[i4 - 1] + deltaK[i4]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt2, min, max) {
  return Math.max(Math.min(pt2, max), min);
}
function capBezierPoints(points, area) {
  let i4, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i4 = 0, ilen = points.length; i4 < ilen; ++i4) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i4 < ilen - 1 && _isPointInArea(points[i4 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i4];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i4, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt2) => !pt2.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i4 = 0, ilen = points.length; i4 < ilen; ++i4) {
      point = points[i4];
      controlPoints = splineCurve(prev, point, points[Math.min(i4 + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i4 = 0; i4 < 4; i4++) {
    const pos = positions[i4];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x5, y4, target) => (x5 > 0 || y4 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e4, canvas) {
  const touches = e4.touches;
  const source = touches && touches.length ? touches[0] : e4;
  const { offsetX, offsetY } = source;
  let box = false;
  let x5, y4;
  if (useOffsetPos(offsetX, offsetY, e4.target)) {
    x5 = offsetX;
    y4 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x5 = source.clientX - rect.left;
    y4 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x5,
    y: y4,
    box
  };
}
function getRelativePosition(event2, chart) {
  if ("native" in event2) {
    return event2;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x5, y: y4, box } = getCanvasPosition(event2, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x5 - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y4 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v4) => Math.round(v4 * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e4) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches2 = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches2 ? +matches2[1] : void 0;
}
function _pointInLine(p1, p22, t5, mode) {
  return {
    x: p1.x + t5 * (p22.x - p1.x),
    y: p1.y + t5 * (p22.y - p1.y)
  };
}
function _steppedInterpolation(p1, p22, t5, mode) {
  return {
    x: p1.x + t5 * (p22.x - p1.x),
    y: mode === "middle" ? t5 < 0.5 ? p1.y : p22.y : mode === "after" ? t5 < 1 ? p1.y : p22.y : t5 > 0 ? p22.y : p1.y
  };
}
function _bezierInterpolation(p1, p22, t5, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p22.cp1x,
    y: p22.cp1y
  };
  const a4 = _pointInLine(p1, cp1, t5);
  const b4 = _pointInLine(cp1, cp2, t5);
  const c4 = _pointInLine(cp2, p22, t5);
  const d3 = _pointInLine(a4, b4, t5);
  const e4 = _pointInLine(b4, c4, t5);
  return _pointInLine(d3, e4, t5);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x5) {
      return rectX + rectX + width - x5;
    },
    setWidth(w5) {
      width = w5;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x5, value) {
      return x5 - value;
    },
    leftForLtr(x5, itemWidth) {
      return x5 - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x5) {
      return x5;
    },
    setWidth(w5) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x5, value) {
      return x5 + value;
    },
    leftForLtr(x5, _itemWidth) {
      return x5;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a4, b4) => a4 - b4,
    normalize: (x5) => x5
  };
}
function normalizeSegment({ start: start4, end, count, loop, style }) {
  return {
    start: start4 % count,
    end: end % count,
    loop: loop && (end - start4 + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start: start4, end, loop } = segment;
  let i4, ilen;
  if (loop) {
    start4 += count;
    end += count;
    for (i4 = 0, ilen = count; i4 < ilen; ++i4) {
      if (!between(normalize(points[start4 % count][property]), startBound, endBound)) {
        break;
      }
      start4--;
      end--;
    }
    start4 %= count;
    end %= count;
  }
  if (end < start4) {
    end += count;
  }
  return {
    start: start4,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start: start4, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i4 = start4, prev = start4; i4 <= end; ++i4) {
    point = points[i4 % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i4 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i4,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i4;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i4 = 0; i4 < segments.length; i4++) {
    const sub = _boundSegment(segments[i4], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start4 = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start4 < count && !points[start4].skip) {
      start4++;
    }
  }
  while (start4 < count && points[start4].skip) {
    start4++;
  }
  start4 %= count;
  if (loop) {
    end += start4;
  }
  while (end > start4 && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start: start4,
    end
  };
}
function solidSegments(points, start4, max, loop) {
  const count = points.length;
  const result = [];
  let last = start4;
  let prev = points[start4];
  let end;
  for (end = start4 + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start4 % count,
          end: (end - 1) % count,
          loop
        });
        start4 = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start4 = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start4 % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start: start4, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start: start4,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start4 ? end + count : end;
  const completeLoop = !!line._fullLoop && start4 === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start4, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start4 = segments[0].start;
  let i4 = start4;
  function addStyle(s4, e4, l4, st2) {
    const dir = spanGaps ? -1 : 1;
    if (s4 === e4) {
      return;
    }
    s4 += count;
    while (points[s4 % count].skip) {
      s4 -= dir;
    }
    while (points[e4 % count].skip) {
      e4 += dir;
    }
    if (s4 % count !== e4 % count) {
      result.push({
        start: s4 % count,
        end: e4 % count,
        loop: l4,
        style: st2
      });
      prevStyle = st2;
      start4 = e4 % count;
    }
  }
  for (const segment of segments) {
    start4 = spanGaps ? start4 : segment.start;
    let prev = points[start4 % count];
    let style;
    for (i4 = start4 + 1; i4 <= segment.end; i4++) {
      const pt2 = points[i4 % count];
      style = readStyle(segmentOptions.setContext(createContext2(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt2,
        p0DataIndex: (i4 - 1) % count,
        p1DataIndex: i4 % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start4, i4 - 1, segment.loop, prevStyle);
      }
      prev = pt2;
      prevStyle = style;
    }
    if (start4 < i4 - 1) {
      addStyle(start4, i4 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache2 = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache2.includes(value)) {
      cache2.push(value);
    }
    return cache2.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn2) => fn2({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i4 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i4 >= 0; --i4) {
        item = items[i4];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i4] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event2, cb) {
    this._getAnims(chart).listeners[event2].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i4 = items.length - 1;
    for (; i4 >= 0; --i4) {
      items[i4].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to3, factor) {
    return factor > 0.5 ? to3 : from2;
  },
  color(from2, to3, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to3 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to3;
  },
  number(from2, to3, factor) {
    return from2 + (to3 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to3) {
    const currentValue = target[prop];
    to3 = resolve([
      cfg.to,
      to3,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to3
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to3;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to3, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to3,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to3
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to3 = this._to;
    let factor;
    this._active = from2 !== to3 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to3;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to3, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i4 = 0; i4 < promises.length; i4++) {
      promises[i4][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config3) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config3);
  }
  configure(config3) {
    if (!isObject(config3)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config3).forEach((key) => {
      const cfg = config3[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i4;
    for (i4 = props.length - 1; i4 >= 0; --i4) {
      const prop = props[i4];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i4 = 0; i4 < keys.length; i4++) {
    const anim = animations[keys[i4]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x5 = scaleClip(xScale, allowedOverflow);
  const y4 = scaleClip(yScale, allowedOverflow);
  return {
    top: y4.end,
    right: x5.end,
    bottom: y4.start,
    left: x5.start
  };
}
function toClip(value) {
  let t5, r4, b4, l4;
  if (isObject(value)) {
    t5 = value.top;
    r4 = value.right;
    b4 = value.bottom;
    l4 = value.left;
  } else {
    t5 = r4 = b4 = l4 = value;
  }
  return {
    top: t5,
    right: r4,
    bottom: b4,
    left: l4,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i4, ilen;
  for (i4 = 0, ilen = metasets.length; i4 < ilen; ++i4) {
    keys.push(metasets[i4].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i4, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i4 = 0, ilen = keys.length; i4 < ilen; ++i4) {
    datasetIndex = +keys[i4];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options.all) {
    return 0;
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i4, ilen, key;
  for (i4 = 0, ilen = keys.length; i4 < ilen; ++i4) {
    key = keys[i4];
    adata[i4] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i4 = 0; i4 < ilen; ++i4) {
    const item = parsed[i4];
    const { [iAxis]: index4, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index4);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index4) {
  return createContext2(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index4,
    index: index4,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index4, element) {
  return createContext2(parent, {
    active: false,
    dataIndex: index4,
    parsed: void 0,
    raw: void 0,
    element,
    index: index4,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x5, y4, r4) => axis === "x" ? x5 : axis === "r" ? r4 : y4;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config3 = this.chart.config;
    const scopeKeys = config3.datasetScopeKeys(this._type);
    const scopes = config3.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config3.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start4, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start4 === 0 && count === data.length ? true : meta._sorted;
    let prev = start4 > 0 && meta._parsed[start4 - 1];
    let i4, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start4])) {
        parsed = this.parseArrayData(meta, data, start4, count);
      } else if (isObject(data[start4])) {
        parsed = this.parseObjectData(meta, data, start4, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start4, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i4 = 0; i4 < count; ++i4) {
        meta._parsed[i4 + start4] = cur = parsed[i4];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start4, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i4, ilen, index4;
    for (i4 = 0, ilen = count; i4 < ilen; ++i4) {
      index4 = i4 + start4;
      parsed[i4] = {
        [iAxis]: singleScale || iScale.parse(labels[index4], index4),
        [vAxis]: vScale.parse(data[index4], index4)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start4, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i4, ilen, index4, item;
    for (i4 = 0, ilen = count; i4 < ilen; ++i4) {
      index4 = i4 + start4;
      item = data[index4];
      parsed[i4] = {
        x: xScale.parse(item[0], index4),
        y: yScale.parse(item[1], index4)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start4, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i4, ilen, index4, item;
    for (i4 = 0, ilen = count; i4 < ilen; ++i4) {
      index4 = i4 + start4;
      item = data[index4];
      parsed[i4] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index4),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index4)
      };
    }
    return parsed;
  }
  getParsed(index4) {
    return this._cachedMeta._parsed[index4];
  }
  getDataElement(index4) {
    return this._cachedMeta.data[index4];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i4, parsed;
    function _skip() {
      parsed = _parsed[i4];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i4 = 0; i4 < ilen; ++i4) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i4 = ilen - 1; i4 >= 0; --i4) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i4, ilen, value;
    for (i4 = 0, ilen = parsed.length; i4 < ilen; ++i4) {
      value = parsed[i4][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index4);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start4 = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start4;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i4;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start4, count);
    }
    for (i4 = start4; i4 < start4 + count; ++i4) {
      const element = elements2[i4];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i4 = 0; i4 < active.length; ++i4) {
      active[i4].draw(ctx, area);
    }
  }
  getStyle(index4, active) {
    const mode = active ? "active" : "default";
    return index4 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index4 || 0, mode);
  }
  getContext(index4, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index4 >= 0 && index4 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index4];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index4, element));
      context.parsed = this.getParsed(index4);
      context.raw = dataset.data[index4];
      context.index = context.dataIndex = index4;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index4, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index4);
  }
  _resolveElementOptions(elementType2, mode = "default", index4) {
    const active = mode === "active";
    const cache2 = this._cachedDataOpts;
    const cacheKey = elementType2 + "-" + mode;
    const cached = cache2[cacheKey];
    const sharing = this.enableOptionSharing && defined(index4);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config3 = this.chart.config;
    const scopeKeys = config3.datasetElementScopeKeys(this._type, elementType2);
    const prefixes = active ? [
      `${elementType2}Hover`,
      "hover",
      elementType2,
      ""
    ] : [
      elementType2,
      ""
    ];
    const scopes = config3.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType2]);
    const context = () => this.getContext(index4, active, mode);
    const values = config3.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index4, transition, active) {
    const chart = this.chart;
    const cache2 = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache2[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config3 = this.chart.config;
      const scopeKeys = config3.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config3.getOptionScopes(this.getDataset(), scopeKeys);
      options = config3.createResolver(scopes, this.getContext(index4, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache2[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start4, mode) {
    const firstOpts = this.resolveDataElementOptions(start4, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index4, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index4, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index4, mode, active) {
    element.active = active;
    const options = this.getStyle(index4, active);
    this._resolveAnimations(index4, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index4) {
    this._setStyle(element, index4, "active", false);
  }
  setHoverStyle(element, datasetIndex, index4) {
    this._setStyle(element, index4, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start4, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start4 + count;
    let i4;
    const move = (arr) => {
      arr.length += count;
      for (i4 = arr.length - 1; i4 >= end; i4--) {
        arr[i4] = arr[i4 - count];
      }
    };
    move(data);
    for (i4 = start4; i4 < end; ++i4) {
      data[i4] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start4, count);
    if (resetNewElements) {
      this.updateElements(data, start4, count, "reset");
    }
  }
  updateElements(element, start4, count, mode) {
  }
  _removeElements(start4, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start4, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start4, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start4, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start4,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start4,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i4 = 0, ilen = visibleMetas.length; i4 < ilen; i4++) {
      values = values.concat(visibleMetas[i4].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a4, b4) => a4 - b4));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i4, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i4 = 0, ilen = values.length; i4 < ilen; ++i4) {
    curr = scale.getPixelForValue(values[i4]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i4 = 0, ilen = scale.ticks.length; i4 < ilen; ++i4) {
    curr = scale.getPixelForTick(i4);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index4, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index4] - size / 2
  };
}
function computeFlexCategoryTraits(index4, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index4];
  let prev = index4 > 0 ? pixels[index4 - 1] : null;
  let next = index4 < pixels.length - 1 ? pixels[index4 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start4 = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start: start4
  };
}
function parseFloatBar(entry, item, vScale, i4) {
  const startValue = vScale.parse(entry[0], i4);
  const endValue = vScale.parse(entry[1], i4);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i4) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i4);
  } else {
    item[vScale.axis] = vScale.parse(entry, i4);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start4, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i4, ilen, item, entry;
  for (i4 = start4, ilen = start4 + count; i4 < ilen; ++i4) {
    entry = data[i4];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i4], i4);
    parsed.push(parseValue(entry, item, vScale, i4));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start4, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start4 = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start4 = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start: start4,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index4) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start: start4, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index4) {
      edge = top;
    } else if ((stack._bottom || 0) === index4) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start4, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start4, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a4, b4, reverse) {
  if (reverse) {
    edge = swap(edge, a4, b4);
    edge = startEnd(edge, b4, a4);
  } else {
    edge = startEnd(edge, a4, b4);
  }
  return edge;
}
function swap(orig, v1, v22) {
  return orig === v1 ? v22 : orig === v22 ? v1 : orig;
}
function startEnd(v4, start4, end) {
  return v4 === "start" ? start4 : v4 === "end" ? end : v4;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  static id = "bar";
  static defaults = {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  };
  parsePrimitiveData(meta, data, start4, count) {
    return parseArrayOrPrimitive(meta, data, start4, count);
  }
  parseArrayData(meta, data, start4, count) {
    return parseArrayOrPrimitive(meta, data, start4, count);
  }
  parseObjectData(meta, data, start4, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i4, ilen, item, obj;
    for (i4 = start4, ilen = start4 + count; i4 < ilen; ++i4) {
      obj = data[i4];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i4);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i4));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index4);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start4, count, mode) {
    const reset = mode === "reset";
    const { index: index4, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start4, mode);
    for (let i4 = start4; i4 < start4 + count; i4++) {
      const parsed = this.getParsed(i4);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i4);
      const ipixels = this._calculateBarIndexPixels(i4, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index4 === stack._top || index4 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i4, bars[i4].active ? "active" : mode);
      }
      const options = properties.options || bars[i4].options;
      setBorderSkipped(properties, options, stack, index4);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i4], i4, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = (meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index4) {
    return this._getStacks(void 0, index4).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index4 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index4 === -1 ? stacks.length - 1 : index4;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i4, ilen;
    for (i4 = 0, ilen = meta.data.length; i4 < ilen; ++i4) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i4)[iScale.axis], i4));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index4) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index4);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start4 = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start4 = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start4 = 0;
      }
      start4 += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start4;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index4)) {
      head = vScale.getPixelForValue(start4 + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index4, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index4) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index4, ruler, options, stackCount) : computeFitCategoryTraits(index4, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index4 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index4)[scale.axis], index4);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i4 = 0;
    for (; i4 < ilen; ++i4) {
      if (this.getParsed(i4)[vScale.axis] !== null && !rects[i4].hidden) {
        rects[i4].draw(this._ctx);
      }
    }
  }
};
var BubbleController = class extends DatasetController {
  static id = "bubble";
  static defaults = {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start4, count) {
    const parsed = super.parsePrimitiveData(meta, data, start4, count);
    for (let i4 = 0; i4 < parsed.length; i4++) {
      parsed[i4]._custom = this.resolveDataElementOptions(i4 + start4).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start4, count) {
    const parsed = super.parseArrayData(meta, data, start4, count);
    for (let i4 = 0; i4 < parsed.length; i4++) {
      const item = data[start4 + i4];
      parsed[i4]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i4 + start4).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start4, count) {
    const parsed = super.parseObjectData(meta, data, start4, count);
    for (let i4 = 0; i4 < parsed.length; i4++) {
      const item = data[start4 + i4];
      parsed[i4]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i4 + start4).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i4 = data.length - 1; i4 >= 0; --i4) {
      max = Math.max(max, data[i4].size(this.resolveDataElementOptions(i4)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index4);
    const x5 = xScale.getLabelForValue(parsed.x);
    const y4 = yScale.getLabelForValue(parsed.y);
    const r4 = parsed._custom;
    return {
      label: labels[index4] || "",
      value: "(" + x5 + ", " + y4 + (r4 ? ", " + r4 : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start4, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start4, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i4 = start4; i4 < start4 + count; i4++) {
      const point = points[i4];
      const parsed = !reset && this.getParsed(i4);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i4, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i4, properties, mode);
    }
  }
  resolveDataElementOptions(index4, mode) {
    const parsed = this.getParsed(index4);
    let values = super.resolveDataElementOptions(index4, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a4, b4) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a4, a4 * cutout, b4, b4 * cutout);
    const calcMin = (angle, a4, b4) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a4, a4 * cutout, b4, b4 * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  static id = "doughnut";
  static defaults = {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i4) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i4);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i4),
                  index: i4
                };
              });
            }
            return [];
          }
        },
        onClick(e4, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  };
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start4, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i5) => +data[i5];
      if (isObject(data[start4])) {
        const { key = "value" } = this._parsing;
        getter = (i5) => +resolveObjectKey(data[i5], key);
      }
      let i4, ilen;
      for (i4 = start4, ilen = start4 + count; i4 < ilen; ++i4) {
        meta._parsed[i4] = getter(i4);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i4 = 0; i4 < this.chart.data.datasets.length; ++i4) {
      if (this.chart.isDatasetVisible(i4) && this.chart.getDatasetMeta(i4).type === this._type) {
        const controller = this.chart.getDatasetMeta(i4).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i4, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i4) || meta._parsed[i4] === null || meta.data[i4].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i4] * circumference / TAU);
  }
  updateElements(arcs, start4, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start4, mode);
    let startAngle = this._getRotation();
    let i4;
    for (i4 = 0; i4 < start4; ++i4) {
      startAngle += this._circumference(i4, reset);
    }
    for (i4 = start4; i4 < start4 + count; ++i4) {
      const circumference = this._circumference(i4, reset);
      const arc = arcs[i4];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i4, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i4, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total2 = 0;
    let i4;
    for (i4 = 0; i4 < metaData.length; i4++) {
      const value = meta._parsed[i4];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i4) && !metaData[i4].hidden) {
        total2 += Math.abs(value);
      }
    }
    return total2;
  }
  calculateCircumference(value) {
    const total2 = this._cachedMeta.total;
    if (total2 > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total2);
    }
    return 0;
  }
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index4], chart.options.locale);
    return {
      label: labels[index4] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i4, ilen, meta, controller, options;
    if (!arcs) {
      for (i4 = 0, ilen = chart.data.datasets.length; i4 < ilen; ++i4) {
        if (chart.isDatasetVisible(i4)) {
          meta = chart.getDatasetMeta(i4);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i4 = 0, ilen = arcs.length; i4 < ilen; ++i4) {
      options = controller.resolveDataElementOptions(i4);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i4 = 0, ilen = arcs.length; i4 < ilen; ++i4) {
      const options = this.resolveDataElementOptions(i4);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i4 = 0; i4 < datasetIndex; ++i4) {
      if (this.chart.isDatasetVisible(i4)) {
        ringWeightOffset += this._getRingWeight(i4);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
var LineController = class extends DatasetController {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start4, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start4;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start4 = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start4, count, mode);
  }
  updateElements(points, start4, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start4, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start4 + count;
    const pointsCount = points.length;
    let prevParsed = start4 > 0 && this.getParsed(start4 - 1);
    for (let i4 = 0; i4 < pointsCount; ++i4) {
      const point = points[i4];
      const properties = directUpdate ? point : {};
      if (i4 < start4 || i4 >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i4);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i4);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i4);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i4 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i4];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i4, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i4, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
var PolarAreaController = class extends DatasetController {
  static id = "polarArea";
  static defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i4) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i4);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i4),
                  index: i4
                };
              });
            }
            return [];
          }
        },
        onClick(e4, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index4].r, chart.options.locale);
    return {
      label: labels[index4] || "",
      value
    };
  }
  parseObjectData(meta, data, start4, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start4, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index4) => {
      const parsed = this.getParsed(index4).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index4)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start4, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i4;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i4 = 0; i4 < start4; ++i4) {
      angle += this._computeAngle(i4, mode, defaultAngle);
    }
    for (i4 = start4; i4 < start4 + count; i4++) {
      const arc = arcs[i4];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i4, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i4) ? scale.getDistanceFromCenterForValue(this.getParsed(i4).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i4, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i4, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index4) => {
      if (!isNaN(this.getParsed(index4).r) && this.chart.getDataVisibility(index4)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index4, mode, defaultAngle) {
    return this.chart.getDataVisibility(index4) ? toRadians(this.resolveDataElementOptions(index4, mode).angle || defaultAngle) : 0;
  }
};
var PieController = class extends DoughnutController {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
};
var RadarController = class extends DatasetController {
  static id = "radar";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  };
  static overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  getLabelAndValue(index4) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index4);
    return {
      label: vScale.getLabels()[index4],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start4, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start4, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start4, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i4 = start4; i4 < start4 + count; i4++) {
      const point = points[i4];
      const options = this.resolveDataElementOptions(i4, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i4, this.getParsed(i4).r);
      const x5 = reset ? scale.xCenter : pointPosition.x;
      const y4 = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x: x5,
        y: y4,
        angle: pointPosition.angle,
        skip: isNaN(x5) || isNaN(y4),
        options
      };
      this.updateElement(point, i4, properties, mode);
    }
  }
};
var ScatterController = class extends DatasetController {
  static id = "scatter";
  static defaults = {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  };
  static overrides = {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  getLabelAndValue(index4) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index4);
    const x5 = xScale.getLabelForValue(parsed.x);
    const y4 = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index4] || "",
      value: "(" + x5 + ", " + y4 + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start4, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start4;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start4 = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start4, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start4, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start4, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start4 > 0 && this.getParsed(start4 - 1);
    for (let i4 = start4; i4 < start4 + count; ++i4) {
      const point = points[i4];
      const parsed = this.getParsed(i4);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i4);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i4);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i4 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i4];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i4, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i4, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i4 = data.length - 1; i4 >= 0; --i4) {
        max = Math.max(max, data[i4].size(this.resolveDataElementOptions(i4)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class _DateAdapterBase {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  options;
  constructor(options) {
    this.options = options || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch2(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start4 = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start4.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i4 = 0, ilen = metasets.length; i4 < ilen; ++i4) {
    const { index: index4, data } = metasets[i4];
    const { lo, hi: hi2 } = binarySearch2(metasets[i4], axis, value, intersect);
    for (let j5 = lo; j5 <= hi2; ++j5) {
      const element = data[j5];
      if (!element.skip) {
        handler(element, index4, j5);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index4) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index4
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index4) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index4
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index4) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index4
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index4
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index4) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index4
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction2 = {
  evaluateInteractionItems,
  modes: {
    index(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index4 = items[0].index;
        const element = meta.data[index4];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index4
          });
        }
      });
      return elements2;
    },
    dataset(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i4 = 0; i4 < data.length; ++i4) {
          items.push({
            element: data[i4],
            datasetIndex,
            index: i4
          });
        }
      }
      return items;
    },
    point(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e4, options, useFinalPosition) {
      const position = getRelativePosition(e4, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v4) => v4.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v4) => STATIC_POSITIONS.indexOf(v4.pos) === -1 && v4.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a4, b4) => {
    const v0 = reverse ? b4 : a4;
    const v1 = reverse ? a4 : b4;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i4, ilen, box, pos, stack, stackWeight;
  for (i4 = 0, ilen = (boxes || []).length; i4 < ilen; ++i4) {
    box = boxes[i4];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i4,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i4, ilen, layout;
  for (i4 = 0, ilen = layouts2.length; i4 < ilen; ++i4) {
    layout = layouts2[i4];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a4, b4) {
  return Math.max(maxPadding[a4], chartArea[a4]) + Math.max(maxPadding[b4], chartArea[b4]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i4, ilen, layout, box, refit, changed;
  for (i4 = 0, ilen = boxes.length, refit = 0; i4 < ilen; ++i4) {
    layout = boxes[i4];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x5, y: y4 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y4 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y4, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y4, width, height);
      }
      stack.start = y4;
      stack.placed += width;
      y4 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x5 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x5, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x5, chartArea.top + stack.placed, width, height);
      }
      stack.start = x5;
      stack.placed += height;
      x5 = box.right;
    }
  }
  chartArea.x = x5;
  chartArea.y = y4;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index4 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index4 !== -1) {
      chart.boxes.splice(index4, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total2, wrap) => wrap.box.options && wrap.box.options.display === false ? total2 : total2 + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config3) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config3) {
    config3.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event2, chart) {
  const type = EVENT_TYPES[event2.type] || event2.type;
  const { x: x5, y: y4 } = getRelativePosition(event2, chart);
  return {
    type,
    chart,
    native: event2,
    x: x5 !== void 0 ? x5 : null,
    y: y4 !== void 0 ? y4 : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w5 = container.clientWidth;
    listener(width, height);
    if (w5 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event2) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event2, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element2 = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = false;
  options;
  $animations;
  tooltipPosition(useFinalPosition) {
    const { x: x5, y: y4 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x5,
      y: y4
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i4, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i4 = 0, ilen = numMajorIndices - 1; i4 < ilen; i4++) {
      skip(ticks, newTicks, spacing, majorIndices[i4], majorIndices[i4 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i4 = 0, ilen = factors.length - 1; i4 < ilen; i4++) {
    const factor = factors[i4];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i4, ilen;
  for (i4 = 0, ilen = ticks.length; i4 < ilen; i4++) {
    if (ticks[i4].major) {
      result.push(i4);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i4;
  spacing = Math.ceil(spacing);
  for (i4 = 0; i4 < ticks.length; i4++) {
    if (i4 === next) {
      newTicks.push(ticks[i4]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start4 = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i4, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start4;
  while (next < 0) {
    count++;
    next = Math.round(start4 + count * spacing);
  }
  for (i4 = Math.max(start4, 0); i4 < end; i4++) {
    if (i4 === next) {
      newTicks.push(ticks[i4]);
      count++;
      next = Math.round(start4 + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i4, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i4 = 1; i4 < len; ++i4) {
    if (arr[i4] - arr[i4 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i4 = 0;
  for (; i4 < len; i4 += increment) {
    result.push(arr[Math.floor(i4)]);
  }
  return result;
}
function getPixelForGridLine(scale, index4, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index4, length - 1);
  const start4 = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start4, end - lineValue);
    } else if (index4 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index4 ? offset : -offset;
    if (lineValue < start4 - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache2) => {
    const gc = cache2.gc;
    const gcLen = gc.length / 2;
    let i4;
    if (gcLen > length) {
      for (i4 = 0; i4 < gcLen; ++i4) {
        delete cache2.data[gc[i4]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext2(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index4, tick) {
  return createContext2(parent, {
    tick,
    index: index4,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class _Scale extends Element2 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index4) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i4 = 0, ilen = metas.length; i4 < ilen; ++i4) {
      range = metas[i4].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i4, ilen, tick;
    for (i4 = 0, ilen = ticks.length; i4 < ilen; i4++) {
      tick = ticks[i4];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i4,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i4, ilen;
    for (i4 = 0, ilen = ticks.length; i4 < ilen; i4++) {
      if (isNullOrUndef(ticks[i4].label)) {
        ticks.splice(i4, 1);
        ilen--;
        i4--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i4, j5, jlen, label, tickFont, fontString, cache2, lineHeight, width, height, nestedLabel;
    for (i4 = 0; i4 < length; i4 += increment) {
      label = ticks[i4].label;
      tickFont = this._resolveTickFontOptions(i4);
      ctx.font = fontString = tickFont.string;
      cache2 = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache2.data, cache2.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j5 = 0, jlen = label.length; j5 < jlen; ++j5) {
          nestedLabel = label[j5];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache2.data, cache2.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index4) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index4) {
    const ticks = this.ticks;
    if (index4 < 0 || index4 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index4].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index4) {
    const ticks = this.ticks || [];
    if (index4 >= 0 && index4 < ticks.length) {
      const tick = ticks[index4];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index4, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w5 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h4 * cos > w5 * sin ? w5 / cos : h4 / sin : h4 * sin < w5 * cos ? h4 / cos : w5 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i4, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x22, y22;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y22 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x22 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x22 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y22 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x22 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i4 = 0; i4 < ticksLength; i4 += step) {
      const context = this.getContext(i4);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i4, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x22 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y22 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2: x22,
        y2: y22,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i4, ilen, tick, label, x5, y4, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y4 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y4 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x5 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x5 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y4 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y4 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x5 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x5 = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i4 = 0, ilen = ticks.length; i4 < ilen; ++i4) {
      tick = ticks[i4];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i4));
      pixel = this.getPixelForTick(i4) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i4);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x5 = pixel;
        if (textAlign === "inner") {
          if (i4 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i4 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x5 += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y4 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i4];
        const width = labelSizes.widths[i4];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i4 === ilen - 1) {
              left -= width;
            } else if (i4 > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x5,
            y4
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x5;
    if (position === "left") {
      if (mirror) {
        x5 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x5 += widest / 2;
        } else {
          textAlign = "right";
          x5 += widest;
        }
      } else {
        x5 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x5 -= widest / 2;
        } else {
          textAlign = "left";
          x5 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x5 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x5 -= widest / 2;
        } else {
          textAlign = "left";
          x5 -= widest;
        }
      } else {
        x5 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x5 += widest / 2;
        } else {
          textAlign = "right";
          x5 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x5
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index4 = ticks.findIndex((t5) => t5.value === value);
    if (index4 >= 0) {
      const opts = grid.setContext(this.getContext(index4));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i4, ilen;
    const drawLine = (p1, p22, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p22.x, p22.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i4 = 0, ilen = items.length; i4 < ilen; ++i4) {
        const item = items[i4];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x22, y1, y22;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x22 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y22 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x22 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x22, y22);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y4 = item.textOffset;
      renderText(ctx, label, 0, y4, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i4, ilen;
    for (i4 = 0, ilen = metas.length; i4 < ilen; ++i4) {
      const meta = metas[i4];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index4) {
    const opts = this.options.ticks.setContext(this.getContext(index4));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope + "." + id2;
    if (!id2) {
      throw new Error("class does not have id: " + item);
    }
    if (id2 in items) {
      return scope;
    }
    items[id2] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id2) {
    return this.items[id2];
  }
  unregister(item) {
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope;
    if (id2 in items) {
      delete items[id2];
    }
    if (scope && id2 in defaults[scope]) {
      delete defaults[scope][id2];
      if (this.override) {
        delete overrides[id2];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element2, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id2) {
    return this._get(id2, this.controllers, "controller");
  }
  getElement(id2) {
    return this._get(id2, this.elements, "element");
  }
  getPlugin(id2) {
    return this._get(id2, this.plugins, "plugin");
  }
  getScale(id2) {
    return this._get(id2, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i4 = 0; i4 < this._typedRegistries.length; i4++) {
      const reg = this._typedRegistries[i4];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id2, typedRegistry, type) {
    const item = typedRegistry.get(id2);
    if (item === void 0) {
      throw new Error('"' + id2 + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config3 = chart && chart.config;
    const options = valueOrDefault(config3.options && config3.options.plugins, {});
    const plugins2 = allPlugins(config3);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a4, b4) => a4.filter((x5) => !b4.some((y4) => x5.plugin.id === y4.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config3) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i4 = 0; i4 < keys.length; i4++) {
    plugins2.push(registry.getPlugin(keys[i4]));
  }
  const local = config3.plugins || [];
  for (let i4 = 0; i4 < local.length; i4++) {
    const plugin = local[i4];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id2 = plugin.id;
    const opts = getOpts(options[id2], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id2]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config3, { plugin, local }, opts, context) {
  const keys = config3.pluginScopeKeys(plugin);
  const scopes = config3.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config3.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id2, indexAxis) {
  let axis = id2;
  if (id2 === "_index_") {
    axis = indexAxis;
  } else if (id2 === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id2) {
  if (id2 === "x" || id2 === "y" || id2 === "r") {
    return id2;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id2, ...scaleOptions) {
  if (idMatchesAxis(id2)) {
    return id2;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id2.length > 1 && idMatchesAxis(id2[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id2}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id2, axis, dataset) {
  if (dataset[axis + "AxisID"] === id2) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id2, config3) {
  if (config3.data && config3.data.datasets) {
    const boundDs = config3.data.datasets.filter((d3) => d3.xAxisID === id2 || d3.yAxisID === id2);
    if (boundDs.length) {
      return getAxisFromDataset(id2, "x", boundDs[0]) || getAxisFromDataset(id2, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config3, options) {
  const chartDefaults = overrides[config3.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config3.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id2) => {
    const scaleConf = configScales[id2];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id2}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
    }
    const axis = determineAxis(id2, scaleConf, retrieveAxisFromDatasets(id2, config3), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id2] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config3.data.datasets.forEach((dataset) => {
    const type = dataset.type || config3.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id2 = dataset[axis + "AxisID"] || axis;
      scales2[id2] = scales2[id2] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id2], [
        {
          axis
        },
        configScales[id2],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config3) {
  const options = config3.options || (config3.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config3, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config3) {
  config3 = config3 || {};
  config3.data = initData(config3.data);
  initOptions(config3);
  return config3;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config2 = class {
  constructor(config3) {
    this._config = initConfig(config3);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config3 = this._config;
    this.clearCache();
    initOptions(config3);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType2) {
    return cachedKeys(`${datasetType}-${elementType2}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType2}`,
        `datasets.${datasetType}`,
        `elements.${elementType2}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id2 = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id2}`, () => [
      [
        `plugins.${id2}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache2 = _scopeCache.get(mainScope);
    if (!cache2 || resetCache) {
      cache2 = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache2);
    }
    return cache2;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache2 = this._cachedScopes(mainScope, resetCache);
    const cached = cache2.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache2.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache2 = resolverCache.get(scopes);
  if (!cache2) {
    cache2 = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache2);
  }
  const cacheKey = prefixes.join();
  let cached = cache2.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p4) => !p4.toLowerCase().includes("hover"))
    };
    cache2.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.6";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l22) {
  return function(a4, b4) {
    return a4[l1] === b4[l1] ? a4[l22] - b4[l22] : a4[l1] - b4[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c4) => c4.canvas === canvas).pop();
};
function moveNumericKeys(obj, start4, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start4) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start4) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e4, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e4.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e4;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static defaults = defaults;
  static instances = instances;
  static overrides = overrides;
  static registry = registry;
  static version = version;
  static getChart = getChart;
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config3 = this.config = new Config2(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config3.createResolver(config3.chartOptionScopes(), this.getContext());
    this.platform = new (config3.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config3);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce2((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id2) => {
      obj[id2] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id2) => {
        const scaleOptions = scaleOpts[id2];
        const axis = determineAxis(id2, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id2 = scaleOptions.id;
      const axis = determineAxis(id2, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id2] = true;
      let scale = null;
      if (id2 in scales2 && scales2[id2].type === scaleType) {
        scale = scales2[id2];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id: id2,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id2) => {
      if (!hasUpdated) {
        delete scales2[id2];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a4, b4) => a4.index - b4.index);
    if (numMeta > numData) {
      for (let i4 = numData; i4 < numMeta; ++i4) {
        this._destroyDatasetMeta(i4);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index4) => {
      if (datasets.filter((x5) => x5 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index4);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i4, ilen;
    this._removeUnreferencedMetasets();
    for (i4 = 0, ilen = datasets.length; i4 < ilen; i4++) {
      const dataset = datasets[i4];
      let meta = this.getDatasetMeta(i4);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i4);
        meta = this.getDatasetMeta(i4);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i4;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i4);
      if (meta.controller) {
        meta.controller.updateIndex(i4);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i4);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config3 = this.config;
    config3.update();
    const options = this._options = config3.createResolver(config3.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i4 = 0, ilen = this.data.datasets.length; i4 < ilen; i4++) {
      const { controller } = this.getDatasetMeta(i4);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start: start4, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start4, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c4) => c4[0] === idx).map((c4, i4) => i4 + "," + c4.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i4 = 1; i4 < datasetCount; i4++) {
      if (!setsEqual(changeSet, makeSet(i4))) {
        return;
      }
    }
    return Array.from(changeSet).map((c4) => c4.split(",")).map((a4) => ({
      method: a4[1],
      start: +a4[2],
      count: +a4[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index4) => {
      item._idx = index4;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i4 = 0, ilen = this.data.datasets.length; i4 < ilen; ++i4) {
      this.getDatasetMeta(i4).controller.configure();
    }
    for (let i4 = 0, ilen = this.data.datasets.length; i4 < ilen; ++i4) {
      this._updateDataset(i4, isFunction(mode) ? mode({
        datasetIndex: i4
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index4, mode) {
    const meta = this.getDatasetMeta(index4);
    const args = {
      meta,
      index: index4,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i4;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i4 = 0; i4 < layers.length && layers[i4].z <= 0; ++i4) {
      layers[i4].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i4 < layers.length; ++i4) {
      layers[i4].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i4, ilen;
    for (i4 = 0, ilen = metasets.length; i4 < ilen; ++i4) {
      const meta = metasets[i4];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i4 = metasets.length - 1; i4 >= 0; --i4) {
      this._drawDataset(metasets[i4]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e4, mode, options, useFinalPosition) {
    const method = Interaction2.modes[mode];
    if (typeof method === "function") {
      return method(this, e4, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x5) => x5 && x5._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext2(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index4) {
    this._hiddenIndices[index4] = !this._hiddenIndices[index4];
  }
  getDataVisibility(index4) {
    return !this._hiddenIndices[index4];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i4, ilen;
    this.stop();
    animator.remove(this);
    for (i4 = 0, ilen = this.data.datasets.length; i4 < ilen; ++i4) {
      this._destroyDatasetMeta(i4);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e4, x5, y4) => {
      e4.offsetX = x5;
      e4.offsetY = y4;
      this._eventHandler(e4);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i4, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i4 = 0, ilen = items.length; i4 < ilen; ++i4) {
      item = items[i4];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index4 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index4],
        index: index4
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p4) => p4.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a4, b4) => a4.filter((x5) => !b4.some((y4) => x5.datasetIndex === y4.datasetIndex && x5.index === y4.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e4, replay) {
    const args = {
      event: e4,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e4)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e4.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e4, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e4, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e4, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e4);
    const lastEvent = determineLastEvent(e4, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e4,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e4,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e4, lastActive, inChartArea, useFinalPosition) {
    if (e4.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e4, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x: x5, y: y4, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x5, y4, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x5, y4, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x5, y4, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o3 = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o3.outerStart),
    outerEnd: computeOuterLimit(o3.outerEnd),
    innerStart: _limitValue(o3.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o3.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r4, theta, x5, y4) {
  return {
    x: x5 + r4 * Math.cos(theta),
    y: y4 + r4 * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x: x5, y: y4, startAngle: start4, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start4;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start4 + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x5, y4, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x5, y4, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x5, y4);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x5, y4);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x5, y4);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x5, y4, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x5, y4, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x5, y4);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x5, y4);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x5, y4);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x5, y4);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x5;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y4;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x5;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y4;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i4 = 0; i4 < fullCircles; ++i4) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i4 = 0; i4 < fullCircles; ++i4) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element2 {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x5, y: y4, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x5 + Math.cos(halfAngle) * halfRadius,
      y: y4 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start4 = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start: start4,
    loop: segment.loop,
    ilen: end < start4 && !outside ? count + end - start4 : end - start4
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start: start4, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i4, point, prev;
  for (i4 = 0; i4 <= ilen; ++i4) {
    point = points[(start4 + (reverse ? ilen - i4 : i4)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start4 + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start: start4, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i4, point, prevX, minY, maxY, lastY;
  const pointIndex = (index4) => (start4 + (reverse ? ilen - index4 : index4)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i4 = 0; i4 <= ilen; ++i4) {
    point = points[pointIndex(i4)];
    if (point.skip) {
      continue;
    }
    const x5 = point.x;
    const y4 = point.y;
    const truncX = x5 | 0;
    if (truncX === prevX) {
      if (y4 < minY) {
        minY = y4;
      } else if (y4 > maxY) {
        maxY = y4;
      }
      avgX = (countX * avgX + x5) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x5, y4);
      prevX = truncX;
      countX = 0;
      minY = maxY = y4;
    }
    lastY = y4;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start4, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start4, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start4, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start: start4,
      end: start4 + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start4, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start4, count);
  } else {
    strokePathDirect(ctx, line, start4, count);
  }
}
var LineElement = class extends Element2 {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  };
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i4, ilen;
    for (i4 = 0, ilen = segments.length; i4 < ilen; ++i4) {
      const { start: start4, end } = segments[i4];
      const p1 = points[start4];
      const p22 = points[end];
      if (p1 === p22) {
        result.push(p1);
        continue;
      }
      const t5 = Math.abs((value - p1[property]) / (p22[property] - p1[property]));
      const interpolated = _interpolate(p1, p22, t5, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start4, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start4 = start4 || 0;
    count = count || this.points.length - start4;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start: start4,
        end: start4 + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start4, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start4, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element2 {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x5, y: y4 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x5, 2) + Math.pow(mouseY - y4, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x5, y: y4 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x5,
      y: y4
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
function getBarBounds(bar, useFinalPosition) {
  const { x: x5, y: y4, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x5, base);
    right = Math.max(x5, base);
    top = y4 - half;
    bottom = y4 + half;
  } else {
    half = width / 2;
    left = x5 - half;
    right = x5 + half;
    top = Math.min(y4, base);
    bottom = Math.max(y4, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o3 = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o3.top, 0, maxH),
    r: skipOrLimit(skip2.right, o3.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o3.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o3.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o3 = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o3.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o3.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o3.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o3.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x5, y4, useFinalPosition) {
  const skipX = x5 === null;
  const skipY = y4 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x5, bounds.left, bounds.right)) && (skipY || _isBetween(y4, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x5 = rect.x !== refRect.x ? -amount : 0;
  const y4 = rect.y !== refRect.y ? -amount : 0;
  const w5 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x5;
  const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y4;
  return {
    x: rect.x + x5,
    y: rect.y + y4,
    w: rect.w + w5,
    h: rect.h + h4,
    radius: rect.radius
  };
}
var BarElement = class extends Element2 {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x5, y: y4, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x5 + base) / 2 : x5,
      y: horizontal ? y4 : (y4 + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i4) {
  return BORDER_COLORS[i4 % BORDER_COLORS.length];
}
function getBackgroundColor(i4) {
  return BACKGROUND_COLORS[i4 % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i4) {
  dataset.borderColor = getBorderColor(i4);
  dataset.backgroundColor = getBackgroundColor(i4);
  return ++i4;
}
function colorizeDoughnutDataset(dataset, i4) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i4++));
  return i4;
}
function colorizePolarAreaDataset(dataset, i4) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i4++));
  return i4;
}
function getColorizer(chart) {
  let i4 = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i4 = colorizeDoughnutDataset(dataset, i4);
    } else if (controller instanceof PolarAreaController) {
      i4 = colorizePolarAreaDataset(dataset, i4);
    } else if (controller) {
      i4 = colorizeDefaultDataset(dataset, i4);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k4;
  for (k4 in descriptors2) {
    if (descriptors2[k4].borderColor || descriptors2[k4].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
  return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
    if (!options.forceOverride && containsColorDefenition) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start4, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start4, start4 + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start4 + count - 1;
  let a4 = start4;
  let i4, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a4];
  for (i4 = 0; i4 < samples - 2; i4++) {
    let avgX = 0;
    let avgY = 0;
    let j5;
    const avgRangeStart = Math.floor((i4 + 1) * bucketWidth) + 1 + start4;
    const avgRangeEnd = Math.min(Math.floor((i4 + 2) * bucketWidth) + 1, count) + start4;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j5 = avgRangeStart; j5 < avgRangeEnd; j5++) {
      avgX += data[j5].x;
      avgY += data[j5].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i4 * bucketWidth) + 1 + start4;
    const rangeTo = Math.min(Math.floor((i4 + 1) * bucketWidth) + 1, count) + start4;
    const { x: pointAx, y: pointAy } = data[a4];
    maxArea = area = -1;
    for (j5 = rangeOffs; j5 < rangeTo; j5++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j5].y - pointAy) - (pointAx - data[j5].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j5];
        nextA = j5;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a4 = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start4, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i4, point, x5, y4, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start4 + count - 1;
  const xMin = data[start4].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i4 = start4; i4 < start4 + count; ++i4) {
    point = data[i4];
    x5 = (point.x - xMin) / dx * availableWidth;
    y4 = point.y;
    const truncX = x5 | 0;
    if (truncX === prevX) {
      if (y4 < minY) {
        minY = y4;
        minIndex = i4;
      } else if (y4 > maxY) {
        maxY = y4;
        maxIndex = i4;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i4 - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i4 > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y4;
      minIndex = maxIndex = startIndex = i4;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start4 = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start4 = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start4, pointCount) - start4;
  } else {
    count = pointCount - start4;
  }
  return {
    start: start4,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start: start4, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d3) {
            this._data = d3;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start4, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start4, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start: start4, end } = segment;
    end = _findSegmentEnd(start4, end, points);
    const bounds = _getBounds(property, points[start4], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start4],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start4 = first[property];
  let end = last[property];
  if (property === "angle") {
    start4 = _normalizeAngle(start4);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start: start4,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x: x5 = null, y: y4 = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start: start4, end }) => {
    end = _findSegmentEnd(start4, end, linePoints);
    const first = linePoints[start4];
    const last = linePoints[end];
    if (y4 !== null) {
      points.push({
        x: first.x,
        y: y4
      });
      points.push({
        x: last.x,
        y: y4
      });
    } else if (x5 !== null) {
      points.push({
        x: x5,
        y: first.y
      });
      points.push({
        x: x5,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start4, end, points) {
  for (; end > start4; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a4, b4, prop, fn2) {
  if (a4 && b4) {
    return fn2(a4[prop], b4[prop]);
  }
  return a4 ? a4[prop] : b4 ? b4[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index4, propagate) {
  const source = sources[index4];
  let fill2 = source.fill;
  const visited = [
    index4
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index4, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index4, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index4, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index4 + target;
  }
  if (target === index4 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index4, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index4);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i4 = 0; i4 < segments.length; i4++) {
    const segment = segments[i4];
    for (let j5 = segment.start; j5 <= segment.end; j5++) {
      addPointsBelow(points, sourcePoints[j5], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index4) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i4 = 0; i4 < metas.length; i4++) {
    const meta = metas[i4];
    if (meta.index === index4) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j5 = 0; j5 < linesBelow.length; j5++) {
    const line = linesBelow[j5];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i4 = 0; i4 < segments.length; i4++) {
    const segment = segments[i4];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x: x5, y: y4, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x5, y4, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x: x5, y: y4, radius } = this;
    const angle = point.angle;
    return {
      x: x5 + Math.cos(angle) * radius,
      y: y4 + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index4) {
  const meta = chart.getDatasetMeta(index4);
  const visible = meta && chart.isDatasetVisible(index4);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start4 = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start4);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start4);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i4 = 0; i4 < length; ++i4) {
    target.push(scale.getPointPositionForValue(i4, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start: start4, end } = segment;
    const firstPoint = points[start4];
    const lastPoint = points[_findSegmentEnd(start4, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start: start4, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start4, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start4, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start: start4, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start4, top, end - start4, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index3 = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i4, line, source;
    for (i4 = 0; i4 < count; ++i4) {
      meta = chart.getDatasetMeta(i4);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i4),
          index: i4,
          fill: _decodeFill(line, i4, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i4 = 0; i4 < count; ++i4) {
      source = sources[i4];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i4, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i4 = metasets.length - 1; i4 >= 0; --i4) {
      const source = metasets[i4].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i4 = metasets.length - 1; i4 >= 0; --i4) {
      const source = metasets[i4].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a4, b4) => a4 !== null && b4 !== null && a4.datasetIndex === b4.datasetIndex && a4.index === b4.index;
var Legend = class extends Element2 {
  constructor(config3) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config3.chart;
    this.options = config3.options;
    this.ctx = config3.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a4, b4) => labelOpts.sort(a4, b4, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i4) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i4 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i4 > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i4] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i4) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i4 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i4] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x5, y4, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x5, boxWidth / 2);
        const centerY = y4 + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y4 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x5, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x5, y4, legendItem) {
      renderText(ctx, legendItem.text, x5, y4 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i4) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x5 = cursor.x;
      let y4 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i4 > 0 && x5 + width + padding > this.right) {
          y4 = cursor.y += lineHeight;
          cursor.line++;
          x5 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i4 > 0 && y4 + lineHeight > this.bottom) {
        x5 = cursor.x = x5 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y4 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x5);
      drawLegendBox(realX, y4, legendItem);
      x5 = _textX(textAlign, x5 + boxWidth + halfFontSize, isHorizontal ? x5 + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x5), y4, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y4;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y4 = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y4 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x5 = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x5, y4, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x5, y4) {
    let i4, hitBox, lh;
    if (_isBetween(x5, this.left, this.right) && _isBetween(y4, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i4 = 0; i4 < lh.length; ++i4) {
        hitBox = lh[i4];
        if (_isBetween(x5, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y4, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i4];
        }
      }
    }
    return null;
  }
  handleEvent(e4) {
    const opts = this.options;
    if (!isListened(e4.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e4.x, e4.y);
    if (e4.type === "mousemove" || e4.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e4,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e4,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e4,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a4, b4) => a4.length > b4.length ? a4 : b4);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e4, legendItem, legend) {
      const index4 = legendItem.datasetIndex;
      const ci2 = legend.chart;
      if (ci2.isDatasetVisible(index4)) {
        ci2.hide(index4);
        legendItem.hidden = true;
      } else {
        ci2.show(index4);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element2 {
  constructor(config3) {
    super();
    this.chart = config3.chart;
    this.options = config3.options;
    this.ctx = config3.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i4, len;
    let xSet = /* @__PURE__ */ new Set();
    let y4 = 0;
    let count = 0;
    for (i4 = 0, len = items.length; i4 < len; ++i4) {
      const el = items[i4].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y4 += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a4, b4) => a4 + b4) / xSet.size;
    return {
      x: xAverage,
      y: y4 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x5 = eventPosition.x;
    let y4 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i4, len, nearestElement;
    for (i4 = 0, len = items.length; i4 < len; ++i4) {
      const el = items[i4].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d3 = distanceBetweenPoints(eventPosition, center);
        if (d3 < minDistance) {
          minDistance = d3;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x5 = tp.x;
      y4 = tp.y;
    }
    return {
      x: x5,
      y: y4
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index4 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index4);
  return {
    chart,
    label,
    parsed: controller.getParsed(index4),
    raw: chart.data.datasets[datasetIndex].data[index4],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index4,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body: body2, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body2.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body2.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body2, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y: y4, height } = size;
  if (y4 < height / 2) {
    return "top";
  } else if (y4 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x: x5, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x5 + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x5 - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x: x5, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x5 <= (left + right) / 2 ? "left" : "right";
  } else if (x5 <= width / 2) {
    xAlign = "left";
  } else if (x5 >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x: x5, width } = size;
  if (xAlign === "right") {
    x5 -= width;
  } else if (xAlign === "center") {
    x5 -= width / 2;
  }
  return x5;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y: y4, height } = size;
  if (yAlign === "top") {
    y4 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y4 -= height + paddingAndSize;
  } else {
    y4 -= height / 2;
  }
  return y4;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x5 = alignX(size, xAlign);
  const y4 = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x5 += paddingAndSize;
    } else if (xAlign === "right") {
      x5 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x5 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x5 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x5, 0, chart.width - size.width),
    y: _limitValue(y4, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext2(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element2 {
  static positioners = positioners;
  constructor(config3) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config3.chart;
    this.options = config3.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i4, len;
    for (i4 = 0, len = active.length; i4 < len; ++i4) {
      tooltipItems.push(createTooltipItem(this.chart, active[i4]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index4, array) => options.filter(element, index4, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a4, b4) => options.itemSort(a4, b4, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x22, x32, y1, y22, y32;
    if (yAlign === "center") {
      y22 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x22 = x1 - caretSize;
        y1 = y22 + caretSize;
        y32 = y22 - caretSize;
      } else {
        x1 = ptX + width;
        x22 = x1 + caretSize;
        y1 = y22 - caretSize;
        y32 = y22 + caretSize;
      }
      x32 = x1;
    } else {
      if (xAlign === "left") {
        x22 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x22 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x22 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y22 = y1 - caretSize;
        x1 = x22 - caretSize;
        x32 = x22 + caretSize;
      } else {
        y1 = ptY + height;
        y22 = y1 + caretSize;
        x1 = x22 + caretSize;
        x32 = x22 - caretSize;
      }
      y32 = y1;
    }
    return {
      x1,
      x2: x22,
      x3: x32,
      y1,
      y2: y22,
      y3: y32
    };
  }
  drawTitle(pt2, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i4;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i4 = 0; i4 < length; ++i4) {
        ctx.fillText(title[i4], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
        pt2.y += titleFont.lineHeight + titleSpacing;
        if (i4 + 1 === length) {
          pt2.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt2, i4, rtlHelper, options) {
    const labelColor = this.labelColors[i4];
    const labelPointStyle = this.labelPointStyles[i4];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt2.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i4];
  }
  drawBody(pt2, ctx, options) {
    const { body: body2 } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
      pt2.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i4, j5, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt2.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i4 = 0, ilen = body2.length; i4 < ilen; ++i4) {
      bodyItem = body2[i4];
      textColor = this.labelTextColors[i4];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt2, i4, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j5 = 0, jlen = lines.length; j5 < jlen; ++j5) {
        fillLineOfText(lines[j5]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt2.y -= bodySpacing;
  }
  drawFooter(pt2, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i4;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt2.x = getAlignedX(this, options.footerAlign, options);
      pt2.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i4 = 0; i4 < length; ++i4) {
        ctx.fillText(footer[i4], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
        pt2.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt2, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x5, y: y4 } = pt2;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x5 + topLeft, y4);
    if (yAlign === "top") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x5 + width - topRight, y4);
    ctx.quadraticCurveTo(x5 + width, y4, x5 + width, y4 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x5 + width, y4 + height - bottomRight);
    ctx.quadraticCurveTo(x5 + width, y4 + height, x5 + width - bottomRight, y4 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x5 + bottomLeft, y4 + height);
    ctx.quadraticCurveTo(x5, y4 + height, x5, y4 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt2, ctx, tooltipSize, options);
    }
    ctx.lineTo(x5, y4 + topLeft);
    ctx.quadraticCurveTo(x5, y4, x5 + topLeft, y4);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt2 = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt2, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt2.y += padding.top;
      this.drawTitle(pt2, ctx, options);
      this.drawBody(pt2, ctx, options);
      this.drawFooter(pt2, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index4 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index4],
        index: index4
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e4, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e4, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e4);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e4.x,
          y: e4.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e4, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e4.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i4) => this.chart.data.datasets[i4.datasetIndex] && this.chart.getDatasetMeta(i4.datasetIndex).controller.getParsed(i4.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e4, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e4) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e4);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index3,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index4, addedLabels) => {
  if (typeof raw === "string") {
    index4 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index4,
      label: raw
    });
  } else if (isNaN(raw)) {
    index4 = null;
  }
  return index4;
};
function findOrAddLabel(labels, raw, index4, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index4, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index4 : first;
}
var validIndex = (index4, max) => index4 === null ? null : _limitValue(Math.round(index4), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  static id = "category";
  static defaults = {
    ticks: {
      callback: _getLabelForValue
    }
  };
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index4, label } of added) {
        if (labels[index4] === label) {
          labels.splice(index4, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index4) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index4 = isFinite(index4) && labels[index4] === raw ? index4 : findOrAddLabel(labels, raw, valueOrDefault(index4, raw), this._addedLabels);
    return validIndex(index4, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index4) {
    const ticks = this.ticks;
    if (index4 < 0 || index4 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index4].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j5 = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j5++;
      }
      if (almostEquals(Math.round((niceMin + j5 * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j5++;
      }
    } else if (niceMin < min) {
      j5++;
    }
  }
  for (; j5 < numSpaces; ++j5) {
    const tickValue = Math.round((niceMin + j5 * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index4) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v4) => min = minDefined ? min : v4;
    const setMax = (v4) => max = maxDefined ? max : v4;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start4 = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start4) / Math.max(ticks.length - 1, 1) / 2;
      start4 -= offset;
      end += offset;
    }
    this._startValue = start4;
    this._endValue = end;
    this._valueRange = end - start4;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
var log10Floor = (v4) => Math.floor(log10(v4));
var changeExponent = (v4, m5) => Math.pow(10, log10Floor(v4) + m5);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start4 = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start4;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start4 = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start4 - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  static id = "logarithmic";
  static defaults = {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index4) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index4
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v4) => min = minDefined ? min : v4;
    const setMax = (v4) => max = maxDefined ? max : v4;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start4 = this.min;
    super.configure();
    this._startValue = log10(start4);
    this._valueRange = log10(this.max) - log10(start4);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i4 = 0; i4 < valueCount; i4++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i4));
    padding[i4] = opts.padding;
    const pointPosition = scale.getPointPosition(i4, scale.drawingArea + padding[i4], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i4]);
    labelSizes[i4] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i4) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x5 = 0;
  let y4 = 0;
  if (hLimits.start < orig.l) {
    x5 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x5);
  } else if (hLimits.end > orig.r) {
    x5 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x5);
  }
  if (vLimits.start < orig.t) {
    y4 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y4);
  } else if (vLimits.end > orig.b) {
    y4 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y4);
  }
}
function createPointLabelItem(scale, index4, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index4, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y4 = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y: y4,
    textAlign,
    left,
    top: y4,
    right: left + size.w,
    bottom: y4 + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i4 = 0; i4 < valueCount; i4++) {
    itemOpts.padding = padding[i4];
    itemOpts.size = labelSizes[i4];
    const item = createPointLabelItem(scale, i4, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x5, w5, align) {
  if (align === "right") {
    x5 -= w5;
  } else if (align === "center") {
    x5 -= w5 / 2;
  }
  return x5;
}
function yForAngle(y4, h4, angle) {
  if (angle === 90 || angle === 270) {
    y4 -= h4 / 2;
  } else if (angle > 270 || angle < 90) {
    y4 -= h4;
  }
  return y4;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v4) => v4 !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i4 = labelCount - 1; i4 >= 0; i4--) {
    const item = scale._pointLabelItems[i4];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i4));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x: x5, y: y4, textAlign } = item;
    renderText(ctx, scale._pointLabels[i4], x5, y4 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i4 = 1; i4 < labelCount; i4++) {
      pointPosition = scale.getPointPosition(i4, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash || []);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index4, label) {
  return createContext2(parent, {
    label,
    index: index4,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  static id = "radialLinear";
  static defaults = {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  };
  static defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  };
  static descriptors = {
    angleLines: {
      _fallback: "grid"
    }
  };
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w5 = this.width = this.maxWidth - padding.width;
    const h4 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w5 / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w5, h4) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index4) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index4
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v4, i4) => this.chart.getDataVisibility(i4));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index4) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index4 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index4) {
    const pointLabels = this._pointLabels || [];
    if (index4 >= 0 && index4 < pointLabels.length) {
      const pointLabel = pointLabels[index4];
      return createPointLabelContext(this.getContext(), index4, pointLabel);
    }
  }
  getPointPosition(index4, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index4) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index4, value) {
    return this.getPointPosition(index4, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index4) {
    return this.getPointPositionForValue(index4 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index4) {
    const { left, top, right, bottom } = this._pointLabelItems[index4];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i4, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index4) => {
        if (index4 !== 0 || index4 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index4);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i4 = labelCount - 1; i4 >= 0; i4--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i4));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i4, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index4) => {
      if (index4 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index4));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index4].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a4, b4) {
  return a4 - b4;
}
function parse2(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i4 = UNITS.indexOf(minUnit); i4 < ilen - 1; ++i4) {
    const interval = INTERVALS[UNITS[i4]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i4];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i4 = UNITS.length - 1; i4 >= UNITS.indexOf(minUnit); i4--) {
    const unit = UNITS[i4];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i4 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i4 < ilen; ++i4) {
    if (INTERVALS[UNITS[i4]].common) {
      return UNITS[i4];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi: hi2 } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi2];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index4;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index4 = map3[major];
    if (index4 >= 0) {
      ticks[index4].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i4, value;
  for (i4 = 0; i4 < ilen; ++i4) {
    value = values[i4];
    map3[value] = i4;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  };
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index4) {
    if (raw === void 0) {
      return null;
    }
    return parse2(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start4 = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start4 = 1 - first;
      } else {
        start4 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start4 = _limitValue(start4, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start: start4,
      end,
      factor: 1 / (start4 + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x5) => +x5);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index4, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index4,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index4];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i4, ilen, tick;
    for (i4 = 0, ilen = ticks.length; i4 < ilen; ++i4) {
      tick = ticks[i4];
      tick.label = this._tickFormatFunction(tick.value, i4, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i4, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i4 = 0, ilen = metas.length; i4 < ilen; ++i4) {
      timestamps = timestamps.concat(metas[i4].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i4, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i4 = 0, ilen = labels.length; i4 < ilen; ++i4) {
      timestamps.push(parse2(this, labels[i4]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
function interpolate3(table, val, reverse) {
  let lo = 0;
  let hi2 = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi2].pos) {
      ({ lo, hi: hi2 } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi2]);
  } else {
    if (val >= table[lo].time && val <= table[hi2].time) {
      ({ lo, hi: hi2 } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi2]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  static id = "timeseries";
  static defaults = TimeScale.defaults;
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate3(table, this.min);
    this._tableRange = interpolate3(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i4, ilen, prev, curr, next;
    for (i4 = 0, ilen = timestamps.length; i4 < ilen; ++i4) {
      curr = timestamps[i4];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i4 = 0, ilen = items.length; i4 < ilen; ++i4) {
      next = items[i4 + 1];
      prev = items[i4 - 1];
      curr = items[i4];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i4 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a4, b4) => a4 - b4);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate3(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate3(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.js
Chart.register(...registerables);
var auto_default = Chart;

// node_modules/trix/dist/trix.esm.min.js
var t3 = "2.1.12";
var e3 = "[data-trix-attachment]";
var i3 = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
var n2 = { default: { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, htmlAttributes: ["language"], text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test(t5) {
  return r3(t5.parentNode) === n2[this.listAttribute].tagName;
} }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test(t5) {
  return r3(t5.parentNode) === n2[this.listAttribute].tagName;
} }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
var r3 = (t5) => {
  var e4;
  return null == t5 || null === (e4 = t5.tagName) || void 0 === e4 ? void 0 : e4.toLowerCase();
};
var o2 = navigator.userAgent.match(/android\s([0-9]+.*Chrome)/i);
var s3 = o2 && parseInt(o2[1]);
var a3 = { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), recentAndroid: s3 && s3 > 12, samsungAndroid: s3 && navigator.userAgent.match(/Android.*SM-/), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: "undefined" != typeof InputEvent && ["data", "getTargetRanges", "inputType"].every((t5) => t5 in InputEvent.prototype) };
var l3 = { ADD_ATTR: ["language"], SAFE_FOR_XML: false, RETURN_DOM: true };
var c3 = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
var u3 = [c3.bytes, c3.KB, c3.MB, c3.GB, c3.TB, c3.PB];
var h3 = { prefix: "IEC", precision: 2, formatter(t5) {
  switch (t5) {
    case 0:
      return "0 ".concat(c3.bytes);
    case 1:
      return "1 ".concat(c3.byte);
    default:
      let e4;
      "SI" === this.prefix ? e4 = 1e3 : "IEC" === this.prefix && (e4 = 1024);
      const i4 = Math.floor(Math.log(t5) / Math.log(e4)), n3 = (t5 / Math.pow(e4, i4)).toFixed(this.precision).replace(/0*$/, "").replace(/\.$/, "");
      return "".concat(n3, " ").concat(u3[i4]);
  }
} };
var d2 = "\uFEFF";
var g4 = "\xA0";
var m4 = function(t5) {
  for (const e4 in t5) {
    const i4 = t5[e4];
    this[e4] = i4;
  }
  return this;
};
var p3 = document.documentElement;
var f3 = p3.matches;
var b3 = function(t5) {
  let { onElement: e4, matchingSelector: i4, withCallback: n3, inPhase: r4, preventDefault: o3, times: s4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const a4 = e4 || p3, l4 = i4, c4 = "capturing" === r4, u4 = function(t6) {
    null != s4 && 0 == --s4 && u4.destroy();
    const e5 = y3(t6.target, { matchingSelector: l4 });
    null != e5 && (null == n3 || n3.call(e5, t6, e5), o3 && t6.preventDefault());
  };
  return u4.destroy = () => a4.removeEventListener(t5, u4, c4), a4.addEventListener(t5, u4, c4), u4;
};
var v3 = function(t5) {
  let { onElement: e4, bubbles: i4, cancelable: n3, attributes: r4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const o3 = null != e4 ? e4 : p3;
  i4 = false !== i4, n3 = false !== n3;
  const s4 = document.createEvent("Events");
  return s4.initEvent(t5, i4, n3), null != r4 && m4.call(s4, r4), o3.dispatchEvent(s4);
};
var A3 = function(t5, e4) {
  if (1 === (null == t5 ? void 0 : t5.nodeType)) return f3.call(t5, e4);
};
var y3 = function(t5) {
  let { matchingSelector: e4, untilNode: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  for (; t5 && t5.nodeType !== Node.ELEMENT_NODE; ) t5 = t5.parentNode;
  if (null != t5) {
    if (null == e4) return t5;
    if (t5.closest && null == i4) return t5.closest(e4);
    for (; t5 && t5 !== i4; ) {
      if (A3(t5, e4)) return t5;
      t5 = t5.parentNode;
    }
  }
};
var x4 = (t5) => document.activeElement !== t5 && C3(t5, document.activeElement);
var C3 = function(t5, e4) {
  if (t5 && e4) for (; e4; ) {
    if (e4 === t5) return true;
    e4 = e4.parentNode;
  }
};
var E2 = function(t5) {
  var e4;
  if (null === (e4 = t5) || void 0 === e4 || !e4.parentNode) return;
  let i4 = 0;
  for (t5 = t5.previousSibling; t5; ) i4++, t5 = t5.previousSibling;
  return i4;
};
var S2 = (t5) => {
  var e4;
  return null == t5 || null === (e4 = t5.parentNode) || void 0 === e4 ? void 0 : e4.removeChild(t5);
};
var R = function(t5) {
  let { onlyNodesOfType: e4, usingFilter: i4, expandEntityReferences: n3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const r4 = (() => {
    switch (e4) {
      case "element":
        return NodeFilter.SHOW_ELEMENT;
      case "text":
        return NodeFilter.SHOW_TEXT;
      case "comment":
        return NodeFilter.SHOW_COMMENT;
      default:
        return NodeFilter.SHOW_ALL;
    }
  })();
  return document.createTreeWalker(t5, r4, null != i4 ? i4 : null, true === n3);
};
var k3 = (t5) => {
  var e4;
  return null == t5 || null === (e4 = t5.tagName) || void 0 === e4 ? void 0 : e4.toLowerCase();
};
var T4 = function(t5) {
  let e4, i4, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  "object" == typeof t5 ? (n3 = t5, t5 = n3.tagName) : n3 = { attributes: n3 };
  const r4 = document.createElement(t5);
  if (null != n3.editable && (null == n3.attributes && (n3.attributes = {}), n3.attributes.contenteditable = n3.editable), n3.attributes) for (e4 in n3.attributes) i4 = n3.attributes[e4], r4.setAttribute(e4, i4);
  if (n3.style) for (e4 in n3.style) i4 = n3.style[e4], r4.style[e4] = i4;
  if (n3.data) for (e4 in n3.data) i4 = n3.data[e4], r4.dataset[e4] = i4;
  return n3.className && n3.className.split(" ").forEach((t6) => {
    r4.classList.add(t6);
  }), n3.textContent && (r4.textContent = n3.textContent), n3.childNodes && [].concat(n3.childNodes).forEach((t6) => {
    r4.appendChild(t6);
  }), r4;
};
var w4;
var L3 = function() {
  if (null != w4) return w4;
  w4 = [];
  for (const t5 in n2) {
    const e4 = n2[t5];
    e4.tagName && w4.push(e4.tagName);
  }
  return w4;
};
var D3 = (t5) => I3(null == t5 ? void 0 : t5.firstChild);
var N3 = function(t5) {
  let { strict: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { strict: true };
  return e4 ? I3(t5) : I3(t5) || !I3(t5.firstChild) && function(t6) {
    return L3().includes(k3(t6)) && !L3().includes(k3(t6.firstChild));
  }(t5);
};
var I3 = (t5) => O2(t5) && "block" === (null == t5 ? void 0 : t5.data);
var O2 = (t5) => (null == t5 ? void 0 : t5.nodeType) === Node.COMMENT_NODE;
var F4 = function(t5) {
  let { name: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  if (t5) return B3(t5) ? t5.data === d2 ? !e4 || t5.parentNode.dataset.trixCursorTarget === e4 : void 0 : F4(t5.firstChild);
};
var P3 = (t5) => A3(t5, e3);
var M2 = (t5) => B3(t5) && "" === (null == t5 ? void 0 : t5.data);
var B3 = (t5) => (null == t5 ? void 0 : t5.nodeType) === Node.TEXT_NODE;
var _3 = { level2Enabled: true, getLevel() {
  return this.level2Enabled && a3.supportsInputEvents ? 2 : 0;
}, pickFiles(t5) {
  const e4 = T4("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId });
  e4.addEventListener("change", () => {
    t5(e4.files), S2(e4);
  }), S2(document.getElementById(this.fileInputId)), document.body.appendChild(e4), e4.click();
} };
var j4 = { removeBlankTableCells: false, tableCellSeparator: " | ", tableRowSeparator: "\n" };
var W2 = { bold: { tagName: "strong", inheritable: true, parser(t5) {
  const e4 = window.getComputedStyle(t5);
  return "bold" === e4.fontWeight || e4.fontWeight >= 600;
} }, italic: { tagName: "em", inheritable: true, parser: (t5) => "italic" === window.getComputedStyle(t5).fontStyle }, href: { groupTagName: "a", parser(t5) {
  const i4 = "a:not(".concat(e3, ")"), n3 = t5.closest(i4);
  if (n3) return n3.getAttribute("href");
} }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
var U2 = { getDefaultHTML: () => '<div class="trix-button-row">\n      <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="'.concat(c3.bold, '" tabindex="-1">').concat(c3.bold, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="').concat(c3.italic, '" tabindex="-1">').concat(c3.italic, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="').concat(c3.strike, '" tabindex="-1">').concat(c3.strike, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="').concat(c3.link, '" tabindex="-1">').concat(c3.link, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="').concat(c3.heading1, '" tabindex="-1">').concat(c3.heading1, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="').concat(c3.quote, '" tabindex="-1">').concat(c3.quote, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="').concat(c3.code, '" tabindex="-1">').concat(c3.code, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="').concat(c3.bullets, '" tabindex="-1">').concat(c3.bullets, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="').concat(c3.numbers, '" tabindex="-1">').concat(c3.numbers, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="').concat(c3.outdent, '" tabindex="-1">').concat(c3.outdent, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="').concat(c3.indent, '" tabindex="-1">').concat(c3.indent, '</button>\n      </span>\n\n      <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="').concat(c3.attachFiles, '" tabindex="-1">').concat(c3.attachFiles, '</button>\n      </span>\n\n      <span class="trix-button-group-spacer"></span>\n\n      <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="').concat(c3.undo, '" tabindex="-1">').concat(c3.undo, '</button>\n        <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="').concat(c3.redo, '" tabindex="-1">').concat(c3.redo, '</button>\n      </span>\n    </div>\n\n    <div class="trix-dialogs" data-trix-dialogs>\n      <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n        <div class="trix-dialog__link-fields">\n          <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="').concat(c3.urlPlaceholder, '" aria-label="').concat(c3.url, '" data-trix-validate-href required data-trix-input>\n          <div class="trix-button-group">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c3.link, '" data-trix-method="setAttribute">\n            <input type="button" class="trix-button trix-button--dialog" value="').concat(c3.unlink, '" data-trix-method="removeAttribute">\n          </div>\n        </div>\n      </div>\n    </div>') };
var V3 = { interval: 5e3 };
var z3 = Object.freeze({ __proto__: null, attachments: i3, blockAttributes: n2, browser: a3, css: { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" }, dompurify: l3, fileSize: h3, input: _3, keyNames: { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" }, lang: c3, parser: j4, textAttributes: W2, toolbar: U2, undo: V3 });
var q3 = class {
  static proxyMethod(t5) {
    const { name: e4, toMethod: i4, toProperty: n3, optional: r4 } = H3(t5);
    this.prototype[e4] = function() {
      let t6, o3;
      var s4, a4;
      i4 ? o3 = r4 ? null === (s4 = this[i4]) || void 0 === s4 ? void 0 : s4.call(this) : this[i4]() : n3 && (o3 = this[n3]);
      return r4 ? (t6 = null === (a4 = o3) || void 0 === a4 ? void 0 : a4[e4], t6 ? J2.call(t6, o3, arguments) : void 0) : (t6 = o3[e4], J2.call(t6, o3, arguments));
    };
  }
};
var H3 = function(t5) {
  const e4 = t5.match(K2);
  if (!e4) throw new Error("can't parse @proxyMethod expression: ".concat(t5));
  const i4 = { name: e4[4] };
  return null != e4[2] ? i4.toMethod = e4[1] : i4.toProperty = e4[1], null != e4[3] && (i4.optional = true), i4;
};
var { apply: J2 } = Function.prototype;
var K2 = new RegExp("^(.+?)(\\(\\))?(\\?)?\\.(.+?)$");
var G3;
var Y;
var $4;
var X2 = class extends q3 {
  static box() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    return t5 instanceof this ? t5 : this.fromUCS2String(null == t5 ? void 0 : t5.toString());
  }
  static fromUCS2String(t5) {
    return new this(t5, et(t5));
  }
  static fromCodepoints(t5) {
    return new this(it(t5), t5);
  }
  constructor(t5, e4) {
    super(...arguments), this.ucs2String = t5, this.codepoints = e4, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
  }
  offsetToUCS2Offset(t5) {
    return it(this.codepoints.slice(0, Math.max(0, t5))).length;
  }
  offsetFromUCS2Offset(t5) {
    return et(this.ucs2String.slice(0, Math.max(0, t5))).length;
  }
  slice() {
    return this.constructor.fromCodepoints(this.codepoints.slice(...arguments));
  }
  charAt(t5) {
    return this.slice(t5, t5 + 1);
  }
  isEqualTo(t5) {
    return this.constructor.box(t5).ucs2String === this.ucs2String;
  }
  toJSON() {
    return this.ucs2String;
  }
  getCacheKey() {
    return this.ucs2String;
  }
  toString() {
    return this.ucs2String;
  }
};
var Z2 = 1 === (null === (G3 = Array.from) || void 0 === G3 ? void 0 : G3.call(Array, "\u{1F47C}").length);
var Q2 = null != (null === (Y = " ".codePointAt) || void 0 === Y ? void 0 : Y.call(" ", 0));
var tt = " \u{1F47C}" === (null === ($4 = String.fromCodePoint) || void 0 === $4 ? void 0 : $4.call(String, 32, 128124));
var et;
var it;
et = Z2 && Q2 ? (t5) => Array.from(t5).map((t6) => t6.codePointAt(0)) : function(t5) {
  const e4 = [];
  let i4 = 0;
  const { length: n3 } = t5;
  for (; i4 < n3; ) {
    let r4 = t5.charCodeAt(i4++);
    if (55296 <= r4 && r4 <= 56319 && i4 < n3) {
      const e5 = t5.charCodeAt(i4++);
      56320 == (64512 & e5) ? r4 = ((1023 & r4) << 10) + (1023 & e5) + 65536 : i4--;
    }
    e4.push(r4);
  }
  return e4;
}, it = tt ? (t5) => String.fromCodePoint(...Array.from(t5 || [])) : function(t5) {
  return (() => {
    const e4 = [];
    return Array.from(t5).forEach((t6) => {
      let i4 = "";
      t6 > 65535 && (t6 -= 65536, i4 += String.fromCharCode(t6 >>> 10 & 1023 | 55296), t6 = 56320 | 1023 & t6), e4.push(i4 + String.fromCharCode(t6));
    }), e4;
  })().join("");
};
var nt = 0;
var rt = class extends q3 {
  static fromJSONString(t5) {
    return this.fromJSON(JSON.parse(t5));
  }
  constructor() {
    super(...arguments), this.id = ++nt;
  }
  hasSameConstructorAs(t5) {
    return this.constructor === (null == t5 ? void 0 : t5.constructor);
  }
  isEqualTo(t5) {
    return this === t5;
  }
  inspect() {
    const t5 = [], e4 = this.contentsForInspection() || {};
    for (const i4 in e4) {
      const n3 = e4[i4];
      t5.push("".concat(i4, "=").concat(n3));
    }
    return "#<".concat(this.constructor.name, ":").concat(this.id).concat(t5.length ? " ".concat(t5.join(", ")) : "", ">");
  }
  contentsForInspection() {
  }
  toJSONString() {
    return JSON.stringify(this);
  }
  toUTF16String() {
    return X2.box(this);
  }
  getCacheKey() {
    return this.id.toString();
  }
};
var ot = function() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  if (t5.length !== e4.length) return false;
  for (let i4 = 0; i4 < t5.length; i4++) {
    if (t5[i4] !== e4[i4]) return false;
  }
  return true;
};
var st = function(t5) {
  const e4 = t5.slice(0);
  for (var i4 = arguments.length, n3 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1; r4 < i4; r4++) n3[r4 - 1] = arguments[r4];
  return e4.splice(...n3), e4;
};
var at = /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/;
var lt = function() {
  const t5 = T4("input", { dir: "auto", name: "x", dirName: "x.dir" }), e4 = T4("textarea", { dir: "auto", name: "y", dirName: "y.dir" }), i4 = T4("form");
  i4.appendChild(t5), i4.appendChild(e4);
  const n3 = function() {
    try {
      return new FormData(i4).has(e4.dirName);
    } catch (t6) {
      return false;
    }
  }(), r4 = function() {
    try {
      return t5.matches(":dir(ltr),:dir(rtl)");
    } catch (t6) {
      return false;
    }
  }();
  return n3 ? function(t6) {
    return e4.value = t6, new FormData(i4).get(e4.dirName);
  } : r4 ? function(e5) {
    return t5.value = e5, t5.matches(":dir(rtl)") ? "rtl" : "ltr";
  } : function(t6) {
    const e5 = t6.trim().charAt(0);
    return at.test(e5) ? "rtl" : "ltr";
  };
}();
var ct = null;
var ut = null;
var ht = null;
var dt = null;
var gt = () => (ct || (ct = bt().concat(pt())), ct);
var mt = (t5) => n2[t5];
var pt = () => (ut || (ut = Object.keys(n2)), ut);
var ft = (t5) => W2[t5];
var bt = () => (ht || (ht = Object.keys(W2)), ht);
var vt = function(t5, e4) {
  At(t5).textContent = e4.replace(/%t/g, t5);
};
var At = function(t5) {
  const e4 = document.createElement("style");
  e4.setAttribute("type", "text/css"), e4.setAttribute("data-tag-name", t5.toLowerCase());
  const i4 = yt();
  return i4 && e4.setAttribute("nonce", i4), document.head.insertBefore(e4, document.head.firstChild), e4;
};
var yt = function() {
  const t5 = xt("trix-csp-nonce") || xt("csp-nonce");
  if (t5) {
    const { nonce: e4, content: i4 } = t5;
    return "" == e4 ? i4 : e4;
  }
};
var xt = (t5) => document.head.querySelector("meta[name=".concat(t5, "]"));
var Ct = { "application/x-trix-feature-detection": "test" };
var Et = function(t5) {
  const e4 = t5.getData("text/plain"), i4 = t5.getData("text/html");
  if (!e4 || !i4) return null == e4 ? void 0 : e4.length;
  {
    const { body: t6 } = new DOMParser().parseFromString(i4, "text/html");
    if (t6.textContent === e4) return !t6.querySelector("*");
  }
};
var St = /Mac|^iP/.test(navigator.platform) ? (t5) => t5.metaKey : (t5) => t5.ctrlKey;
var Rt = (t5) => setTimeout(t5, 1);
var kt = function() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const e4 = {};
  for (const i4 in t5) {
    const n3 = t5[i4];
    e4[i4] = n3;
  }
  return e4;
};
var Tt = function() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  if (Object.keys(t5).length !== Object.keys(e4).length) return false;
  for (const i4 in t5) {
    if (t5[i4] !== e4[i4]) return false;
  }
  return true;
};
var wt = function(t5) {
  if (null != t5) return Array.isArray(t5) || (t5 = [t5, t5]), [Nt(t5[0]), Nt(null != t5[1] ? t5[1] : t5[0])];
};
var Lt = function(t5) {
  if (null == t5) return;
  const [e4, i4] = wt(t5);
  return It(e4, i4);
};
var Dt = function(t5, e4) {
  if (null == t5 || null == e4) return;
  const [i4, n3] = wt(t5), [r4, o3] = wt(e4);
  return It(i4, r4) && It(n3, o3);
};
var Nt = function(t5) {
  return "number" == typeof t5 ? t5 : kt(t5);
};
var It = function(t5, e4) {
  return "number" == typeof t5 ? t5 === e4 : Tt(t5, e4);
};
var Ot = class extends q3 {
  constructor() {
    super(...arguments), this.update = this.update.bind(this), this.selectionManagers = [];
  }
  start() {
    this.started || (this.started = true, document.addEventListener("selectionchange", this.update, true));
  }
  stop() {
    if (this.started) return this.started = false, document.removeEventListener("selectionchange", this.update, true);
  }
  registerSelectionManager(t5) {
    if (!this.selectionManagers.includes(t5)) return this.selectionManagers.push(t5), this.start();
  }
  unregisterSelectionManager(t5) {
    if (this.selectionManagers = this.selectionManagers.filter((e4) => e4 !== t5), 0 === this.selectionManagers.length) return this.stop();
  }
  notifySelectionManagersOfSelectionChange() {
    return this.selectionManagers.map((t5) => t5.selectionDidChange());
  }
  update() {
    this.notifySelectionManagersOfSelectionChange();
  }
  reset() {
    this.update();
  }
};
var Ft = new Ot();
var Pt = function() {
  const t5 = window.getSelection();
  if (t5.rangeCount > 0) return t5;
};
var Mt = function() {
  var t5;
  const e4 = null === (t5 = Pt()) || void 0 === t5 ? void 0 : t5.getRangeAt(0);
  if (e4 && !_t(e4)) return e4;
};
var Bt = function(t5) {
  const e4 = window.getSelection();
  return e4.removeAllRanges(), e4.addRange(t5), Ft.update();
};
var _t = (t5) => jt(t5.startContainer) || jt(t5.endContainer);
var jt = (t5) => !Object.getPrototypeOf(t5);
var Wt = (t5) => t5.replace(new RegExp("".concat(d2), "g"), "").replace(new RegExp("".concat(g4), "g"), " ");
var Ut = new RegExp("[^\\S".concat(g4, "]"));
var Vt = (t5) => t5.replace(new RegExp("".concat(Ut.source), "g"), " ").replace(/\ {2,}/g, " ");
var zt = function(t5, e4) {
  if (t5.isEqualTo(e4)) return ["", ""];
  const i4 = qt(t5, e4), { length: n3 } = i4.utf16String;
  let r4;
  if (n3) {
    const { offset: o3 } = i4, s4 = t5.codepoints.slice(0, o3).concat(t5.codepoints.slice(o3 + n3));
    r4 = qt(e4, X2.fromCodepoints(s4));
  } else r4 = qt(e4, t5);
  return [i4.utf16String.toString(), r4.utf16String.toString()];
};
var qt = function(t5, e4) {
  let i4 = 0, n3 = t5.length, r4 = e4.length;
  for (; i4 < n3 && t5.charAt(i4).isEqualTo(e4.charAt(i4)); ) i4++;
  for (; n3 > i4 + 1 && t5.charAt(n3 - 1).isEqualTo(e4.charAt(r4 - 1)); ) n3--, r4--;
  return { utf16String: t5.slice(i4, n3), offset: i4 };
};
var Ht = class _Ht extends rt {
  static fromCommonAttributesOfObjects() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    if (!t5.length) return new this();
    let e4 = Yt(t5[0]), i4 = e4.getKeys();
    return t5.slice(1).forEach((t6) => {
      i4 = e4.getKeysCommonToHash(Yt(t6)), e4 = e4.slice(i4);
    }), e4;
  }
  static box(t5) {
    return Yt(t5);
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    super(...arguments), this.values = Gt(t5);
  }
  add(t5, e4) {
    return this.merge(Jt(t5, e4));
  }
  remove(t5) {
    return new _Ht(Gt(this.values, t5));
  }
  get(t5) {
    return this.values[t5];
  }
  has(t5) {
    return t5 in this.values;
  }
  merge(t5) {
    return new _Ht(Kt(this.values, $t(t5)));
  }
  slice(t5) {
    const e4 = {};
    return Array.from(t5).forEach((t6) => {
      this.has(t6) && (e4[t6] = this.values[t6]);
    }), new _Ht(e4);
  }
  getKeys() {
    return Object.keys(this.values);
  }
  getKeysCommonToHash(t5) {
    return t5 = Yt(t5), this.getKeys().filter((e4) => this.values[e4] === t5.values[e4]);
  }
  isEqualTo(t5) {
    return ot(this.toArray(), Yt(t5).toArray());
  }
  isEmpty() {
    return 0 === this.getKeys().length;
  }
  toArray() {
    if (!this.array) {
      const t5 = [];
      for (const e4 in this.values) {
        const i4 = this.values[e4];
        t5.push(t5.push(e4, i4));
      }
      this.array = t5.slice(0);
    }
    return this.array;
  }
  toObject() {
    return Gt(this.values);
  }
  toJSON() {
    return this.toObject();
  }
  contentsForInspection() {
    return { values: JSON.stringify(this.values) };
  }
};
var Jt = function(t5, e4) {
  const i4 = {};
  return i4[t5] = e4, i4;
};
var Kt = function(t5, e4) {
  const i4 = Gt(t5);
  for (const t6 in e4) {
    const n3 = e4[t6];
    i4[t6] = n3;
  }
  return i4;
};
var Gt = function(t5, e4) {
  const i4 = {};
  return Object.keys(t5).sort().forEach((n3) => {
    n3 !== e4 && (i4[n3] = t5[n3]);
  }), i4;
};
var Yt = function(t5) {
  return t5 instanceof Ht ? t5 : new Ht(t5);
};
var $t = function(t5) {
  return t5 instanceof Ht ? t5.values : t5;
};
var Xt = class {
  static groupObjects() {
    let t5, e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: i4, asTree: n3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    n3 && null == i4 && (i4 = 0);
    const r4 = [];
    return Array.from(e4).forEach((e5) => {
      var o3;
      if (t5) {
        var s4, a4, l4;
        if (null !== (s4 = e5.canBeGrouped) && void 0 !== s4 && s4.call(e5, i4) && null !== (a4 = (l4 = t5[t5.length - 1]).canBeGroupedWith) && void 0 !== a4 && a4.call(l4, e5, i4)) return void t5.push(e5);
        r4.push(new this(t5, { depth: i4, asTree: n3 })), t5 = null;
      }
      null !== (o3 = e5.canBeGrouped) && void 0 !== o3 && o3.call(e5, i4) ? t5 = [e5] : r4.push(e5);
    }), t5 && r4.push(new this(t5, { depth: i4, asTree: n3 })), r4;
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], { depth: e4, asTree: i4 } = arguments.length > 1 ? arguments[1] : void 0;
    this.objects = t5, i4 && (this.depth = e4, this.objects = this.constructor.groupObjects(this.objects, { asTree: i4, depth: this.depth + 1 }));
  }
  getObjects() {
    return this.objects;
  }
  getDepth() {
    return this.depth;
  }
  getCacheKey() {
    const t5 = ["objectGroup"];
    return Array.from(this.getObjects()).forEach((e4) => {
      t5.push(e4.getCacheKey());
    }), t5.join("/");
  }
};
var Zt = class extends q3 {
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    super(...arguments), this.objects = {}, Array.from(t5).forEach((t6) => {
      const e4 = JSON.stringify(t6);
      null == this.objects[e4] && (this.objects[e4] = t6);
    });
  }
  find(t5) {
    const e4 = JSON.stringify(t5);
    return this.objects[e4];
  }
};
var Qt = class {
  constructor(t5) {
    this.reset(t5);
  }
  add(t5) {
    const e4 = te(t5);
    this.elements[e4] = t5;
  }
  remove(t5) {
    const e4 = te(t5), i4 = this.elements[e4];
    if (i4) return delete this.elements[e4], i4;
  }
  reset() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return this.elements = {}, Array.from(t5).forEach((t6) => {
      this.add(t6);
    }), t5;
  }
};
var te = (t5) => t5.dataset.trixStoreKey;
var ee = class extends q3 {
  isPerforming() {
    return true === this.performing;
  }
  hasPerformed() {
    return true === this.performed;
  }
  hasSucceeded() {
    return this.performed && this.succeeded;
  }
  hasFailed() {
    return this.performed && !this.succeeded;
  }
  getPromise() {
    return this.promise || (this.promise = new Promise((t5, e4) => (this.performing = true, this.perform((i4, n3) => {
      this.succeeded = i4, this.performing = false, this.performed = true, this.succeeded ? t5(n3) : e4(n3);
    })))), this.promise;
  }
  perform(t5) {
    return t5(false);
  }
  release() {
    var t5, e4;
    null === (t5 = this.promise) || void 0 === t5 || null === (e4 = t5.cancel) || void 0 === e4 || e4.call(t5), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
  }
};
ee.proxyMethod("getPromise().then"), ee.proxyMethod("getPromise().catch");
var ie = class extends q3 {
  constructor(t5) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(...arguments), this.object = t5, this.options = e4, this.childViews = [], this.rootView = this;
  }
  getNodes() {
    return this.nodes || (this.nodes = this.createNodes()), this.nodes.map((t5) => t5.cloneNode(true));
  }
  invalidate() {
    var t5;
    return this.nodes = null, this.childViews = [], null === (t5 = this.parentView) || void 0 === t5 ? void 0 : t5.invalidate();
  }
  invalidateViewForObject(t5) {
    var e4;
    return null === (e4 = this.findViewForObject(t5)) || void 0 === e4 ? void 0 : e4.invalidate();
  }
  findOrCreateCachedChildView(t5, e4, i4) {
    let n3 = this.getCachedViewForObject(e4);
    return n3 ? this.recordChildView(n3) : (n3 = this.createChildView(...arguments), this.cacheViewForObject(n3, e4)), n3;
  }
  createChildView(t5, e4) {
    let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    e4 instanceof Xt && (i4.viewClass = t5, t5 = ne);
    const n3 = new t5(e4, i4);
    return this.recordChildView(n3);
  }
  recordChildView(t5) {
    return t5.parentView = this, t5.rootView = this.rootView, this.childViews.push(t5), t5;
  }
  getAllChildViews() {
    let t5 = [];
    return this.childViews.forEach((e4) => {
      t5.push(e4), t5 = t5.concat(e4.getAllChildViews());
    }), t5;
  }
  findElement() {
    return this.findElementForObject(this.object);
  }
  findElementForObject(t5) {
    const e4 = null == t5 ? void 0 : t5.id;
    if (e4) return this.rootView.element.querySelector("[data-trix-id='".concat(e4, "']"));
  }
  findViewForObject(t5) {
    for (const e4 of this.getAllChildViews()) if (e4.object === t5) return e4;
  }
  getViewCache() {
    return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? (this.viewCache || (this.viewCache = {}), this.viewCache) : void 0;
  }
  isViewCachingEnabled() {
    return false !== this.shouldCacheViews;
  }
  enableViewCaching() {
    this.shouldCacheViews = true;
  }
  disableViewCaching() {
    this.shouldCacheViews = false;
  }
  getCachedViewForObject(t5) {
    var e4;
    return null === (e4 = this.getViewCache()) || void 0 === e4 ? void 0 : e4[t5.getCacheKey()];
  }
  cacheViewForObject(t5, e4) {
    const i4 = this.getViewCache();
    i4 && (i4[e4.getCacheKey()] = t5);
  }
  garbageCollectCachedViews() {
    const t5 = this.getViewCache();
    if (t5) {
      const e4 = this.getAllChildViews().concat(this).map((t6) => t6.object.getCacheKey());
      for (const i4 in t5) e4.includes(i4) || delete t5[i4];
    }
  }
};
var ne = class extends ie {
  constructor() {
    super(...arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
  }
  getChildViews() {
    return this.childViews.length || Array.from(this.objectGroup.getObjects()).forEach((t5) => {
      this.findOrCreateCachedChildView(this.viewClass, t5, this.options);
    }), this.childViews;
  }
  createNodes() {
    const t5 = this.createContainerElement();
    return this.getChildViews().forEach((e4) => {
      Array.from(e4.getNodes()).forEach((e5) => {
        t5.appendChild(e5);
      });
    }), [t5];
  }
  createContainerElement() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.objectGroup.getDepth();
    return this.getChildViews()[0].createContainerElement(t5);
  }
};
var { entries: re, setPrototypeOf: oe, isFrozen: se, getPrototypeOf: ae, getOwnPropertyDescriptor: le } = Object;
var { freeze: ce, seal: ue, create: he } = Object;
var { apply: de, construct: ge } = "undefined" != typeof Reflect && Reflect;
ce || (ce = function(t5) {
  return t5;
}), ue || (ue = function(t5) {
  return t5;
}), de || (de = function(t5, e4, i4) {
  return t5.apply(e4, i4);
}), ge || (ge = function(t5, e4) {
  return new t5(...e4);
});
var me = Te(Array.prototype.forEach);
var pe = Te(Array.prototype.pop);
var fe = Te(Array.prototype.push);
var be = Te(String.prototype.toLowerCase);
var ve = Te(String.prototype.toString);
var Ae = Te(String.prototype.match);
var ye = Te(String.prototype.replace);
var xe = Te(String.prototype.indexOf);
var Ce = Te(String.prototype.trim);
var Ee = Te(Object.prototype.hasOwnProperty);
var Se = Te(RegExp.prototype.test);
var Re = (ke = TypeError, function() {
  for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
  return ge(ke, e4);
});
var ke;
function Te(t5) {
  return function(e4) {
    for (var i4 = arguments.length, n3 = new Array(i4 > 1 ? i4 - 1 : 0), r4 = 1; r4 < i4; r4++) n3[r4 - 1] = arguments[r4];
    return de(t5, e4, n3);
  };
}
function we(t5, e4) {
  let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : be;
  oe && oe(t5, null);
  let n3 = e4.length;
  for (; n3--; ) {
    let r4 = e4[n3];
    if ("string" == typeof r4) {
      const t6 = i4(r4);
      t6 !== r4 && (se(e4) || (e4[n3] = t6), r4 = t6);
    }
    t5[r4] = true;
  }
  return t5;
}
function Le(t5) {
  for (let e4 = 0; e4 < t5.length; e4++) {
    Ee(t5, e4) || (t5[e4] = null);
  }
  return t5;
}
function De(t5) {
  const e4 = he(null);
  for (const [i4, n3] of re(t5)) {
    Ee(t5, i4) && (Array.isArray(n3) ? e4[i4] = Le(n3) : n3 && "object" == typeof n3 && n3.constructor === Object ? e4[i4] = De(n3) : e4[i4] = n3);
  }
  return e4;
}
function Ne(t5, e4) {
  for (; null !== t5; ) {
    const i4 = le(t5, e4);
    if (i4) {
      if (i4.get) return Te(i4.get);
      if ("function" == typeof i4.value) return Te(i4.value);
    }
    t5 = ae(t5);
  }
  return function() {
    return null;
  };
}
var Ie = ce(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var Oe = ce(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var Fe = ce(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var Pe = ce(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var Me = ce(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var Be = ce(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var _e = ce(["#text"]);
var je = ce(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var We = ce(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var Ue = ce(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var Ve = ce(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var ze = ue(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var qe = ue(/<%[\w\W]*|[\w\W]*%>/gm);
var He = ue(/\$\{[\w\W]*}/gm);
var Je = ue(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var Ke = ue(/^aria-[\-\w]+$/);
var Ge = ue(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var Ye = ue(/^(?:\w+script|data):/i);
var $e = ue(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var Xe = ue(/^html$/i);
var Ze = ue(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Qe = Object.freeze({ __proto__: null, ARIA_ATTR: Ke, ATTR_WHITESPACE: $e, CUSTOM_ELEMENT: Ze, DATA_ATTR: Je, DOCTYPE_NAME: Xe, ERB_EXPR: qe, IS_ALLOWED_URI: Ge, IS_SCRIPT_OR_DATA: Ye, MUSTACHE_EXPR: ze, TMPLIT_EXPR: He });
var ti = 1;
var ei = 3;
var ii = 7;
var ni = 8;
var ri = 9;
var oi = function() {
  return "undefined" == typeof window ? null : window;
};
var si = function t4() {
  let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oi();
  const i4 = (e5) => t4(e5);
  if (i4.version = "3.2.3", i4.removed = [], !e4 || !e4.document || e4.document.nodeType !== ri) return i4.isSupported = false, i4;
  let { document: n3 } = e4;
  const r4 = n3, o3 = r4.currentScript, { DocumentFragment: s4, HTMLTemplateElement: a4, Node: l4, Element: c4, NodeFilter: u4, NamedNodeMap: h4 = e4.NamedNodeMap || e4.MozNamedAttrMap, HTMLFormElement: d3, DOMParser: g5, trustedTypes: m5 } = e4, p4 = c4.prototype, f4 = Ne(p4, "cloneNode"), b4 = Ne(p4, "remove"), v4 = Ne(p4, "nextSibling"), A4 = Ne(p4, "childNodes"), y4 = Ne(p4, "parentNode");
  if ("function" == typeof a4) {
    const t5 = n3.createElement("template");
    t5.content && t5.content.ownerDocument && (n3 = t5.content.ownerDocument);
  }
  let x5, C4 = "";
  const { implementation: E3, createNodeIterator: S3, createDocumentFragment: R2, getElementsByTagName: k4 } = n3, { importNode: T5 } = r4;
  let w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
  i4.isSupported = "function" == typeof re && "function" == typeof y4 && E3 && void 0 !== E3.createHTMLDocument;
  const { MUSTACHE_EXPR: L4, ERB_EXPR: D4, TMPLIT_EXPR: N4, DATA_ATTR: I4, ARIA_ATTR: O3, IS_SCRIPT_OR_DATA: F5, ATTR_WHITESPACE: P4, CUSTOM_ELEMENT: M3 } = Qe;
  let { IS_ALLOWED_URI: B4 } = Qe, _4 = null;
  const j5 = we({}, [...Ie, ...Oe, ...Fe, ...Me, ..._e]);
  let W3 = null;
  const U3 = we({}, [...je, ...We, ...Ue, ...Ve]);
  let V4 = Object.seal(he(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), z4 = null, q4 = null, H4 = true, J3 = true, K3 = false, G4 = true, Y2 = false, $6 = true, X3 = false, Z3 = false, Q3 = false, tt2 = false, et2 = false, it2 = false, nt2 = true, rt2 = false, ot2 = true, st2 = false, at2 = {}, lt2 = null;
  const ct2 = we({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ut2 = null;
  const ht2 = we({}, ["audio", "video", "img", "source", "image", "track"]);
  let dt2 = null;
  const gt2 = we({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), mt2 = "http://www.w3.org/1998/Math/MathML", pt2 = "http://www.w3.org/2000/svg", ft2 = "http://www.w3.org/1999/xhtml";
  let bt2 = ft2, vt2 = false, At2 = null;
  const yt2 = we({}, [mt2, pt2, ft2], ve);
  let xt2 = we({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct2 = we({}, ["annotation-xml"]);
  const Et2 = we({}, ["title", "style", "font", "a", "script"]);
  let St2 = null;
  const Rt2 = ["application/xhtml+xml", "text/html"];
  let kt2 = null, Tt2 = null;
  const wt2 = n3.createElement("form"), Lt2 = function(t5) {
    return t5 instanceof RegExp || t5 instanceof Function;
  }, Dt2 = function() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (!Tt2 || Tt2 !== t5) {
      if (t5 && "object" == typeof t5 || (t5 = {}), t5 = De(t5), St2 = -1 === Rt2.indexOf(t5.PARSER_MEDIA_TYPE) ? "text/html" : t5.PARSER_MEDIA_TYPE, kt2 = "application/xhtml+xml" === St2 ? ve : be, _4 = Ee(t5, "ALLOWED_TAGS") ? we({}, t5.ALLOWED_TAGS, kt2) : j5, W3 = Ee(t5, "ALLOWED_ATTR") ? we({}, t5.ALLOWED_ATTR, kt2) : U3, At2 = Ee(t5, "ALLOWED_NAMESPACES") ? we({}, t5.ALLOWED_NAMESPACES, ve) : yt2, dt2 = Ee(t5, "ADD_URI_SAFE_ATTR") ? we(De(gt2), t5.ADD_URI_SAFE_ATTR, kt2) : gt2, ut2 = Ee(t5, "ADD_DATA_URI_TAGS") ? we(De(ht2), t5.ADD_DATA_URI_TAGS, kt2) : ht2, lt2 = Ee(t5, "FORBID_CONTENTS") ? we({}, t5.FORBID_CONTENTS, kt2) : ct2, z4 = Ee(t5, "FORBID_TAGS") ? we({}, t5.FORBID_TAGS, kt2) : {}, q4 = Ee(t5, "FORBID_ATTR") ? we({}, t5.FORBID_ATTR, kt2) : {}, at2 = !!Ee(t5, "USE_PROFILES") && t5.USE_PROFILES, H4 = false !== t5.ALLOW_ARIA_ATTR, J3 = false !== t5.ALLOW_DATA_ATTR, K3 = t5.ALLOW_UNKNOWN_PROTOCOLS || false, G4 = false !== t5.ALLOW_SELF_CLOSE_IN_ATTR, Y2 = t5.SAFE_FOR_TEMPLATES || false, $6 = false !== t5.SAFE_FOR_XML, X3 = t5.WHOLE_DOCUMENT || false, tt2 = t5.RETURN_DOM || false, et2 = t5.RETURN_DOM_FRAGMENT || false, it2 = t5.RETURN_TRUSTED_TYPE || false, Q3 = t5.FORCE_BODY || false, nt2 = false !== t5.SANITIZE_DOM, rt2 = t5.SANITIZE_NAMED_PROPS || false, ot2 = false !== t5.KEEP_CONTENT, st2 = t5.IN_PLACE || false, B4 = t5.ALLOWED_URI_REGEXP || Ge, bt2 = t5.NAMESPACE || ft2, xt2 = t5.MATHML_TEXT_INTEGRATION_POINTS || xt2, Ct2 = t5.HTML_INTEGRATION_POINTS || Ct2, V4 = t5.CUSTOM_ELEMENT_HANDLING || {}, t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (V4.tagNameCheck = t5.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t5.CUSTOM_ELEMENT_HANDLING && Lt2(t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (V4.attributeNameCheck = t5.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t5.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (V4.allowCustomizedBuiltInElements = t5.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y2 && (J3 = false), et2 && (tt2 = true), at2 && (_4 = we({}, _e), W3 = [], true === at2.html && (we(_4, Ie), we(W3, je)), true === at2.svg && (we(_4, Oe), we(W3, We), we(W3, Ve)), true === at2.svgFilters && (we(_4, Fe), we(W3, We), we(W3, Ve)), true === at2.mathMl && (we(_4, Me), we(W3, Ue), we(W3, Ve))), t5.ADD_TAGS && (_4 === j5 && (_4 = De(_4)), we(_4, t5.ADD_TAGS, kt2)), t5.ADD_ATTR && (W3 === U3 && (W3 = De(W3)), we(W3, t5.ADD_ATTR, kt2)), t5.ADD_URI_SAFE_ATTR && we(dt2, t5.ADD_URI_SAFE_ATTR, kt2), t5.FORBID_CONTENTS && (lt2 === ct2 && (lt2 = De(lt2)), we(lt2, t5.FORBID_CONTENTS, kt2)), ot2 && (_4["#text"] = true), X3 && we(_4, ["html", "head", "body"]), _4.table && (we(_4, ["tbody"]), delete z4.tbody), t5.TRUSTED_TYPES_POLICY) {
        if ("function" != typeof t5.TRUSTED_TYPES_POLICY.createHTML) throw Re('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if ("function" != typeof t5.TRUSTED_TYPES_POLICY.createScriptURL) throw Re('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        x5 = t5.TRUSTED_TYPES_POLICY, C4 = x5.createHTML("");
      } else void 0 === x5 && (x5 = function(t6, e5) {
        if ("object" != typeof t6 || "function" != typeof t6.createPolicy) return null;
        let i5 = null;
        const n4 = "data-tt-policy-suffix";
        e5 && e5.hasAttribute(n4) && (i5 = e5.getAttribute(n4));
        const r5 = "dompurify" + (i5 ? "#" + i5 : "");
        try {
          return t6.createPolicy(r5, { createHTML: (t7) => t7, createScriptURL: (t7) => t7 });
        } catch (t7) {
          return console.warn("TrustedTypes policy " + r5 + " could not be created."), null;
        }
      }(m5, o3)), null !== x5 && "string" == typeof C4 && (C4 = x5.createHTML(""));
      ce && ce(t5), Tt2 = t5;
    }
  }, Nt2 = we({}, [...Oe, ...Fe, ...Pe]), It2 = we({}, [...Me, ...Be]), Ot2 = function(t5) {
    fe(i4.removed, { element: t5 });
    try {
      y4(t5).removeChild(t5);
    } catch (e5) {
      b4(t5);
    }
  }, Ft2 = function(t5, e5) {
    try {
      fe(i4.removed, { attribute: e5.getAttributeNode(t5), from: e5 });
    } catch (t6) {
      fe(i4.removed, { attribute: null, from: e5 });
    }
    if (e5.removeAttribute(t5), "is" === t5) if (tt2 || et2) try {
      Ot2(e5);
    } catch (t6) {
    }
    else try {
      e5.setAttribute(t5, "");
    } catch (t6) {
    }
  }, Pt2 = function(t5) {
    let e5 = null, i5 = null;
    if (Q3) t5 = "<remove></remove>" + t5;
    else {
      const e6 = Ae(t5, /^[\r\n\t ]+/);
      i5 = e6 && e6[0];
    }
    "application/xhtml+xml" === St2 && bt2 === ft2 && (t5 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t5 + "</body></html>");
    const r5 = x5 ? x5.createHTML(t5) : t5;
    if (bt2 === ft2) try {
      e5 = new g5().parseFromString(r5, St2);
    } catch (t6) {
    }
    if (!e5 || !e5.documentElement) {
      e5 = E3.createDocument(bt2, "template", null);
      try {
        e5.documentElement.innerHTML = vt2 ? C4 : r5;
      } catch (t6) {
      }
    }
    const o4 = e5.body || e5.documentElement;
    return t5 && i5 && o4.insertBefore(n3.createTextNode(i5), o4.childNodes[0] || null), bt2 === ft2 ? k4.call(e5, X3 ? "html" : "body")[0] : X3 ? e5.documentElement : o4;
  }, Mt2 = function(t5) {
    return S3.call(t5.ownerDocument || t5, t5, u4.SHOW_ELEMENT | u4.SHOW_COMMENT | u4.SHOW_TEXT | u4.SHOW_PROCESSING_INSTRUCTION | u4.SHOW_CDATA_SECTION, null);
  }, Bt2 = function(t5) {
    return t5 instanceof d3 && ("string" != typeof t5.nodeName || "string" != typeof t5.textContent || "function" != typeof t5.removeChild || !(t5.attributes instanceof h4) || "function" != typeof t5.removeAttribute || "function" != typeof t5.setAttribute || "string" != typeof t5.namespaceURI || "function" != typeof t5.insertBefore || "function" != typeof t5.hasChildNodes);
  }, _t2 = function(t5) {
    return "function" == typeof l4 && t5 instanceof l4;
  };
  function jt2(t5, e5, n4) {
    me(t5, (t6) => {
      t6.call(i4, e5, n4, Tt2);
    });
  }
  const Wt2 = function(t5) {
    let e5 = null;
    if (jt2(w5.beforeSanitizeElements, t5, null), Bt2(t5)) return Ot2(t5), true;
    const n4 = kt2(t5.nodeName);
    if (jt2(w5.uponSanitizeElement, t5, { tagName: n4, allowedTags: _4 }), t5.hasChildNodes() && !_t2(t5.firstElementChild) && Se(/<[/\w]/g, t5.innerHTML) && Se(/<[/\w]/g, t5.textContent)) return Ot2(t5), true;
    if (t5.nodeType === ii) return Ot2(t5), true;
    if ($6 && t5.nodeType === ni && Se(/<[/\w]/g, t5.data)) return Ot2(t5), true;
    if (!_4[n4] || z4[n4]) {
      if (!z4[n4] && Vt2(n4)) {
        if (V4.tagNameCheck instanceof RegExp && Se(V4.tagNameCheck, n4)) return false;
        if (V4.tagNameCheck instanceof Function && V4.tagNameCheck(n4)) return false;
      }
      if (ot2 && !lt2[n4]) {
        const e6 = y4(t5) || t5.parentNode, i5 = A4(t5) || t5.childNodes;
        if (i5 && e6) {
          for (let n5 = i5.length - 1; n5 >= 0; --n5) {
            const r5 = f4(i5[n5], true);
            r5.__removalCount = (t5.__removalCount || 0) + 1, e6.insertBefore(r5, v4(t5));
          }
        }
      }
      return Ot2(t5), true;
    }
    return t5 instanceof c4 && !function(t6) {
      let e6 = y4(t6);
      e6 && e6.tagName || (e6 = { namespaceURI: bt2, tagName: "template" });
      const i5 = be(t6.tagName), n5 = be(e6.tagName);
      return !!At2[t6.namespaceURI] && (t6.namespaceURI === pt2 ? e6.namespaceURI === ft2 ? "svg" === i5 : e6.namespaceURI === mt2 ? "svg" === i5 && ("annotation-xml" === n5 || xt2[n5]) : Boolean(Nt2[i5]) : t6.namespaceURI === mt2 ? e6.namespaceURI === ft2 ? "math" === i5 : e6.namespaceURI === pt2 ? "math" === i5 && Ct2[n5] : Boolean(It2[i5]) : t6.namespaceURI === ft2 ? !(e6.namespaceURI === pt2 && !Ct2[n5]) && !(e6.namespaceURI === mt2 && !xt2[n5]) && !It2[i5] && (Et2[i5] || !Nt2[i5]) : !("application/xhtml+xml" !== St2 || !At2[t6.namespaceURI]));
    }(t5) ? (Ot2(t5), true) : "noscript" !== n4 && "noembed" !== n4 && "noframes" !== n4 || !Se(/<\/no(script|embed|frames)/i, t5.innerHTML) ? (Y2 && t5.nodeType === ei && (e5 = t5.textContent, me([L4, D4, N4], (t6) => {
      e5 = ye(e5, t6, " ");
    }), t5.textContent !== e5 && (fe(i4.removed, { element: t5.cloneNode() }), t5.textContent = e5)), jt2(w5.afterSanitizeElements, t5, null), false) : (Ot2(t5), true);
  }, Ut2 = function(t5, e5, i5) {
    if (nt2 && ("id" === e5 || "name" === e5) && (i5 in n3 || i5 in wt2)) return false;
    if (J3 && !q4[e5] && Se(I4, e5)) ;
    else if (H4 && Se(O3, e5)) ;
    else if (!W3[e5] || q4[e5]) {
      if (!(Vt2(t5) && (V4.tagNameCheck instanceof RegExp && Se(V4.tagNameCheck, t5) || V4.tagNameCheck instanceof Function && V4.tagNameCheck(t5)) && (V4.attributeNameCheck instanceof RegExp && Se(V4.attributeNameCheck, e5) || V4.attributeNameCheck instanceof Function && V4.attributeNameCheck(e5)) || "is" === e5 && V4.allowCustomizedBuiltInElements && (V4.tagNameCheck instanceof RegExp && Se(V4.tagNameCheck, i5) || V4.tagNameCheck instanceof Function && V4.tagNameCheck(i5)))) return false;
    } else if (dt2[e5]) ;
    else if (Se(B4, ye(i5, P4, ""))) ;
    else if ("src" !== e5 && "xlink:href" !== e5 && "href" !== e5 || "script" === t5 || 0 !== xe(i5, "data:") || !ut2[t5]) {
      if (K3 && !Se(F5, ye(i5, P4, ""))) ;
      else if (i5) return false;
    } else ;
    return true;
  }, Vt2 = function(t5) {
    return "annotation-xml" !== t5 && Ae(t5, M3);
  }, zt2 = function(t5) {
    jt2(w5.beforeSanitizeAttributes, t5, null);
    const { attributes: e5 } = t5;
    if (!e5 || Bt2(t5)) return;
    const n4 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: W3, forceKeepAttr: void 0 };
    let r5 = e5.length;
    for (; r5--; ) {
      const o4 = e5[r5], { name: s5, namespaceURI: a5, value: l5 } = o4, c5 = kt2(s5);
      let u5 = "value" === s5 ? l5 : Ce(l5);
      if (n4.attrName = c5, n4.attrValue = u5, n4.keepAttr = true, n4.forceKeepAttr = void 0, jt2(w5.uponSanitizeAttribute, t5, n4), u5 = n4.attrValue, !rt2 || "id" !== c5 && "name" !== c5 || (Ft2(s5, t5), u5 = "user-content-" + u5), $6 && Se(/((--!?|])>)|<\/(style|title)/i, u5)) {
        Ft2(s5, t5);
        continue;
      }
      if (n4.forceKeepAttr) continue;
      if (Ft2(s5, t5), !n4.keepAttr) continue;
      if (!G4 && Se(/\/>/i, u5)) {
        Ft2(s5, t5);
        continue;
      }
      Y2 && me([L4, D4, N4], (t6) => {
        u5 = ye(u5, t6, " ");
      });
      const h5 = kt2(t5.nodeName);
      if (Ut2(h5, c5, u5)) {
        if (x5 && "object" == typeof m5 && "function" == typeof m5.getAttributeType) if (a5) ;
        else switch (m5.getAttributeType(h5, c5)) {
          case "TrustedHTML":
            u5 = x5.createHTML(u5);
            break;
          case "TrustedScriptURL":
            u5 = x5.createScriptURL(u5);
        }
        try {
          a5 ? t5.setAttributeNS(a5, s5, u5) : t5.setAttribute(s5, u5), Bt2(t5) ? Ot2(t5) : pe(i4.removed);
        } catch (t6) {
        }
      }
    }
    jt2(w5.afterSanitizeAttributes, t5, null);
  }, qt2 = function t5(e5) {
    let i5 = null;
    const n4 = Mt2(e5);
    for (jt2(w5.beforeSanitizeShadowDOM, e5, null); i5 = n4.nextNode(); ) jt2(w5.uponSanitizeShadowNode, i5, null), Wt2(i5), zt2(i5), i5.content instanceof s4 && t5(i5.content);
    jt2(w5.afterSanitizeShadowDOM, e5, null);
  };
  return i4.sanitize = function(t5) {
    let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n4 = null, o4 = null, a5 = null, c5 = null;
    if (vt2 = !t5, vt2 && (t5 = "<!-->"), "string" != typeof t5 && !_t2(t5)) {
      if ("function" != typeof t5.toString) throw Re("toString is not a function");
      if ("string" != typeof (t5 = t5.toString())) throw Re("dirty is not a string, aborting");
    }
    if (!i4.isSupported) return t5;
    if (Z3 || Dt2(e5), i4.removed = [], "string" == typeof t5 && (st2 = false), st2) {
      if (t5.nodeName) {
        const e6 = kt2(t5.nodeName);
        if (!_4[e6] || z4[e6]) throw Re("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (t5 instanceof l4) n4 = Pt2("<!---->"), o4 = n4.ownerDocument.importNode(t5, true), o4.nodeType === ti && "BODY" === o4.nodeName || "HTML" === o4.nodeName ? n4 = o4 : n4.appendChild(o4);
    else {
      if (!tt2 && !Y2 && !X3 && -1 === t5.indexOf("<")) return x5 && it2 ? x5.createHTML(t5) : t5;
      if (n4 = Pt2(t5), !n4) return tt2 ? null : it2 ? C4 : "";
    }
    n4 && Q3 && Ot2(n4.firstChild);
    const u5 = Mt2(st2 ? t5 : n4);
    for (; a5 = u5.nextNode(); ) Wt2(a5), zt2(a5), a5.content instanceof s4 && qt2(a5.content);
    if (st2) return t5;
    if (tt2) {
      if (et2) for (c5 = R2.call(n4.ownerDocument); n4.firstChild; ) c5.appendChild(n4.firstChild);
      else c5 = n4;
      return (W3.shadowroot || W3.shadowrootmode) && (c5 = T5.call(r4, c5, true)), c5;
    }
    let h5 = X3 ? n4.outerHTML : n4.innerHTML;
    return X3 && _4["!doctype"] && n4.ownerDocument && n4.ownerDocument.doctype && n4.ownerDocument.doctype.name && Se(Xe, n4.ownerDocument.doctype.name) && (h5 = "<!DOCTYPE " + n4.ownerDocument.doctype.name + ">\n" + h5), Y2 && me([L4, D4, N4], (t6) => {
      h5 = ye(h5, t6, " ");
    }), x5 && it2 ? x5.createHTML(h5) : h5;
  }, i4.setConfig = function() {
    Dt2(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), Z3 = true;
  }, i4.clearConfig = function() {
    Tt2 = null, Z3 = false;
  }, i4.isValidAttribute = function(t5, e5, i5) {
    Tt2 || Dt2({});
    const n4 = kt2(t5), r5 = kt2(e5);
    return Ut2(n4, r5, i5);
  }, i4.addHook = function(t5, e5) {
    "function" == typeof e5 && fe(w5[t5], e5);
  }, i4.removeHook = function(t5) {
    return pe(w5[t5]);
  }, i4.removeHooks = function(t5) {
    w5[t5] = [];
  }, i4.removeAllHooks = function() {
    w5 = { afterSanitizeAttributes: [], afterSanitizeElements: [], afterSanitizeShadowDOM: [], beforeSanitizeAttributes: [], beforeSanitizeElements: [], beforeSanitizeShadowDOM: [], uponSanitizeAttribute: [], uponSanitizeElement: [], uponSanitizeShadowNode: [] };
  }, i4;
}();
si.addHook("uponSanitizeAttribute", function(t5, e4) {
  /^data-trix-/.test(e4.attrName) && (e4.forceKeepAttr = true);
});
var ai = "style href src width height language class".split(" ");
var li = "javascript:".split(" ");
var ci = "script iframe form noscript".split(" ");
var ui = class extends q3 {
  static setHTML(t5, e4) {
    const i4 = new this(e4).sanitize(), n3 = i4.getHTML ? i4.getHTML() : i4.outerHTML;
    t5.innerHTML = n3;
  }
  static sanitize(t5, e4) {
    const i4 = new this(t5, e4);
    return i4.sanitize(), i4;
  }
  constructor(t5) {
    let { allowedAttributes: e4, forbiddenProtocols: i4, forbiddenElements: n3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(...arguments), this.allowedAttributes = e4 || ai, this.forbiddenProtocols = i4 || li, this.forbiddenElements = n3 || ci, this.body = hi(t5);
  }
  sanitize() {
    return this.sanitizeElements(), this.normalizeListElementNesting(), si.setConfig(l3), this.body = si.sanitize(this.body), this.body;
  }
  getHTML() {
    return this.body.innerHTML;
  }
  getBody() {
    return this.body;
  }
  sanitizeElements() {
    const t5 = R(this.body), e4 = [];
    for (; t5.nextNode(); ) {
      const i4 = t5.currentNode;
      switch (i4.nodeType) {
        case Node.ELEMENT_NODE:
          this.elementIsRemovable(i4) ? e4.push(i4) : this.sanitizeElement(i4);
          break;
        case Node.COMMENT_NODE:
          e4.push(i4);
      }
    }
    return e4.forEach((t6) => S2(t6)), this.body;
  }
  sanitizeElement(t5) {
    return t5.hasAttribute("href") && this.forbiddenProtocols.includes(t5.protocol) && t5.removeAttribute("href"), Array.from(t5.attributes).forEach((e4) => {
      let { name: i4 } = e4;
      this.allowedAttributes.includes(i4) || 0 === i4.indexOf("data-trix") || t5.removeAttribute(i4);
    }), t5;
  }
  normalizeListElementNesting() {
    return Array.from(this.body.querySelectorAll("ul,ol")).forEach((t5) => {
      const e4 = t5.previousElementSibling;
      e4 && "li" === k3(e4) && e4.appendChild(t5);
    }), this.body;
  }
  elementIsRemovable(t5) {
    if ((null == t5 ? void 0 : t5.nodeType) === Node.ELEMENT_NODE) return this.elementIsForbidden(t5) || this.elementIsntSerializable(t5);
  }
  elementIsForbidden(t5) {
    return this.forbiddenElements.includes(k3(t5));
  }
  elementIsntSerializable(t5) {
    return "false" === t5.getAttribute("data-trix-serialize") && !P3(t5);
  }
};
var hi = function() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
  t5 = t5.replace(/<\/html[^>]*>[^]*$/i, "</html>");
  const e4 = document.implementation.createHTMLDocument("");
  return e4.documentElement.innerHTML = t5, Array.from(e4.head.querySelectorAll("style")).forEach((t6) => {
    e4.body.appendChild(t6);
  }), e4.body;
};
var { css: di } = z3;
var gi = class extends ie {
  constructor() {
    super(...arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
  }
  createContentNodes() {
    return [];
  }
  createNodes() {
    let t5;
    const e4 = t5 = T4({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), i4 = this.getHref();
    return i4 && (t5 = T4({ tagName: "a", editable: false, attributes: { href: i4, tabindex: -1 } }), e4.appendChild(t5)), this.attachment.hasContent() ? ui.setHTML(t5, this.attachment.getContent()) : this.createContentNodes().forEach((e5) => {
      t5.appendChild(e5);
    }), t5.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = T4({ tagName: "progress", attributes: { class: di.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e4.appendChild(this.progressElement)), [mi("left"), e4, mi("right")];
  }
  createCaptionElement() {
    const t5 = T4({ tagName: "figcaption", className: di.attachmentCaption }), e4 = this.attachmentPiece.getCaption();
    if (e4) t5.classList.add("".concat(di.attachmentCaption, "--edited")), t5.textContent = e4;
    else {
      let e5, i4;
      const n3 = this.getCaptionConfig();
      if (n3.name && (e5 = this.attachment.getFilename()), n3.size && (i4 = this.attachment.getFormattedFilesize()), e5) {
        const i5 = T4({ tagName: "span", className: di.attachmentName, textContent: e5 });
        t5.appendChild(i5);
      }
      if (i4) {
        e5 && t5.appendChild(document.createTextNode(" "));
        const n4 = T4({ tagName: "span", className: di.attachmentSize, textContent: i4 });
        t5.appendChild(n4);
      }
    }
    return t5;
  }
  getClassName() {
    const t5 = [di.attachment, "".concat(di.attachment, "--").concat(this.attachment.getType())], e4 = this.attachment.getExtension();
    return e4 && t5.push("".concat(di.attachment, "--").concat(e4)), t5.join(" ");
  }
  getData() {
    const t5 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, { attributes: e4 } = this.attachmentPiece;
    return e4.isEmpty() || (t5.trixAttributes = JSON.stringify(e4)), this.attachment.isPending() && (t5.trixSerialize = false), t5;
  }
  getHref() {
    if (!pi(this.attachment.getContent(), "a")) return this.attachment.getHref();
  }
  getCaptionConfig() {
    var t5;
    const e4 = this.attachment.getType(), n3 = kt(null === (t5 = i3[e4]) || void 0 === t5 ? void 0 : t5.caption);
    return "file" === e4 && (n3.name = true), n3;
  }
  findProgressElement() {
    var t5;
    return null === (t5 = this.findElement()) || void 0 === t5 ? void 0 : t5.querySelector("progress");
  }
  attachmentDidChangeUploadProgress() {
    const t5 = this.attachment.getUploadProgress(), e4 = this.findProgressElement();
    e4 && (e4.value = t5);
  }
};
var mi = (t5) => T4({ tagName: "span", textContent: d2, data: { trixCursorTarget: t5, trixSerialize: false } });
var pi = function(t5, e4) {
  const i4 = T4("div");
  return ui.setHTML(i4, t5 || ""), i4.querySelector(e4);
};
var fi = class extends gi {
  constructor() {
    super(...arguments), this.attachment.previewDelegate = this;
  }
  createContentNodes() {
    return this.image = T4({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
  }
  createCaptionElement() {
    const t5 = super.createCaptionElement(...arguments);
    return t5.textContent || t5.setAttribute("data-trix-placeholder", c3.captionPlaceholder), t5;
  }
  refresh(t5) {
    var e4;
    t5 || (t5 = null === (e4 = this.findElement()) || void 0 === e4 ? void 0 : e4.querySelector("img"));
    if (t5) return this.updateAttributesForImage(t5);
  }
  updateAttributesForImage(t5) {
    const e4 = this.attachment.getURL(), i4 = this.attachment.getPreviewURL();
    if (t5.src = i4 || e4, i4 === e4) t5.removeAttribute("data-trix-serialized-attributes");
    else {
      const i5 = JSON.stringify({ src: e4 });
      t5.setAttribute("data-trix-serialized-attributes", i5);
    }
    const n3 = this.attachment.getWidth(), r4 = this.attachment.getHeight();
    null != n3 && (t5.width = n3), null != r4 && (t5.height = r4);
    const o3 = ["imageElement", this.attachment.id, t5.src, t5.width, t5.height].join("/");
    t5.dataset.trixStoreKey = o3;
  }
  attachmentDidChangeAttributes() {
    return this.refresh(this.image), this.refresh();
  }
};
var bi = class extends ie {
  constructor() {
    super(...arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), this.textConfig = this.options.textConfig, this.context = this.options.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
  }
  createNodes() {
    let t5 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes();
    const e4 = this.createElement();
    if (e4) {
      const i4 = function(t6) {
        for (; null !== (e5 = t6) && void 0 !== e5 && e5.firstElementChild; ) {
          var e5;
          t6 = t6.firstElementChild;
        }
        return t6;
      }(e4);
      Array.from(t5).forEach((t6) => {
        i4.appendChild(t6);
      }), t5 = [e4];
    }
    return t5;
  }
  createAttachmentNodes() {
    const t5 = this.attachment.isPreviewable() ? fi : gi;
    return this.createChildView(t5, this.piece.attachment, { piece: this.piece }).getNodes();
  }
  createStringNodes() {
    var t5;
    if (null !== (t5 = this.textConfig) && void 0 !== t5 && t5.plaintext) return [document.createTextNode(this.string)];
    {
      const t6 = [], e4 = this.string.split("\n");
      for (let i4 = 0; i4 < e4.length; i4++) {
        const n3 = e4[i4];
        if (i4 > 0) {
          const e5 = T4("br");
          t6.push(e5);
        }
        if (n3.length) {
          const e5 = document.createTextNode(this.preserveSpaces(n3));
          t6.push(e5);
        }
      }
      return t6;
    }
  }
  createElement() {
    let t5, e4, i4;
    const n3 = {};
    for (e4 in this.attributes) {
      i4 = this.attributes[e4];
      const o3 = ft(e4);
      if (o3) {
        if (o3.tagName) {
          var r4;
          const e5 = T4(o3.tagName);
          r4 ? (r4.appendChild(e5), r4 = e5) : t5 = r4 = e5;
        }
        if (o3.styleProperty && (n3[o3.styleProperty] = i4), o3.style) for (e4 in o3.style) i4 = o3.style[e4], n3[e4] = i4;
      }
    }
    if (Object.keys(n3).length) for (e4 in t5 || (t5 = T4("span")), n3) i4 = n3[e4], t5.style[e4] = i4;
    return t5;
  }
  createContainerElement() {
    for (const t5 in this.attributes) {
      const e4 = this.attributes[t5], i4 = ft(t5);
      if (i4 && i4.groupTagName) {
        const n3 = {};
        return n3[t5] = e4, T4(i4.groupTagName, n3);
      }
    }
  }
  preserveSpaces(t5) {
    return this.context.isLast && (t5 = t5.replace(/\ $/, g4)), t5 = t5.replace(/(\S)\ {3}(\S)/g, "$1 ".concat(g4, " $2")).replace(/\ {2}/g, "".concat(g4, " ")).replace(/\ {2}/g, " ".concat(g4)), (this.context.isFirst || this.context.followsWhitespace) && (t5 = t5.replace(/^\ /, g4)), t5;
  }
};
var vi = class extends ie {
  constructor() {
    super(...arguments), this.text = this.object, this.textConfig = this.options.textConfig;
  }
  createNodes() {
    const t5 = [], e4 = Xt.groupObjects(this.getPieces()), i4 = e4.length - 1;
    for (let r4 = 0; r4 < e4.length; r4++) {
      const o3 = e4[r4], s4 = {};
      0 === r4 && (s4.isFirst = true), r4 === i4 && (s4.isLast = true), Ai(n3) && (s4.followsWhitespace = true);
      const a4 = this.findOrCreateCachedChildView(bi, o3, { textConfig: this.textConfig, context: s4 });
      t5.push(...Array.from(a4.getNodes() || []));
      var n3 = o3;
    }
    return t5;
  }
  getPieces() {
    return Array.from(this.text.getPieces()).filter((t5) => !t5.hasAttribute("blockBreak"));
  }
};
var Ai = (t5) => /\s$/.test(null == t5 ? void 0 : t5.toString());
var { css: yi } = z3;
var xi = class extends ie {
  constructor() {
    super(...arguments), this.block = this.object, this.attributes = this.block.getAttributes();
  }
  createNodes() {
    const t5 = [document.createComment("block")];
    if (this.block.isEmpty()) t5.push(T4("br"));
    else {
      var e4;
      const i4 = null === (e4 = mt(this.block.getLastAttribute())) || void 0 === e4 ? void 0 : e4.text, n3 = this.findOrCreateCachedChildView(vi, this.block.text, { textConfig: i4 });
      t5.push(...Array.from(n3.getNodes() || [])), this.shouldAddExtraNewlineElement() && t5.push(T4("br"));
    }
    if (this.attributes.length) return t5;
    {
      let e5;
      const { tagName: i4 } = n2.default;
      this.block.isRTL() && (e5 = { dir: "rtl" });
      const r4 = T4({ tagName: i4, attributes: e5 });
      return t5.forEach((t6) => r4.appendChild(t6)), [r4];
    }
  }
  createContainerElement(t5) {
    const e4 = {};
    let i4;
    const n3 = this.attributes[t5], { tagName: r4, htmlAttributes: o3 = [] } = mt(n3);
    if (0 === t5 && this.block.isRTL() && Object.assign(e4, { dir: "rtl" }), "attachmentGallery" === n3) {
      const t6 = this.block.getBlockBreakPosition();
      i4 = "".concat(yi.attachmentGallery, " ").concat(yi.attachmentGallery, "--").concat(t6);
    }
    return Object.entries(this.block.htmlAttributes).forEach((t6) => {
      let [i5, n4] = t6;
      o3.includes(i5) && (e4[i5] = n4);
    }), T4({ tagName: r4, className: i4, attributes: e4 });
  }
  shouldAddExtraNewlineElement() {
    return /\n\n$/.test(this.block.toString());
  }
};
var Ci = class extends ie {
  static render(t5) {
    const e4 = T4("div"), i4 = new this(t5, { element: e4 });
    return i4.render(), i4.sync(), e4;
  }
  constructor() {
    super(...arguments), this.element = this.options.element, this.elementStore = new Qt(), this.setDocument(this.object);
  }
  setDocument(t5) {
    t5.isEqualTo(this.document) || (this.document = this.object = t5);
  }
  render() {
    if (this.childViews = [], this.shadowElement = T4("div"), !this.document.isEmpty()) {
      const t5 = Xt.groupObjects(this.document.getBlocks(), { asTree: true });
      Array.from(t5).forEach((t6) => {
        const e4 = this.findOrCreateCachedChildView(xi, t6);
        Array.from(e4.getNodes()).map((t7) => this.shadowElement.appendChild(t7));
      });
    }
  }
  isSynced() {
    return Si(this.shadowElement, this.element);
  }
  sync() {
    const t5 = this.createDocumentFragmentForSync();
    for (; this.element.lastChild; ) this.element.removeChild(this.element.lastChild);
    return this.element.appendChild(t5), this.didSync();
  }
  didSync() {
    return this.elementStore.reset(Ei(this.element)), Rt(() => this.garbageCollectCachedViews());
  }
  createDocumentFragmentForSync() {
    const t5 = document.createDocumentFragment();
    return Array.from(this.shadowElement.childNodes).forEach((e4) => {
      t5.appendChild(e4.cloneNode(true));
    }), Array.from(Ei(t5)).forEach((t6) => {
      const e4 = this.elementStore.remove(t6);
      e4 && t6.parentNode.replaceChild(e4, t6);
    }), t5;
  }
};
var Ei = (t5) => t5.querySelectorAll("[data-trix-store-key]");
var Si = (t5, e4) => Ri(t5.innerHTML) === Ri(e4.innerHTML);
var Ri = (t5) => t5.replace(/&nbsp;/g, " ");
function ki(t5) {
  var e4, i4;
  function n3(e5, i5) {
    try {
      var o3 = t5[e5](i5), s4 = o3.value, a4 = s4 instanceof Ti;
      Promise.resolve(a4 ? s4.v : s4).then(function(i6) {
        if (a4) {
          var l4 = "return" === e5 ? "return" : "next";
          if (!s4.k || i6.done) return n3(l4, i6);
          i6 = t5[l4](i6).value;
        }
        r4(o3.done ? "return" : "normal", i6);
      }, function(t6) {
        n3("throw", t6);
      });
    } catch (t6) {
      r4("throw", t6);
    }
  }
  function r4(t6, r5) {
    switch (t6) {
      case "return":
        e4.resolve({ value: r5, done: true });
        break;
      case "throw":
        e4.reject(r5);
        break;
      default:
        e4.resolve({ value: r5, done: false });
    }
    (e4 = e4.next) ? n3(e4.key, e4.arg) : i4 = null;
  }
  this._invoke = function(t6, r5) {
    return new Promise(function(o3, s4) {
      var a4 = { key: t6, arg: r5, resolve: o3, reject: s4, next: null };
      i4 ? i4 = i4.next = a4 : (e4 = i4 = a4, n3(t6, r5));
    });
  }, "function" != typeof t5.return && (this.return = void 0);
}
function Ti(t5, e4) {
  this.v = t5, this.k = e4;
}
function wi(t5, e4, i4) {
  return (e4 = Li(e4)) in t5 ? Object.defineProperty(t5, e4, { value: i4, enumerable: true, configurable: true, writable: true }) : t5[e4] = i4, t5;
}
function Li(t5) {
  var e4 = function(t6, e5) {
    if ("object" != typeof t6 || null === t6) return t6;
    var i4 = t6[Symbol.toPrimitive];
    if (void 0 !== i4) {
      var n3 = i4.call(t6, e5 || "default");
      if ("object" != typeof n3) return n3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === e5 ? String : Number)(t6);
  }(t5, "string");
  return "symbol" == typeof e4 ? e4 : String(e4);
}
ki.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
  return this;
}, ki.prototype.next = function(t5) {
  return this._invoke("next", t5);
}, ki.prototype.throw = function(t5) {
  return this._invoke("throw", t5);
}, ki.prototype.return = function(t5) {
  return this._invoke("return", t5);
};
function Di(t5, e4) {
  return Oi(t5, Ii(t5, e4, "get"));
}
function Ni(t5, e4, i4) {
  return Fi(t5, Ii(t5, e4, "set"), i4), i4;
}
function Ii(t5, e4, i4) {
  if (!e4.has(t5)) throw new TypeError("attempted to " + i4 + " private field on non-instance");
  return e4.get(t5);
}
function Oi(t5, e4) {
  return e4.get ? e4.get.call(t5) : e4.value;
}
function Fi(t5, e4, i4) {
  if (e4.set) e4.set.call(t5, i4);
  else {
    if (!e4.writable) throw new TypeError("attempted to set read only private field");
    e4.value = i4;
  }
}
function Pi(t5, e4, i4) {
  if (!e4.has(t5)) throw new TypeError("attempted to get private field on non-instance");
  return i4;
}
function Mi(t5, e4) {
  if (e4.has(t5)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Bi(t5, e4, i4) {
  Mi(t5, e4), e4.set(t5, i4);
}
var _i = class extends rt {
  static registerType(t5, e4) {
    e4.type = t5, this.types[t5] = e4;
  }
  static fromJSON(t5) {
    const e4 = this.types[t5.type];
    if (e4) return e4.fromJSON(t5);
  }
  constructor(t5) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(...arguments), this.attributes = Ht.box(e4);
  }
  copyWithAttributes(t5) {
    return new this.constructor(this.getValue(), t5);
  }
  copyWithAdditionalAttributes(t5) {
    return this.copyWithAttributes(this.attributes.merge(t5));
  }
  copyWithoutAttribute(t5) {
    return this.copyWithAttributes(this.attributes.remove(t5));
  }
  copy() {
    return this.copyWithAttributes(this.attributes);
  }
  getAttribute(t5) {
    return this.attributes.get(t5);
  }
  getAttributesHash() {
    return this.attributes;
  }
  getAttributes() {
    return this.attributes.toObject();
  }
  hasAttribute(t5) {
    return this.attributes.has(t5);
  }
  hasSameStringValueAsPiece(t5) {
    return t5 && this.toString() === t5.toString();
  }
  hasSameAttributesAsPiece(t5) {
    return t5 && (this.attributes === t5.attributes || this.attributes.isEqualTo(t5.attributes));
  }
  isBlockBreak() {
    return false;
  }
  isEqualTo(t5) {
    return super.isEqualTo(...arguments) || this.hasSameConstructorAs(t5) && this.hasSameStringValueAsPiece(t5) && this.hasSameAttributesAsPiece(t5);
  }
  isEmpty() {
    return 0 === this.length;
  }
  isSerializable() {
    return true;
  }
  toJSON() {
    return { type: this.constructor.type, attributes: this.getAttributes() };
  }
  contentsForInspection() {
    return { type: this.constructor.type, attributes: this.attributes.inspect() };
  }
  canBeGrouped() {
    return this.hasAttribute("href");
  }
  canBeGroupedWith(t5) {
    return this.getAttribute("href") === t5.getAttribute("href");
  }
  getLength() {
    return this.length;
  }
  canBeConsolidatedWith(t5) {
    return false;
  }
};
wi(_i, "types", {});
var ji = class extends ee {
  constructor(t5) {
    super(...arguments), this.url = t5;
  }
  perform(t5) {
    const e4 = new Image();
    e4.onload = () => (e4.width = this.width = e4.naturalWidth, e4.height = this.height = e4.naturalHeight, t5(true, e4)), e4.onerror = () => t5(false), e4.src = this.url;
  }
};
var Wi = class _Wi extends rt {
  static attachmentForFile(t5) {
    const e4 = new this(this.attributesForFile(t5));
    return e4.setFile(t5), e4;
  }
  static attributesForFile(t5) {
    return new Ht({ filename: t5.name, filesize: t5.size, contentType: t5.type });
  }
  static fromJSON(t5) {
    return new this(t5);
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    super(t5), this.releaseFile = this.releaseFile.bind(this), this.attributes = Ht.box(t5), this.didChangeAttributes();
  }
  getAttribute(t5) {
    return this.attributes.get(t5);
  }
  hasAttribute(t5) {
    return this.attributes.has(t5);
  }
  getAttributes() {
    return this.attributes.toObject();
  }
  setAttributes() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const e4 = this.attributes.merge(t5);
    var i4, n3, r4, o3;
    if (!this.attributes.isEqualTo(e4)) return this.attributes = e4, this.didChangeAttributes(), null === (i4 = this.previewDelegate) || void 0 === i4 || null === (n3 = i4.attachmentDidChangeAttributes) || void 0 === n3 || n3.call(i4, this), null === (r4 = this.delegate) || void 0 === r4 || null === (o3 = r4.attachmentDidChangeAttributes) || void 0 === o3 ? void 0 : o3.call(r4, this);
  }
  didChangeAttributes() {
    if (this.isPreviewable()) return this.preloadURL();
  }
  isPending() {
    return null != this.file && !(this.getURL() || this.getHref());
  }
  isPreviewable() {
    return this.attributes.has("previewable") ? this.attributes.get("previewable") : _Wi.previewablePattern.test(this.getContentType());
  }
  getType() {
    return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
  }
  getURL() {
    return this.attributes.get("url");
  }
  getHref() {
    return this.attributes.get("href");
  }
  getFilename() {
    return this.attributes.get("filename") || "";
  }
  getFilesize() {
    return this.attributes.get("filesize");
  }
  getFormattedFilesize() {
    const t5 = this.attributes.get("filesize");
    return "number" == typeof t5 ? h3.formatter(t5) : "";
  }
  getExtension() {
    var t5;
    return null === (t5 = this.getFilename().match(/\.(\w+)$/)) || void 0 === t5 ? void 0 : t5[1].toLowerCase();
  }
  getContentType() {
    return this.attributes.get("contentType");
  }
  hasContent() {
    return this.attributes.has("content");
  }
  getContent() {
    return this.attributes.get("content");
  }
  getWidth() {
    return this.attributes.get("width");
  }
  getHeight() {
    return this.attributes.get("height");
  }
  getFile() {
    return this.file;
  }
  setFile(t5) {
    if (this.file = t5, this.isPreviewable()) return this.preloadFile();
  }
  releaseFile() {
    this.releasePreloadedFile(), this.file = null;
  }
  getUploadProgress() {
    return null != this.uploadProgress ? this.uploadProgress : 0;
  }
  setUploadProgress(t5) {
    var e4, i4;
    if (this.uploadProgress !== t5) return this.uploadProgress = t5, null === (e4 = this.uploadProgressDelegate) || void 0 === e4 || null === (i4 = e4.attachmentDidChangeUploadProgress) || void 0 === i4 ? void 0 : i4.call(e4, this);
  }
  toJSON() {
    return this.getAttributes();
  }
  getCacheKey() {
    return [super.getCacheKey(...arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
  }
  getPreviewURL() {
    return this.previewURL || this.preloadingURL;
  }
  setPreviewURL(t5) {
    var e4, i4, n3, r4;
    if (t5 !== this.getPreviewURL()) return this.previewURL = t5, null === (e4 = this.previewDelegate) || void 0 === e4 || null === (i4 = e4.attachmentDidChangeAttributes) || void 0 === i4 || i4.call(e4, this), null === (n3 = this.delegate) || void 0 === n3 || null === (r4 = n3.attachmentDidChangePreviewURL) || void 0 === r4 ? void 0 : r4.call(n3, this);
  }
  preloadURL() {
    return this.preload(this.getURL(), this.releaseFile);
  }
  preloadFile() {
    if (this.file) return this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL);
  }
  releasePreloadedFile() {
    this.fileObjectURL && (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null);
  }
  preload(t5, e4) {
    if (t5 && t5 !== this.getPreviewURL()) {
      this.preloadingURL = t5;
      return new ji(t5).then((i4) => {
        let { width: n3, height: r4 } = i4;
        return this.getWidth() && this.getHeight() || this.setAttributes({ width: n3, height: r4 }), this.preloadingURL = null, this.setPreviewURL(t5), null == e4 ? void 0 : e4();
      }).catch(() => (this.preloadingURL = null, null == e4 ? void 0 : e4()));
    }
  }
};
wi(Wi, "previewablePattern", /^image(\/(gif|png|webp|jpe?g)|$)/);
var Ui = class _Ui extends _i {
  static fromJSON(t5) {
    return new this(Wi.fromJSON(t5.attachment), t5.attributes);
  }
  constructor(t5) {
    super(...arguments), this.attachment = t5, this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
  }
  ensureAttachmentExclusivelyHasAttribute(t5) {
    this.hasAttribute(t5) && (this.attachment.hasAttribute(t5) || this.attachment.setAttributes(this.attributes.slice([t5])), this.attributes = this.attributes.remove(t5));
  }
  removeProhibitedAttributes() {
    const t5 = this.attributes.slice(_Ui.permittedAttributes);
    t5.isEqualTo(this.attributes) || (this.attributes = t5);
  }
  getValue() {
    return this.attachment;
  }
  isSerializable() {
    return !this.attachment.isPending();
  }
  getCaption() {
    return this.attributes.get("caption") || "";
  }
  isEqualTo(t5) {
    var e4;
    return super.isEqualTo(t5) && this.attachment.id === (null == t5 || null === (e4 = t5.attachment) || void 0 === e4 ? void 0 : e4.id);
  }
  toString() {
    return "\uFFFC";
  }
  toJSON() {
    const t5 = super.toJSON(...arguments);
    return t5.attachment = this.attachment, t5;
  }
  getCacheKey() {
    return [super.getCacheKey(...arguments), this.attachment.getCacheKey()].join("/");
  }
  toConsole() {
    return JSON.stringify(this.toString());
  }
};
wi(Ui, "permittedAttributes", ["caption", "presentation"]), _i.registerType("attachment", Ui);
var Vi = class extends _i {
  static fromJSON(t5) {
    return new this(t5.string, t5.attributes);
  }
  constructor(t5) {
    super(...arguments), this.string = ((t6) => t6.replace(/\r\n?/g, "\n"))(t5), this.length = this.string.length;
  }
  getValue() {
    return this.string;
  }
  toString() {
    return this.string.toString();
  }
  isBlockBreak() {
    return "\n" === this.toString() && true === this.getAttribute("blockBreak");
  }
  toJSON() {
    const t5 = super.toJSON(...arguments);
    return t5.string = this.string, t5;
  }
  canBeConsolidatedWith(t5) {
    return t5 && this.hasSameConstructorAs(t5) && this.hasSameAttributesAsPiece(t5);
  }
  consolidateWith(t5) {
    return new this.constructor(this.toString() + t5.toString(), this.attributes);
  }
  splitAtOffset(t5) {
    let e4, i4;
    return 0 === t5 ? (e4 = null, i4 = this) : t5 === this.length ? (e4 = this, i4 = null) : (e4 = new this.constructor(this.string.slice(0, t5), this.attributes), i4 = new this.constructor(this.string.slice(t5), this.attributes)), [e4, i4];
  }
  toConsole() {
    let { string: t5 } = this;
    return t5.length > 15 && (t5 = t5.slice(0, 14) + "\u2026"), JSON.stringify(t5.toString());
  }
};
_i.registerType("string", Vi);
var zi = class extends rt {
  static box(t5) {
    return t5 instanceof this ? t5 : new this(t5);
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    super(...arguments), this.objects = t5.slice(0), this.length = this.objects.length;
  }
  indexOf(t5) {
    return this.objects.indexOf(t5);
  }
  splice() {
    for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
    return new this.constructor(st(this.objects, ...e4));
  }
  eachObject(t5) {
    return this.objects.map((e4, i4) => t5(e4, i4));
  }
  insertObjectAtIndex(t5, e4) {
    return this.splice(e4, 0, t5);
  }
  insertSplittableListAtIndex(t5, e4) {
    return this.splice(e4, 0, ...t5.objects);
  }
  insertSplittableListAtPosition(t5, e4) {
    const [i4, n3] = this.splitObjectAtPosition(e4);
    return new this.constructor(i4).insertSplittableListAtIndex(t5, n3);
  }
  editObjectAtIndex(t5, e4) {
    return this.replaceObjectAtIndex(e4(this.objects[t5]), t5);
  }
  replaceObjectAtIndex(t5, e4) {
    return this.splice(e4, 1, t5);
  }
  removeObjectAtIndex(t5) {
    return this.splice(t5, 1);
  }
  getObjectAtIndex(t5) {
    return this.objects[t5];
  }
  getSplittableListInRange(t5) {
    const [e4, i4, n3] = this.splitObjectsAtRange(t5);
    return new this.constructor(e4.slice(i4, n3 + 1));
  }
  selectSplittableList(t5) {
    const e4 = this.objects.filter((e5) => t5(e5));
    return new this.constructor(e4);
  }
  removeObjectsInRange(t5) {
    const [e4, i4, n3] = this.splitObjectsAtRange(t5);
    return new this.constructor(e4).splice(i4, n3 - i4 + 1);
  }
  transformObjectsInRange(t5, e4) {
    const [i4, n3, r4] = this.splitObjectsAtRange(t5), o3 = i4.map((t6, i5) => n3 <= i5 && i5 <= r4 ? e4(t6) : t6);
    return new this.constructor(o3);
  }
  splitObjectsAtRange(t5) {
    let e4, [i4, n3, r4] = this.splitObjectAtPosition(Hi(t5));
    return [i4, e4] = new this.constructor(i4).splitObjectAtPosition(Ji(t5) + r4), [i4, n3, e4 - 1];
  }
  getObjectAtPosition(t5) {
    const { index: e4 } = this.findIndexAndOffsetAtPosition(t5);
    return this.objects[e4];
  }
  splitObjectAtPosition(t5) {
    let e4, i4;
    const { index: n3, offset: r4 } = this.findIndexAndOffsetAtPosition(t5), o3 = this.objects.slice(0);
    if (null != n3) if (0 === r4) e4 = n3, i4 = 0;
    else {
      const t6 = this.getObjectAtIndex(n3), [s4, a4] = t6.splitAtOffset(r4);
      o3.splice(n3, 1, s4, a4), e4 = n3 + 1, i4 = s4.getLength() - r4;
    }
    else e4 = o3.length, i4 = 0;
    return [o3, e4, i4];
  }
  consolidate() {
    const t5 = [];
    let e4 = this.objects[0];
    return this.objects.slice(1).forEach((i4) => {
      var n3, r4;
      null !== (n3 = (r4 = e4).canBeConsolidatedWith) && void 0 !== n3 && n3.call(r4, i4) ? e4 = e4.consolidateWith(i4) : (t5.push(e4), e4 = i4);
    }), e4 && t5.push(e4), new this.constructor(t5);
  }
  consolidateFromIndexToIndex(t5, e4) {
    const i4 = this.objects.slice(0).slice(t5, e4 + 1), n3 = new this.constructor(i4).consolidate().toArray();
    return this.splice(t5, i4.length, ...n3);
  }
  findIndexAndOffsetAtPosition(t5) {
    let e4, i4 = 0;
    for (e4 = 0; e4 < this.objects.length; e4++) {
      const n3 = i4 + this.objects[e4].getLength();
      if (i4 <= t5 && t5 < n3) return { index: e4, offset: t5 - i4 };
      i4 = n3;
    }
    return { index: null, offset: null };
  }
  findPositionAtIndexAndOffset(t5, e4) {
    let i4 = 0;
    for (let n3 = 0; n3 < this.objects.length; n3++) {
      const r4 = this.objects[n3];
      if (n3 < t5) i4 += r4.getLength();
      else if (n3 === t5) {
        i4 += e4;
        break;
      }
    }
    return i4;
  }
  getEndPosition() {
    return null == this.endPosition && (this.endPosition = 0, this.objects.forEach((t5) => this.endPosition += t5.getLength())), this.endPosition;
  }
  toString() {
    return this.objects.join("");
  }
  toArray() {
    return this.objects.slice(0);
  }
  toJSON() {
    return this.toArray();
  }
  isEqualTo(t5) {
    return super.isEqualTo(...arguments) || qi(this.objects, null == t5 ? void 0 : t5.objects);
  }
  contentsForInspection() {
    return { objects: "[".concat(this.objects.map((t5) => t5.inspect()).join(", "), "]") };
  }
};
var qi = function(t5) {
  let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  if (t5.length !== e4.length) return false;
  let i4 = true;
  for (let n3 = 0; n3 < t5.length; n3++) {
    const r4 = t5[n3];
    i4 && !r4.isEqualTo(e4[n3]) && (i4 = false);
  }
  return i4;
};
var Hi = (t5) => t5[0];
var Ji = (t5) => t5[1];
var Ki = class extends rt {
  static textForAttachmentWithAttributes(t5, e4) {
    return new this([new Ui(t5, e4)]);
  }
  static textForStringWithAttributes(t5, e4) {
    return new this([new Vi(t5, e4)]);
  }
  static fromJSON(t5) {
    return new this(Array.from(t5).map((t6) => _i.fromJSON(t6)));
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    super(...arguments);
    const e4 = t5.filter((t6) => !t6.isEmpty());
    this.pieceList = new zi(e4);
  }
  copy() {
    return this.copyWithPieceList(this.pieceList);
  }
  copyWithPieceList(t5) {
    return new this.constructor(t5.consolidate().toArray());
  }
  copyUsingObjectMap(t5) {
    const e4 = this.getPieces().map((e5) => t5.find(e5) || e5);
    return new this.constructor(e4);
  }
  appendText(t5) {
    return this.insertTextAtPosition(t5, this.getLength());
  }
  insertTextAtPosition(t5, e4) {
    return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t5.pieceList, e4));
  }
  removeTextAtRange(t5) {
    return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t5));
  }
  replaceTextAtRange(t5, e4) {
    return this.removeTextAtRange(e4).insertTextAtPosition(t5, e4[0]);
  }
  moveTextFromRangeToPosition(t5, e4) {
    if (t5[0] <= e4 && e4 <= t5[1]) return;
    const i4 = this.getTextAtRange(t5), n3 = i4.getLength();
    return t5[0] < e4 && (e4 -= n3), this.removeTextAtRange(t5).insertTextAtPosition(i4, e4);
  }
  addAttributeAtRange(t5, e4, i4) {
    const n3 = {};
    return n3[t5] = e4, this.addAttributesAtRange(n3, i4);
  }
  addAttributesAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAdditionalAttributes(t5)));
  }
  removeAttributeAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithoutAttribute(t5)));
  }
  setAttributesAtRange(t5, e4) {
    return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e4, (e5) => e5.copyWithAttributes(t5)));
  }
  getAttributesAtPosition(t5) {
    var e4;
    return (null === (e4 = this.pieceList.getObjectAtPosition(t5)) || void 0 === e4 ? void 0 : e4.getAttributes()) || {};
  }
  getCommonAttributes() {
    const t5 = Array.from(this.pieceList.toArray()).map((t6) => t6.getAttributes());
    return Ht.fromCommonAttributesOfObjects(t5).toObject();
  }
  getCommonAttributesAtRange(t5) {
    return this.getTextAtRange(t5).getCommonAttributes() || {};
  }
  getExpandedRangeForAttributeAtOffset(t5, e4) {
    let i4, n3 = i4 = e4;
    const r4 = this.getLength();
    for (; n3 > 0 && this.getCommonAttributesAtRange([n3 - 1, i4])[t5]; ) n3--;
    for (; i4 < r4 && this.getCommonAttributesAtRange([e4, i4 + 1])[t5]; ) i4++;
    return [n3, i4];
  }
  getTextAtRange(t5) {
    return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t5));
  }
  getStringAtRange(t5) {
    return this.pieceList.getSplittableListInRange(t5).toString();
  }
  getStringAtPosition(t5) {
    return this.getStringAtRange([t5, t5 + 1]);
  }
  startsWithString(t5) {
    return this.getStringAtRange([0, t5.length]) === t5;
  }
  endsWithString(t5) {
    const e4 = this.getLength();
    return this.getStringAtRange([e4 - t5.length, e4]) === t5;
  }
  getAttachmentPieces() {
    return this.pieceList.toArray().filter((t5) => !!t5.attachment);
  }
  getAttachments() {
    return this.getAttachmentPieces().map((t5) => t5.attachment);
  }
  getAttachmentAndPositionById(t5) {
    let e4 = 0;
    for (const n3 of this.pieceList.toArray()) {
      var i4;
      if ((null === (i4 = n3.attachment) || void 0 === i4 ? void 0 : i4.id) === t5) return { attachment: n3.attachment, position: e4 };
      e4 += n3.length;
    }
    return { attachment: null, position: null };
  }
  getAttachmentById(t5) {
    const { attachment: e4 } = this.getAttachmentAndPositionById(t5);
    return e4;
  }
  getRangeOfAttachment(t5) {
    const e4 = this.getAttachmentAndPositionById(t5.id), i4 = e4.position;
    if (t5 = e4.attachment) return [i4, i4 + 1];
  }
  updateAttributesForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4);
    return i4 ? this.addAttributesAtRange(t5, i4) : this;
  }
  getLength() {
    return this.pieceList.getEndPosition();
  }
  isEmpty() {
    return 0 === this.getLength();
  }
  isEqualTo(t5) {
    var e4;
    return super.isEqualTo(t5) || (null == t5 || null === (e4 = t5.pieceList) || void 0 === e4 ? void 0 : e4.isEqualTo(this.pieceList));
  }
  isBlockBreak() {
    return 1 === this.getLength() && this.pieceList.getObjectAtIndex(0).isBlockBreak();
  }
  eachPiece(t5) {
    return this.pieceList.eachObject(t5);
  }
  getPieces() {
    return this.pieceList.toArray();
  }
  getPieceAtPosition(t5) {
    return this.pieceList.getObjectAtPosition(t5);
  }
  contentsForInspection() {
    return { pieceList: this.pieceList.inspect() };
  }
  toSerializableText() {
    const t5 = this.pieceList.selectSplittableList((t6) => t6.isSerializable());
    return this.copyWithPieceList(t5);
  }
  toString() {
    return this.pieceList.toString();
  }
  toJSON() {
    return this.pieceList.toJSON();
  }
  toConsole() {
    return JSON.stringify(this.pieceList.toArray().map((t5) => JSON.parse(t5.toConsole())));
  }
  getDirection() {
    return lt(this.toString());
  }
  isRTL() {
    return "rtl" === this.getDirection();
  }
};
var Gi = class _Gi extends rt {
  static fromJSON(t5) {
    return new this(Ki.fromJSON(t5.text), t5.attributes, t5.htmlAttributes);
  }
  constructor(t5, e4, i4) {
    super(...arguments), this.text = Yi(t5 || new Ki()), this.attributes = e4 || [], this.htmlAttributes = i4 || {};
  }
  isEmpty() {
    return this.text.isBlockBreak();
  }
  isEqualTo(t5) {
    return !!super.isEqualTo(t5) || this.text.isEqualTo(null == t5 ? void 0 : t5.text) && ot(this.attributes, null == t5 ? void 0 : t5.attributes) && Tt(this.htmlAttributes, null == t5 ? void 0 : t5.htmlAttributes);
  }
  copyWithText(t5) {
    return new _Gi(t5, this.attributes, this.htmlAttributes);
  }
  copyWithoutText() {
    return this.copyWithText(null);
  }
  copyWithAttributes(t5) {
    return new _Gi(this.text, t5, this.htmlAttributes);
  }
  copyWithoutAttributes() {
    return this.copyWithAttributes(null);
  }
  copyUsingObjectMap(t5) {
    const e4 = t5.find(this.text);
    return e4 ? this.copyWithText(e4) : this.copyWithText(this.text.copyUsingObjectMap(t5));
  }
  addAttribute(t5) {
    const e4 = this.attributes.concat(en2(t5));
    return this.copyWithAttributes(e4);
  }
  addHTMLAttribute(t5, e4) {
    const i4 = Object.assign({}, this.htmlAttributes, { [t5]: e4 });
    return new _Gi(this.text, this.attributes, i4);
  }
  removeAttribute(t5) {
    const { listAttribute: e4 } = mt(t5), i4 = rn(rn(this.attributes, t5), e4);
    return this.copyWithAttributes(i4);
  }
  removeLastAttribute() {
    return this.removeAttribute(this.getLastAttribute());
  }
  getLastAttribute() {
    return nn2(this.attributes);
  }
  getAttributes() {
    return this.attributes.slice(0);
  }
  getAttributeLevel() {
    return this.attributes.length;
  }
  getAttributeAtLevel(t5) {
    return this.attributes[t5 - 1];
  }
  hasAttribute(t5) {
    return this.attributes.includes(t5);
  }
  hasAttributes() {
    return this.getAttributeLevel() > 0;
  }
  getLastNestableAttribute() {
    return nn2(this.getNestableAttributes());
  }
  getNestableAttributes() {
    return this.attributes.filter((t5) => mt(t5).nestable);
  }
  getNestingLevel() {
    return this.getNestableAttributes().length;
  }
  decreaseNestingLevel() {
    const t5 = this.getLastNestableAttribute();
    return t5 ? this.removeAttribute(t5) : this;
  }
  increaseNestingLevel() {
    const t5 = this.getLastNestableAttribute();
    if (t5) {
      const e4 = this.attributes.lastIndexOf(t5), i4 = st(this.attributes, e4 + 1, 0, ...en2(t5));
      return this.copyWithAttributes(i4);
    }
    return this;
  }
  getListItemAttributes() {
    return this.attributes.filter((t5) => mt(t5).listAttribute);
  }
  isListItem() {
    var t5;
    return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.listAttribute;
  }
  isTerminalBlock() {
    var t5;
    return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.terminal;
  }
  breaksOnReturn() {
    var t5;
    return null === (t5 = mt(this.getLastAttribute())) || void 0 === t5 ? void 0 : t5.breakOnReturn;
  }
  findLineBreakInDirectionFromPosition(t5, e4) {
    const i4 = this.toString();
    let n3;
    switch (t5) {
      case "forward":
        n3 = i4.indexOf("\n", e4);
        break;
      case "backward":
        n3 = i4.slice(0, e4).lastIndexOf("\n");
    }
    if (-1 !== n3) return n3;
  }
  contentsForInspection() {
    return { text: this.text.inspect(), attributes: this.attributes };
  }
  toString() {
    return this.text.toString();
  }
  toJSON() {
    return { text: this.text, attributes: this.attributes, htmlAttributes: this.htmlAttributes };
  }
  getDirection() {
    return this.text.getDirection();
  }
  isRTL() {
    return this.text.isRTL();
  }
  getLength() {
    return this.text.getLength();
  }
  canBeConsolidatedWith(t5) {
    return !this.hasAttributes() && !t5.hasAttributes() && this.getDirection() === t5.getDirection();
  }
  consolidateWith(t5) {
    const e4 = Ki.textForStringWithAttributes("\n"), i4 = this.getTextWithoutBlockBreak().appendText(e4);
    return this.copyWithText(i4.appendText(t5.text));
  }
  splitAtOffset(t5) {
    let e4, i4;
    return 0 === t5 ? (e4 = null, i4 = this) : t5 === this.getLength() ? (e4 = this, i4 = null) : (e4 = this.copyWithText(this.text.getTextAtRange([0, t5])), i4 = this.copyWithText(this.text.getTextAtRange([t5, this.getLength()]))), [e4, i4];
  }
  getBlockBreakPosition() {
    return this.text.getLength() - 1;
  }
  getTextWithoutBlockBreak() {
    return Qi(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
  }
  canBeGrouped(t5) {
    return this.attributes[t5];
  }
  canBeGroupedWith(t5, e4) {
    const i4 = t5.getAttributes(), r4 = i4[e4], o3 = this.attributes[e4];
    return o3 === r4 && !(false === mt(o3).group && !(() => {
      if (!dt) {
        dt = [];
        for (const t6 in n2) {
          const { listAttribute: e5 } = n2[t6];
          null != e5 && dt.push(e5);
        }
      }
      return dt;
    })().includes(i4[e4 + 1])) && (this.getDirection() === t5.getDirection() || t5.isEmpty());
  }
};
var Yi = function(t5) {
  return t5 = $i(t5), t5 = Zi(t5);
};
var $i = function(t5) {
  let e4 = false;
  const i4 = t5.getPieces();
  let n3 = i4.slice(0, i4.length - 1);
  const r4 = i4[i4.length - 1];
  return r4 ? (n3 = n3.map((t6) => t6.isBlockBreak() ? (e4 = true, tn2(t6)) : t6), e4 ? new Ki([...n3, r4]) : t5) : t5;
};
var Xi = Ki.textForStringWithAttributes("\n", { blockBreak: true });
var Zi = function(t5) {
  return Qi(t5) ? t5 : t5.appendText(Xi);
};
var Qi = function(t5) {
  const e4 = t5.getLength();
  if (0 === e4) return false;
  return t5.getTextAtRange([e4 - 1, e4]).isBlockBreak();
};
var tn2 = (t5) => t5.copyWithoutAttribute("blockBreak");
var en2 = function(t5) {
  const { listAttribute: e4 } = mt(t5);
  return e4 ? [e4, t5] : [t5];
};
var nn2 = (t5) => t5.slice(-1)[0];
var rn = function(t5, e4) {
  const i4 = t5.lastIndexOf(e4);
  return -1 === i4 ? t5 : st(t5, i4, 1);
};
var on = class extends rt {
  static fromJSON(t5) {
    return new this(Array.from(t5).map((t6) => Gi.fromJSON(t6)));
  }
  static fromString(t5, e4) {
    const i4 = Ki.textForStringWithAttributes(t5, e4);
    return new this([new Gi(i4)]);
  }
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    super(...arguments), 0 === t5.length && (t5 = [new Gi()]), this.blockList = zi.box(t5);
  }
  isEmpty() {
    const t5 = this.getBlockAtIndex(0);
    return 1 === this.blockList.length && t5.isEmpty() && !t5.hasAttributes();
  }
  copy() {
    const t5 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray();
    return new this.constructor(t5);
  }
  copyUsingObjectsFromDocument(t5) {
    const e4 = new Zt(t5.getObjects());
    return this.copyUsingObjectMap(e4);
  }
  copyUsingObjectMap(t5) {
    const e4 = this.getBlocks().map((e5) => t5.find(e5) || e5.copyUsingObjectMap(t5));
    return new this.constructor(e4);
  }
  copyWithBaseBlockAttributes() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    const e4 = this.getBlocks().map((e5) => {
      const i4 = t5.concat(e5.getAttributes());
      return e5.copyWithAttributes(i4);
    });
    return new this.constructor(e4);
  }
  replaceBlock(t5, e4) {
    const i4 = this.blockList.indexOf(t5);
    return -1 === i4 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e4, i4));
  }
  insertDocumentAtRange(t5, e4) {
    const { blockList: i4 } = t5;
    e4 = wt(e4);
    let [n3] = e4;
    const { index: r4, offset: o3 } = this.locationFromPosition(n3);
    let s4 = this;
    const a4 = this.getBlockAtPosition(n3);
    return Lt(e4) && a4.isEmpty() && !a4.hasAttributes() ? s4 = new this.constructor(s4.blockList.removeObjectAtIndex(r4)) : a4.getBlockBreakPosition() === o3 && n3++, s4 = s4.removeTextAtRange(e4), new this.constructor(s4.blockList.insertSplittableListAtPosition(i4, n3));
  }
  mergeDocumentAtRange(t5, e4) {
    let i4, n3;
    e4 = wt(e4);
    const [r4] = e4, o3 = this.locationFromPosition(r4), s4 = this.getBlockAtIndex(o3.index).getAttributes(), a4 = t5.getBaseBlockAttributes(), l4 = s4.slice(-a4.length);
    if (ot(a4, l4)) {
      const e5 = s4.slice(0, -a4.length);
      i4 = t5.copyWithBaseBlockAttributes(e5);
    } else i4 = t5.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(s4);
    const c4 = i4.getBlockCount(), u4 = i4.getBlockAtIndex(0);
    if (ot(s4, u4.getAttributes())) {
      const t6 = u4.getTextWithoutBlockBreak();
      if (n3 = this.insertTextAtRange(t6, e4), c4 > 1) {
        i4 = new this.constructor(i4.getBlocks().slice(1));
        const e5 = r4 + t6.getLength();
        n3 = n3.insertDocumentAtRange(i4, e5);
      }
    } else n3 = this.insertDocumentAtRange(i4, e4);
    return n3;
  }
  insertTextAtRange(t5, e4) {
    e4 = wt(e4);
    const [i4] = e4, { index: n3, offset: r4 } = this.locationFromPosition(i4), o3 = this.removeTextAtRange(e4);
    return new this.constructor(o3.blockList.editObjectAtIndex(n3, (e5) => e5.copyWithText(e5.text.insertTextAtPosition(t5, r4))));
  }
  removeTextAtRange(t5) {
    let e4;
    t5 = wt(t5);
    const [i4, n3] = t5;
    if (Lt(t5)) return this;
    const [r4, o3] = Array.from(this.locationRangeFromRange(t5)), s4 = r4.index, a4 = r4.offset, l4 = this.getBlockAtIndex(s4), c4 = o3.index, u4 = o3.offset, h4 = this.getBlockAtIndex(c4);
    if (n3 - i4 == 1 && l4.getBlockBreakPosition() === a4 && h4.getBlockBreakPosition() !== u4 && "\n" === h4.text.getStringAtPosition(u4)) e4 = this.blockList.editObjectAtIndex(c4, (t6) => t6.copyWithText(t6.text.removeTextAtRange([u4, u4 + 1])));
    else {
      let t6;
      const i5 = l4.text.getTextAtRange([0, a4]), n4 = h4.text.getTextAtRange([u4, h4.getLength()]), r5 = i5.appendText(n4);
      t6 = s4 !== c4 && 0 === a4 && l4.getAttributeLevel() >= h4.getAttributeLevel() ? h4.copyWithText(r5) : l4.copyWithText(r5);
      const o4 = c4 + 1 - s4;
      e4 = this.blockList.splice(s4, o4, t6);
    }
    return new this.constructor(e4);
  }
  moveTextFromRangeToPosition(t5, e4) {
    let i4;
    t5 = wt(t5);
    const [n3, r4] = t5;
    if (n3 <= e4 && e4 <= r4) return this;
    let o3 = this.getDocumentAtRange(t5), s4 = this.removeTextAtRange(t5);
    const a4 = n3 < e4;
    a4 && (e4 -= o3.getLength());
    const [l4, ...c4] = o3.getBlocks();
    return 0 === c4.length ? (i4 = l4.getTextWithoutBlockBreak(), a4 && (e4 += 1)) : i4 = l4.text, s4 = s4.insertTextAtRange(i4, e4), 0 === c4.length ? s4 : (o3 = new this.constructor(c4), e4 += i4.getLength(), s4.insertDocumentAtRange(o3, e4));
  }
  addAttributeAtRange(t5, e4, i4) {
    let { blockList: n3 } = this;
    return this.eachBlockAtRange(i4, (i5, r4, o3) => n3 = n3.editObjectAtIndex(o3, function() {
      return mt(t5) ? i5.addAttribute(t5, e4) : r4[0] === r4[1] ? i5 : i5.copyWithText(i5.text.addAttributeAtRange(t5, e4, r4));
    })), new this.constructor(n3);
  }
  addAttribute(t5, e4) {
    let { blockList: i4 } = this;
    return this.eachBlock((n3, r4) => i4 = i4.editObjectAtIndex(r4, () => n3.addAttribute(t5, e4))), new this.constructor(i4);
  }
  removeAttributeAtRange(t5, e4) {
    let { blockList: i4 } = this;
    return this.eachBlockAtRange(e4, function(e5, n3, r4) {
      mt(t5) ? i4 = i4.editObjectAtIndex(r4, () => e5.removeAttribute(t5)) : n3[0] !== n3[1] && (i4 = i4.editObjectAtIndex(r4, () => e5.copyWithText(e5.text.removeAttributeAtRange(t5, n3))));
    }), new this.constructor(i4);
  }
  updateAttributesForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4), [n3] = Array.from(i4), { index: r4 } = this.locationFromPosition(n3), o3 = this.getTextAtIndex(r4);
    return new this.constructor(this.blockList.editObjectAtIndex(r4, (i5) => i5.copyWithText(o3.updateAttributesForAttachment(t5, e4))));
  }
  removeAttributeForAttachment(t5, e4) {
    const i4 = this.getRangeOfAttachment(e4);
    return this.removeAttributeAtRange(t5, i4);
  }
  setHTMLAttributeAtPosition(t5, e4, i4) {
    const n3 = this.getBlockAtPosition(t5), r4 = n3.addHTMLAttribute(e4, i4);
    return this.replaceBlock(n3, r4);
  }
  insertBlockBreakAtRange(t5) {
    let e4;
    t5 = wt(t5);
    const [i4] = t5, { offset: n3 } = this.locationFromPosition(i4), r4 = this.removeTextAtRange(t5);
    return 0 === n3 && (e4 = [new Gi()]), new this.constructor(r4.blockList.insertSplittableListAtPosition(new zi(e4), i4));
  }
  applyBlockAttributeAtRange(t5, e4, i4) {
    const n3 = this.expandRangeToLineBreaksAndSplitBlocks(i4);
    let r4 = n3.document;
    i4 = n3.range;
    const o3 = mt(t5);
    if (o3.listAttribute) {
      r4 = r4.removeLastListAttributeAtRange(i4, { exceptAttributeName: t5 });
      const e5 = r4.convertLineBreaksToBlockBreaksInRange(i4);
      r4 = e5.document, i4 = e5.range;
    } else r4 = o3.exclusive ? r4.removeBlockAttributesAtRange(i4) : o3.terminal ? r4.removeLastTerminalAttributeAtRange(i4) : r4.consolidateBlocksAtRange(i4);
    return r4.addAttributeAtRange(t5, e4, i4);
  }
  removeLastListAttributeAtRange(t5) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { blockList: i4 } = this;
    return this.eachBlockAtRange(t5, function(t6, n3, r4) {
      const o3 = t6.getLastAttribute();
      o3 && mt(o3).listAttribute && o3 !== e4.exceptAttributeName && (i4 = i4.editObjectAtIndex(r4, () => t6.removeAttribute(o3)));
    }), new this.constructor(i4);
  }
  removeLastTerminalAttributeAtRange(t5) {
    let { blockList: e4 } = this;
    return this.eachBlockAtRange(t5, function(t6, i4, n3) {
      const r4 = t6.getLastAttribute();
      r4 && mt(r4).terminal && (e4 = e4.editObjectAtIndex(n3, () => t6.removeAttribute(r4)));
    }), new this.constructor(e4);
  }
  removeBlockAttributesAtRange(t5) {
    let { blockList: e4 } = this;
    return this.eachBlockAtRange(t5, function(t6, i4, n3) {
      t6.hasAttributes() && (e4 = e4.editObjectAtIndex(n3, () => t6.copyWithoutAttributes()));
    }), new this.constructor(e4);
  }
  expandRangeToLineBreaksAndSplitBlocks(t5) {
    let e4;
    t5 = wt(t5);
    let [i4, n3] = t5;
    const r4 = this.locationFromPosition(i4), o3 = this.locationFromPosition(n3);
    let s4 = this;
    const a4 = s4.getBlockAtIndex(r4.index);
    if (r4.offset = a4.findLineBreakInDirectionFromPosition("backward", r4.offset), null != r4.offset && (e4 = s4.positionFromLocation(r4), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]), o3.index += 1, o3.offset -= s4.getBlockAtIndex(r4.index).getLength(), r4.index += 1), r4.offset = 0, 0 === o3.offset && o3.index > r4.index) o3.index -= 1, o3.offset = s4.getBlockAtIndex(o3.index).getBlockBreakPosition();
    else {
      const t6 = s4.getBlockAtIndex(o3.index);
      "\n" === t6.text.getStringAtRange([o3.offset - 1, o3.offset]) ? o3.offset -= 1 : o3.offset = t6.findLineBreakInDirectionFromPosition("forward", o3.offset), o3.offset !== t6.getBlockBreakPosition() && (e4 = s4.positionFromLocation(o3), s4 = s4.insertBlockBreakAtRange([e4, e4 + 1]));
    }
    return i4 = s4.positionFromLocation(r4), n3 = s4.positionFromLocation(o3), { document: s4, range: t5 = wt([i4, n3]) };
  }
  convertLineBreaksToBlockBreaksInRange(t5) {
    t5 = wt(t5);
    let [e4] = t5;
    const i4 = this.getStringAtRange(t5).slice(0, -1);
    let n3 = this;
    return i4.replace(/.*?\n/g, function(t6) {
      e4 += t6.length, n3 = n3.insertBlockBreakAtRange([e4 - 1, e4]);
    }), { document: n3, range: t5 };
  }
  consolidateBlocksAtRange(t5) {
    t5 = wt(t5);
    const [e4, i4] = t5, n3 = this.locationFromPosition(e4).index, r4 = this.locationFromPosition(i4).index;
    return new this.constructor(this.blockList.consolidateFromIndexToIndex(n3, r4));
  }
  getDocumentAtRange(t5) {
    t5 = wt(t5);
    const e4 = this.blockList.getSplittableListInRange(t5).toArray();
    return new this.constructor(e4);
  }
  getStringAtRange(t5) {
    let e4;
    const i4 = t5 = wt(t5);
    return i4[i4.length - 1] !== this.getLength() && (e4 = -1), this.getDocumentAtRange(t5).toString().slice(0, e4);
  }
  getBlockAtIndex(t5) {
    return this.blockList.getObjectAtIndex(t5);
  }
  getBlockAtPosition(t5) {
    const { index: e4 } = this.locationFromPosition(t5);
    return this.getBlockAtIndex(e4);
  }
  getTextAtIndex(t5) {
    var e4;
    return null === (e4 = this.getBlockAtIndex(t5)) || void 0 === e4 ? void 0 : e4.text;
  }
  getTextAtPosition(t5) {
    const { index: e4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4);
  }
  getPieceAtPosition(t5) {
    const { index: e4, offset: i4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4).getPieceAtPosition(i4);
  }
  getCharacterAtPosition(t5) {
    const { index: e4, offset: i4 } = this.locationFromPosition(t5);
    return this.getTextAtIndex(e4).getStringAtRange([i4, i4 + 1]);
  }
  getLength() {
    return this.blockList.getEndPosition();
  }
  getBlocks() {
    return this.blockList.toArray();
  }
  getBlockCount() {
    return this.blockList.length;
  }
  getEditCount() {
    return this.editCount;
  }
  eachBlock(t5) {
    return this.blockList.eachObject(t5);
  }
  eachBlockAtRange(t5, e4) {
    let i4, n3;
    t5 = wt(t5);
    const [r4, o3] = t5, s4 = this.locationFromPosition(r4), a4 = this.locationFromPosition(o3);
    if (s4.index === a4.index) return i4 = this.getBlockAtIndex(s4.index), n3 = [s4.offset, a4.offset], e4(i4, n3, s4.index);
    for (let t6 = s4.index; t6 <= a4.index; t6++) if (i4 = this.getBlockAtIndex(t6), i4) {
      switch (t6) {
        case s4.index:
          n3 = [s4.offset, i4.text.getLength()];
          break;
        case a4.index:
          n3 = [0, a4.offset];
          break;
        default:
          n3 = [0, i4.text.getLength()];
      }
      e4(i4, n3, t6);
    }
  }
  getCommonAttributesAtRange(t5) {
    t5 = wt(t5);
    const [e4] = t5;
    if (Lt(t5)) return this.getCommonAttributesAtPosition(e4);
    {
      const e5 = [], i4 = [];
      return this.eachBlockAtRange(t5, function(t6, n3) {
        if (n3[0] !== n3[1]) return e5.push(t6.text.getCommonAttributesAtRange(n3)), i4.push(sn(t6));
      }), Ht.fromCommonAttributesOfObjects(e5).merge(Ht.fromCommonAttributesOfObjects(i4)).toObject();
    }
  }
  getCommonAttributesAtPosition(t5) {
    let e4, i4;
    const { index: n3, offset: r4 } = this.locationFromPosition(t5), o3 = this.getBlockAtIndex(n3);
    if (!o3) return {};
    const s4 = sn(o3), a4 = o3.text.getAttributesAtPosition(r4), l4 = o3.text.getAttributesAtPosition(r4 - 1), c4 = Object.keys(W2).filter((t6) => W2[t6].inheritable);
    for (e4 in l4) i4 = l4[e4], (i4 === a4[e4] || c4.includes(e4)) && (s4[e4] = i4);
    return s4;
  }
  getRangeOfCommonAttributeAtPosition(t5, e4) {
    const { index: i4, offset: n3 } = this.locationFromPosition(e4), r4 = this.getTextAtIndex(i4), [o3, s4] = Array.from(r4.getExpandedRangeForAttributeAtOffset(t5, n3)), a4 = this.positionFromLocation({ index: i4, offset: o3 }), l4 = this.positionFromLocation({ index: i4, offset: s4 });
    return wt([a4, l4]);
  }
  getBaseBlockAttributes() {
    let t5 = this.getBlockAtIndex(0).getAttributes();
    for (let e4 = 1; e4 < this.getBlockCount(); e4++) {
      const i4 = this.getBlockAtIndex(e4).getAttributes(), n3 = Math.min(t5.length, i4.length);
      t5 = (() => {
        const e5 = [];
        for (let r4 = 0; r4 < n3 && i4[r4] === t5[r4]; r4++) e5.push(i4[r4]);
        return e5;
      })();
    }
    return t5;
  }
  getAttachmentById(t5) {
    for (const e4 of this.getAttachments()) if (e4.id === t5) return e4;
  }
  getAttachmentPieces() {
    let t5 = [];
    return this.blockList.eachObject((e4) => {
      let { text: i4 } = e4;
      return t5 = t5.concat(i4.getAttachmentPieces());
    }), t5;
  }
  getAttachments() {
    return this.getAttachmentPieces().map((t5) => t5.attachment);
  }
  getRangeOfAttachment(t5) {
    let e4 = 0;
    const i4 = this.blockList.toArray();
    for (let n3 = 0; n3 < i4.length; n3++) {
      const { text: r4 } = i4[n3], o3 = r4.getRangeOfAttachment(t5);
      if (o3) return wt([e4 + o3[0], e4 + o3[1]]);
      e4 += r4.getLength();
    }
  }
  getLocationRangeOfAttachment(t5) {
    const e4 = this.getRangeOfAttachment(t5);
    return this.locationRangeFromRange(e4);
  }
  getAttachmentPieceForAttachment(t5) {
    for (const e4 of this.getAttachmentPieces()) if (e4.attachment === t5) return e4;
  }
  findRangesForBlockAttribute(t5) {
    let e4 = 0;
    const i4 = [];
    return this.getBlocks().forEach((n3) => {
      const r4 = n3.getLength();
      n3.hasAttribute(t5) && i4.push([e4, e4 + r4]), e4 += r4;
    }), i4;
  }
  findRangesForTextAttribute(t5) {
    let { withValue: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i4 = 0, n3 = [];
    const r4 = [];
    return this.getPieces().forEach((o3) => {
      const s4 = o3.getLength();
      (function(i5) {
        return e4 ? i5.getAttribute(t5) === e4 : i5.hasAttribute(t5);
      })(o3) && (n3[1] === i4 ? n3[1] = i4 + s4 : r4.push(n3 = [i4, i4 + s4])), i4 += s4;
    }), r4;
  }
  locationFromPosition(t5) {
    const e4 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t5));
    if (null != e4.index) return e4;
    {
      const t6 = this.getBlocks();
      return { index: t6.length - 1, offset: t6[t6.length - 1].getLength() };
    }
  }
  positionFromLocation(t5) {
    return this.blockList.findPositionAtIndexAndOffset(t5.index, t5.offset);
  }
  locationRangeFromPosition(t5) {
    return wt(this.locationFromPosition(t5));
  }
  locationRangeFromRange(t5) {
    if (!(t5 = wt(t5))) return;
    const [e4, i4] = Array.from(t5), n3 = this.locationFromPosition(e4), r4 = this.locationFromPosition(i4);
    return wt([n3, r4]);
  }
  rangeFromLocationRange(t5) {
    let e4;
    t5 = wt(t5);
    const i4 = this.positionFromLocation(t5[0]);
    return Lt(t5) || (e4 = this.positionFromLocation(t5[1])), wt([i4, e4]);
  }
  isEqualTo(t5) {
    return this.blockList.isEqualTo(null == t5 ? void 0 : t5.blockList);
  }
  getTexts() {
    return this.getBlocks().map((t5) => t5.text);
  }
  getPieces() {
    const t5 = [];
    return Array.from(this.getTexts()).forEach((e4) => {
      t5.push(...Array.from(e4.getPieces() || []));
    }), t5;
  }
  getObjects() {
    return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
  }
  toSerializableDocument() {
    const t5 = [];
    return this.blockList.eachObject((e4) => t5.push(e4.copyWithText(e4.text.toSerializableText()))), new this.constructor(t5);
  }
  toString() {
    return this.blockList.toString();
  }
  toJSON() {
    return this.blockList.toJSON();
  }
  toConsole() {
    return JSON.stringify(this.blockList.toArray().map((t5) => JSON.parse(t5.text.toConsole())));
  }
};
var sn = function(t5) {
  const e4 = {}, i4 = t5.getLastAttribute();
  return i4 && (e4[i4] = true), e4;
};
var an = function(t5) {
  let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return { string: t5 = Wt(t5), attributes: e4, type: "string" };
};
var ln = (t5, e4) => {
  try {
    return JSON.parse(t5.getAttribute("data-trix-".concat(e4)));
  } catch (t6) {
    return {};
  }
};
var cn = class extends q3 {
  static parse(t5, e4) {
    const i4 = new this(t5, e4);
    return i4.parse(), i4;
  }
  constructor(t5) {
    let { referenceElement: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    super(...arguments), this.html = t5, this.referenceElement = e4, this.blocks = [], this.blockElements = [], this.processedElements = [];
  }
  getDocument() {
    return on.fromJSON(this.blocks);
  }
  parse() {
    try {
      this.createHiddenContainer(), ui.setHTML(this.containerElement, this.html);
      const t5 = R(this.containerElement, { usingFilter: gn });
      for (; t5.nextNode(); ) this.processNode(t5.currentNode);
      return this.translateBlockElementMarginsToNewlines();
    } finally {
      this.removeHiddenContainer();
    }
  }
  createHiddenContainer() {
    return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = T4({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
  }
  removeHiddenContainer() {
    return S2(this.containerElement);
  }
  processNode(t5) {
    switch (t5.nodeType) {
      case Node.TEXT_NODE:
        if (!this.isInsignificantTextNode(t5)) return this.appendBlockForTextNode(t5), this.processTextNode(t5);
        break;
      case Node.ELEMENT_NODE:
        return this.appendBlockForElement(t5), this.processElement(t5);
    }
  }
  appendBlockForTextNode(t5) {
    const e4 = t5.parentNode;
    if (e4 === this.currentBlockElement && this.isBlockElement(t5.previousSibling)) return this.appendStringWithAttributes("\n");
    if (e4 === this.containerElement || this.isBlockElement(e4)) {
      var i4;
      const t6 = this.getBlockAttributes(e4), n3 = this.getBlockHTMLAttributes(e4);
      ot(t6, null === (i4 = this.currentBlock) || void 0 === i4 ? void 0 : i4.attributes) || (this.currentBlock = this.appendBlockForAttributesWithElement(t6, e4, n3), this.currentBlockElement = e4);
    }
  }
  appendBlockForElement(t5) {
    const e4 = this.isBlockElement(t5), i4 = C3(this.currentBlockElement, t5);
    if (e4 && !this.isBlockElement(t5.firstChild)) {
      if (!this.isInsignificantTextNode(t5.firstChild) || !this.isBlockElement(t5.firstElementChild)) {
        const e5 = this.getBlockAttributes(t5), n3 = this.getBlockHTMLAttributes(t5);
        if (t5.firstChild) {
          if (i4 && ot(e5, this.currentBlock.attributes)) return this.appendStringWithAttributes("\n");
          this.currentBlock = this.appendBlockForAttributesWithElement(e5, t5, n3), this.currentBlockElement = t5;
        }
      }
    } else if (this.currentBlockElement && !i4 && !e4) {
      const e5 = this.findParentBlockElement(t5);
      if (e5) return this.appendBlockForElement(e5);
      this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null;
    }
  }
  findParentBlockElement(t5) {
    let { parentElement: e4 } = t5;
    for (; e4 && e4 !== this.containerElement; ) {
      if (this.isBlockElement(e4) && this.blockElements.includes(e4)) return e4;
      e4 = e4.parentElement;
    }
    return null;
  }
  processTextNode(t5) {
    let e4 = t5.data;
    var i4;
    un(t5.parentNode) || (e4 = Vt(e4), fn(null === (i4 = t5.previousSibling) || void 0 === i4 ? void 0 : i4.textContent) && (e4 = mn(e4)));
    return this.appendStringWithAttributes(e4, this.getTextAttributes(t5.parentNode));
  }
  processElement(t5) {
    let e4;
    if (P3(t5)) {
      if (e4 = ln(t5, "attachment"), Object.keys(e4).length) {
        const i4 = this.getTextAttributes(t5);
        this.appendAttachmentWithAttributes(e4, i4), t5.innerHTML = "";
      }
      return this.processedElements.push(t5);
    }
    switch (k3(t5)) {
      case "br":
        return this.isExtraBR(t5) || this.isBlockElement(t5.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t5)), this.processedElements.push(t5);
      case "img":
        e4 = { url: t5.getAttribute("src"), contentType: "image" };
        const i4 = ((t6) => {
          const e5 = t6.getAttribute("width"), i5 = t6.getAttribute("height"), n3 = {};
          return e5 && (n3.width = parseInt(e5, 10)), i5 && (n3.height = parseInt(i5, 10)), n3;
        })(t5);
        for (const t6 in i4) {
          const n3 = i4[t6];
          e4[t6] = n3;
        }
        return this.appendAttachmentWithAttributes(e4, this.getTextAttributes(t5)), this.processedElements.push(t5);
      case "tr":
        if (this.needsTableSeparator(t5)) return this.appendStringWithAttributes(j4.tableRowSeparator);
        break;
      case "td":
        if (this.needsTableSeparator(t5)) return this.appendStringWithAttributes(j4.tableCellSeparator);
    }
  }
  appendBlockForAttributesWithElement(t5, e4) {
    let i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    this.blockElements.push(e4);
    const n3 = function() {
      return { text: [], attributes: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, htmlAttributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {} };
    }(t5, i4);
    return this.blocks.push(n3), n3;
  }
  appendEmptyBlock() {
    return this.appendBlockForAttributesWithElement([], null);
  }
  appendStringWithAttributes(t5, e4) {
    return this.appendPiece(an(t5, e4));
  }
  appendAttachmentWithAttributes(t5, e4) {
    return this.appendPiece(function(t6) {
      return { attachment: t6, attributes: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, type: "attachment" };
    }(t5, e4));
  }
  appendPiece(t5) {
    return 0 === this.blocks.length && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t5);
  }
  appendStringToTextAtIndex(t5, e4) {
    const { text: i4 } = this.blocks[e4], n3 = i4[i4.length - 1];
    if ("string" !== (null == n3 ? void 0 : n3.type)) return i4.push(an(t5));
    n3.string += t5;
  }
  prependStringToTextAtIndex(t5, e4) {
    const { text: i4 } = this.blocks[e4], n3 = i4[0];
    if ("string" !== (null == n3 ? void 0 : n3.type)) return i4.unshift(an(t5));
    n3.string = t5 + n3.string;
  }
  getTextAttributes(t5) {
    let e4;
    const i4 = {};
    for (const n3 in W2) {
      const r4 = W2[n3];
      if (r4.tagName && y3(t5, { matchingSelector: r4.tagName, untilNode: this.containerElement })) i4[n3] = true;
      else if (r4.parser) {
        if (e4 = r4.parser(t5), e4) {
          let o3 = false;
          for (const i5 of this.findBlockElementAncestors(t5)) if (r4.parser(i5) === e4) {
            o3 = true;
            break;
          }
          o3 || (i4[n3] = e4);
        }
      } else r4.styleProperty && (e4 = t5.style[r4.styleProperty], e4 && (i4[n3] = e4));
    }
    if (P3(t5)) {
      const n3 = ln(t5, "attributes");
      for (const t6 in n3) e4 = n3[t6], i4[t6] = e4;
    }
    return i4;
  }
  getBlockAttributes(t5) {
    const e4 = [];
    for (; t5 && t5 !== this.containerElement; ) {
      for (const r4 in n2) {
        const o3 = n2[r4];
        var i4;
        if (false !== o3.parse) {
          if (k3(t5) === o3.tagName) (null !== (i4 = o3.test) && void 0 !== i4 && i4.call(o3, t5) || !o3.test) && (e4.push(r4), o3.listAttribute && e4.push(o3.listAttribute));
        }
      }
      t5 = t5.parentNode;
    }
    return e4.reverse();
  }
  getBlockHTMLAttributes(t5) {
    const e4 = {}, i4 = Object.values(n2).find((e5) => e5.tagName === k3(t5));
    return ((null == i4 ? void 0 : i4.htmlAttributes) || []).forEach((i5) => {
      t5.hasAttribute(i5) && (e4[i5] = t5.getAttribute(i5));
    }), e4;
  }
  findBlockElementAncestors(t5) {
    const e4 = [];
    for (; t5 && t5 !== this.containerElement; ) {
      const i4 = k3(t5);
      L3().includes(i4) && e4.push(t5), t5 = t5.parentNode;
    }
    return e4;
  }
  isBlockElement(t5) {
    if ((null == t5 ? void 0 : t5.nodeType) === Node.ELEMENT_NODE && !P3(t5) && !y3(t5, { matchingSelector: "td", untilNode: this.containerElement })) return L3().includes(k3(t5)) || "block" === window.getComputedStyle(t5).display;
  }
  isInsignificantTextNode(t5) {
    if ((null == t5 ? void 0 : t5.nodeType) !== Node.TEXT_NODE) return;
    if (!pn(t5.data)) return;
    const { parentNode: e4, previousSibling: i4, nextSibling: n3 } = t5;
    return hn(e4.previousSibling) && !this.isBlockElement(e4.previousSibling) || un(e4) ? void 0 : !i4 || this.isBlockElement(i4) || !n3 || this.isBlockElement(n3);
  }
  isExtraBR(t5) {
    return "br" === k3(t5) && this.isBlockElement(t5.parentNode) && t5.parentNode.lastChild === t5;
  }
  needsTableSeparator(t5) {
    if (j4.removeBlankTableCells) {
      var e4;
      const i4 = null === (e4 = t5.previousSibling) || void 0 === e4 ? void 0 : e4.textContent;
      return i4 && /\S/.test(i4);
    }
    return t5.previousSibling;
  }
  translateBlockElementMarginsToNewlines() {
    const t5 = this.getMarginOfDefaultBlockElement();
    for (let e4 = 0; e4 < this.blocks.length; e4++) {
      const i4 = this.getMarginOfBlockElementAtIndex(e4);
      i4 && (i4.top > 2 * t5.top && this.prependStringToTextAtIndex("\n", e4), i4.bottom > 2 * t5.bottom && this.appendStringToTextAtIndex("\n", e4));
    }
  }
  getMarginOfBlockElementAtIndex(t5) {
    const e4 = this.blockElements[t5];
    if (e4 && e4.textContent && !L3().includes(k3(e4)) && !this.processedElements.includes(e4)) return dn(e4);
  }
  getMarginOfDefaultBlockElement() {
    const t5 = T4(n2.default.tagName);
    return this.containerElement.appendChild(t5), dn(t5);
  }
};
var un = function(t5) {
  const { whiteSpace: e4 } = window.getComputedStyle(t5);
  return ["pre", "pre-wrap", "pre-line"].includes(e4);
};
var hn = (t5) => t5 && !fn(t5.textContent);
var dn = function(t5) {
  const e4 = window.getComputedStyle(t5);
  if ("block" === e4.display) return { top: parseInt(e4.marginTop), bottom: parseInt(e4.marginBottom) };
};
var gn = function(t5) {
  return "style" === k3(t5) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};
var mn = (t5) => t5.replace(new RegExp("^".concat(Ut.source, "+")), "");
var pn = (t5) => new RegExp("^".concat(Ut.source, "*$")).test(t5);
var fn = (t5) => /\s$/.test(t5);
var bn = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"];
var vn = "data-trix-serialized-attributes";
var An = "[".concat(vn, "]");
var yn = new RegExp("<!--block-->", "g");
var xn = { "application/json": function(t5) {
  let e4;
  if (t5 instanceof on) e4 = t5;
  else {
    if (!(t5 instanceof HTMLElement)) throw new Error("unserializable object");
    e4 = cn.parse(t5.innerHTML).getDocument();
  }
  return e4.toSerializableDocument().toJSONString();
}, "text/html": function(t5) {
  let e4;
  if (t5 instanceof on) e4 = Ci.render(t5);
  else {
    if (!(t5 instanceof HTMLElement)) throw new Error("unserializable object");
    e4 = t5.cloneNode(true);
  }
  return Array.from(e4.querySelectorAll("[data-trix-serialize=false]")).forEach((t6) => {
    S2(t6);
  }), bn.forEach((t6) => {
    Array.from(e4.querySelectorAll("[".concat(t6, "]"))).forEach((e5) => {
      e5.removeAttribute(t6);
    });
  }), Array.from(e4.querySelectorAll(An)).forEach((t6) => {
    try {
      const e5 = JSON.parse(t6.getAttribute(vn));
      t6.removeAttribute(vn);
      for (const i4 in e5) {
        const n3 = e5[i4];
        t6.setAttribute(i4, n3);
      }
    } catch (t7) {
    }
  }), e4.innerHTML.replace(yn, "");
} };
var Cn = Object.freeze({ __proto__: null });
var En = class extends q3 {
  constructor(t5, e4) {
    super(...arguments), this.attachmentManager = t5, this.attachment = e4, this.id = this.attachment.id, this.file = this.attachment.file;
  }
  remove() {
    return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
  }
};
En.proxyMethod("attachment.getAttribute"), En.proxyMethod("attachment.hasAttribute"), En.proxyMethod("attachment.setAttribute"), En.proxyMethod("attachment.getAttributes"), En.proxyMethod("attachment.setAttributes"), En.proxyMethod("attachment.isPending"), En.proxyMethod("attachment.isPreviewable"), En.proxyMethod("attachment.getURL"), En.proxyMethod("attachment.getHref"), En.proxyMethod("attachment.getFilename"), En.proxyMethod("attachment.getFilesize"), En.proxyMethod("attachment.getFormattedFilesize"), En.proxyMethod("attachment.getExtension"), En.proxyMethod("attachment.getContentType"), En.proxyMethod("attachment.getFile"), En.proxyMethod("attachment.setFile"), En.proxyMethod("attachment.releaseFile"), En.proxyMethod("attachment.getUploadProgress"), En.proxyMethod("attachment.setUploadProgress");
var Sn = class extends q3 {
  constructor() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    super(...arguments), this.managedAttachments = {}, Array.from(t5).forEach((t6) => {
      this.manageAttachment(t6);
    });
  }
  getAttachments() {
    const t5 = [];
    for (const e4 in this.managedAttachments) {
      const i4 = this.managedAttachments[e4];
      t5.push(i4);
    }
    return t5;
  }
  manageAttachment(t5) {
    return this.managedAttachments[t5.id] || (this.managedAttachments[t5.id] = new En(this, t5)), this.managedAttachments[t5.id];
  }
  attachmentIsManaged(t5) {
    return t5.id in this.managedAttachments;
  }
  requestRemovalOfAttachment(t5) {
    var e4, i4;
    if (this.attachmentIsManaged(t5)) return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.attachmentManagerDidRequestRemovalOfAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  unmanageAttachment(t5) {
    const e4 = this.managedAttachments[t5.id];
    return delete this.managedAttachments[t5.id], e4;
  }
};
var Rn = class {
  constructor(t5) {
    this.composition = t5, this.document = this.composition.document;
    const e4 = this.composition.getSelectedRange();
    this.startPosition = e4[0], this.endPosition = e4[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
  }
  shouldInsertBlockBreak() {
    return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? 0 !== this.startLocation.offset : this.breaksOnReturn && "\n" !== this.nextCharacter;
  }
  shouldBreakFormattedBlock() {
    return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && "\n" === this.nextCharacter || "\n" === this.previousCharacter);
  }
  shouldDecreaseListLevel() {
    return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
  }
  shouldPrependListItem() {
    return this.block.isListItem() && 0 === this.startLocation.offset && !this.block.isEmpty();
  }
  shouldRemoveLastBlockAttribute() {
    return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
  }
};
var kn = class extends q3 {
  constructor() {
    super(...arguments), this.document = new on(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
  }
  setDocument(t5) {
    var e4, i4;
    if (!t5.isEqualTo(this.document)) return this.document = t5, this.refreshAttachments(), this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidChangeDocument) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  getSnapshot() {
    return { document: this.document, selectedRange: this.getSelectedRange() };
  }
  loadSnapshot(t5) {
    var e4, i4, n3, r4;
    let { document: o3, selectedRange: s4 } = t5;
    return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionWillLoadSnapshot) || void 0 === i4 || i4.call(e4), this.setDocument(null != o3 ? o3 : new on()), this.setSelection(null != s4 ? s4 : [0, 0]), null === (n3 = this.delegate) || void 0 === n3 || null === (r4 = n3.compositionDidLoadSnapshot) || void 0 === r4 ? void 0 : r4.call(n3);
  }
  insertText(t5) {
    let { updatePosition: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { updatePosition: true };
    const i4 = this.getSelectedRange();
    this.setDocument(this.document.insertTextAtRange(t5, i4));
    const n3 = i4[0], r4 = n3 + t5.getLength();
    return e4 && this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n3, r4]);
  }
  insertBlock() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Gi();
    const e4 = new on([t5]);
    return this.insertDocument(e4);
  }
  insertDocument() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new on();
    const e4 = this.getSelectedRange();
    this.setDocument(this.document.insertDocumentAtRange(t5, e4));
    const i4 = e4[0], n3 = i4 + t5.getLength();
    return this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([i4, n3]);
  }
  insertString(t5, e4) {
    const i4 = this.getCurrentTextAttributes(), n3 = Ki.textForStringWithAttributes(t5, i4);
    return this.insertText(n3, e4);
  }
  insertBlockBreak() {
    const t5 = this.getSelectedRange();
    this.setDocument(this.document.insertBlockBreakAtRange(t5));
    const e4 = t5[0], i4 = e4 + 1;
    return this.setSelection(i4), this.notifyDelegateOfInsertionAtRange([e4, i4]);
  }
  insertLineBreak() {
    const t5 = new Rn(this);
    if (t5.shouldDecreaseListLevel()) return this.decreaseListLevel(), this.setSelection(t5.startPosition);
    if (t5.shouldPrependListItem()) {
      const e4 = new on([t5.block.copyWithoutText()]);
      return this.insertDocument(e4);
    }
    return t5.shouldInsertBlockBreak() ? this.insertBlockBreak() : t5.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : t5.shouldBreakFormattedBlock() ? this.breakFormattedBlock(t5) : this.insertString("\n");
  }
  insertHTML(t5) {
    const e4 = cn.parse(t5).getDocument(), i4 = this.getSelectedRange();
    this.setDocument(this.document.mergeDocumentAtRange(e4, i4));
    const n3 = i4[0], r4 = n3 + e4.getLength() - 1;
    return this.setSelection(r4), this.notifyDelegateOfInsertionAtRange([n3, r4]);
  }
  replaceHTML(t5) {
    const e4 = cn.parse(t5).getDocument().copyUsingObjectsFromDocument(this.document), i4 = this.getLocationRange({ strict: false }), n3 = this.document.rangeFromLocationRange(i4);
    return this.setDocument(e4), this.setSelection(n3);
  }
  insertFile(t5) {
    return this.insertFiles([t5]);
  }
  insertFiles(t5) {
    const e4 = [];
    return Array.from(t5).forEach((t6) => {
      var i4;
      if (null !== (i4 = this.delegate) && void 0 !== i4 && i4.compositionShouldAcceptFile(t6)) {
        const i5 = Wi.attachmentForFile(t6);
        e4.push(i5);
      }
    }), this.insertAttachments(e4);
  }
  insertAttachment(t5) {
    return this.insertAttachments([t5]);
  }
  insertAttachments(t5) {
    let e4 = new Ki();
    return Array.from(t5).forEach((t6) => {
      var n3;
      const r4 = t6.getType(), o3 = null === (n3 = i3[r4]) || void 0 === n3 ? void 0 : n3.presentation, s4 = this.getCurrentTextAttributes();
      o3 && (s4.presentation = o3);
      const a4 = Ki.textForAttachmentWithAttributes(t6, s4);
      e4 = e4.appendText(a4);
    }), this.insertText(e4);
  }
  shouldManageDeletingInDirection(t5) {
    const e4 = this.getLocationRange();
    if (Lt(e4)) {
      if ("backward" === t5 && 0 === e4[0].offset) return true;
      if (this.shouldManageMovingCursorInDirection(t5)) return true;
    } else if (e4[0].index !== e4[1].index) return true;
    return false;
  }
  deleteInDirection(t5) {
    let e4, i4, n3, { length: r4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const o3 = this.getLocationRange();
    let s4 = this.getSelectedRange();
    const a4 = Lt(s4);
    if (a4 ? i4 = "backward" === t5 && 0 === o3[0].offset : n3 = o3[0].index !== o3[1].index, i4 && this.canDecreaseBlockAttributeLevel()) {
      const t6 = this.getBlock();
      if (t6.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(s4[0]), t6.isEmpty()) return false;
    }
    return a4 && (s4 = this.getExpandedRangeInDirection(t5, { length: r4 }), "backward" === t5 && (e4 = this.getAttachmentAtRange(s4))), e4 ? (this.editAttachment(e4), false) : (this.setDocument(this.document.removeTextAtRange(s4)), this.setSelection(s4[0]), !i4 && !n3 && void 0);
  }
  moveTextFromRange(t5) {
    const [e4] = Array.from(this.getSelectedRange());
    return this.setDocument(this.document.moveTextFromRangeToPosition(t5, e4)), this.setSelection(e4);
  }
  removeAttachment(t5) {
    const e4 = this.document.getRangeOfAttachment(t5);
    if (e4) return this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e4)), this.setSelection(e4[0]);
  }
  removeLastBlockAttribute() {
    const [t5, e4] = Array.from(this.getSelectedRange()), i4 = this.document.getBlockAtPosition(e4);
    return this.removeCurrentAttribute(i4.getLastAttribute()), this.setSelection(t5);
  }
  insertPlaceholder() {
    return this.placeholderPosition = this.getPosition(), this.insertString(" ");
  }
  selectPlaceholder() {
    if (null != this.placeholderPosition) return this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + 1]), this.getSelectedRange();
  }
  forgetPlaceholder() {
    this.placeholderPosition = null;
  }
  hasCurrentAttribute(t5) {
    const e4 = this.currentAttributes[t5];
    return null != e4 && false !== e4;
  }
  toggleCurrentAttribute(t5) {
    const e4 = !this.currentAttributes[t5];
    return e4 ? this.setCurrentAttribute(t5, e4) : this.removeCurrentAttribute(t5);
  }
  canSetCurrentAttribute(t5) {
    return mt(t5) ? this.canSetCurrentBlockAttribute(t5) : this.canSetCurrentTextAttribute(t5);
  }
  canSetCurrentTextAttribute(t5) {
    const e4 = this.getSelectedDocument();
    if (e4) {
      for (const t6 of Array.from(e4.getAttachments())) if (!t6.hasContent()) return false;
      return true;
    }
  }
  canSetCurrentBlockAttribute(t5) {
    const e4 = this.getBlock();
    if (e4) return !e4.isTerminalBlock();
  }
  setCurrentAttribute(t5, e4) {
    return mt(t5) ? this.setBlockAttribute(t5, e4) : (this.setTextAttribute(t5, e4), this.currentAttributes[t5] = e4, this.notifyDelegateOfCurrentAttributesChange());
  }
  setHTMLAtributeAtPosition(t5, e4, i4) {
    var n3;
    const r4 = this.document.getBlockAtPosition(t5), o3 = null === (n3 = mt(r4.getLastAttribute())) || void 0 === n3 ? void 0 : n3.htmlAttributes;
    if (r4 && null != o3 && o3.includes(e4)) {
      const n4 = this.document.setHTMLAttributeAtPosition(t5, e4, i4);
      this.setDocument(n4);
    }
  }
  setTextAttribute(t5, e4) {
    const i4 = this.getSelectedRange();
    if (!i4) return;
    const [n3, r4] = Array.from(i4);
    if (n3 !== r4) return this.setDocument(this.document.addAttributeAtRange(t5, e4, i4));
    if ("href" === t5) {
      const t6 = Ki.textForStringWithAttributes(e4, { href: e4 });
      return this.insertText(t6);
    }
  }
  setBlockAttribute(t5, e4) {
    const i4 = this.getSelectedRange();
    if (this.canSetCurrentAttribute(t5)) return this.setDocument(this.document.applyBlockAttributeAtRange(t5, e4, i4)), this.setSelection(i4);
  }
  removeCurrentAttribute(t5) {
    return mt(t5) ? (this.removeBlockAttribute(t5), this.updateCurrentAttributes()) : (this.removeTextAttribute(t5), delete this.currentAttributes[t5], this.notifyDelegateOfCurrentAttributesChange());
  }
  removeTextAttribute(t5) {
    const e4 = this.getSelectedRange();
    if (e4) return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
  }
  removeBlockAttribute(t5) {
    const e4 = this.getSelectedRange();
    if (e4) return this.setDocument(this.document.removeAttributeAtRange(t5, e4));
  }
  canDecreaseNestingLevel() {
    var t5;
    return (null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getNestingLevel()) > 0;
  }
  canIncreaseNestingLevel() {
    var t5;
    const e4 = this.getBlock();
    if (e4) {
      if (null === (t5 = mt(e4.getLastNestableAttribute())) || void 0 === t5 || !t5.listAttribute) return e4.getNestingLevel() > 0;
      {
        const t6 = this.getPreviousBlock();
        if (t6) return function() {
          let t7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
          return ot((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).slice(0, t7.length), t7);
        }(t6.getListItemAttributes(), e4.getListItemAttributes());
      }
    }
  }
  decreaseNestingLevel() {
    const t5 = this.getBlock();
    if (t5) return this.setDocument(this.document.replaceBlock(t5, t5.decreaseNestingLevel()));
  }
  increaseNestingLevel() {
    const t5 = this.getBlock();
    if (t5) return this.setDocument(this.document.replaceBlock(t5, t5.increaseNestingLevel()));
  }
  canDecreaseBlockAttributeLevel() {
    var t5;
    return (null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getAttributeLevel()) > 0;
  }
  decreaseBlockAttributeLevel() {
    var t5;
    const e4 = null === (t5 = this.getBlock()) || void 0 === t5 ? void 0 : t5.getLastAttribute();
    if (e4) return this.removeCurrentAttribute(e4);
  }
  decreaseListLevel() {
    let [t5] = Array.from(this.getSelectedRange());
    const { index: e4 } = this.document.locationFromPosition(t5);
    let i4 = e4;
    const n3 = this.getBlock().getAttributeLevel();
    let r4 = this.document.getBlockAtIndex(i4 + 1);
    for (; r4 && r4.isListItem() && !(r4.getAttributeLevel() <= n3); ) i4++, r4 = this.document.getBlockAtIndex(i4 + 1);
    t5 = this.document.positionFromLocation({ index: e4, offset: 0 });
    const o3 = this.document.positionFromLocation({ index: i4, offset: 0 });
    return this.setDocument(this.document.removeLastListAttributeAtRange([t5, o3]));
  }
  updateCurrentAttributes() {
    const t5 = this.getSelectedRange({ ignoreLock: true });
    if (t5) {
      const e4 = this.document.getCommonAttributesAtRange(t5);
      if (Array.from(gt()).forEach((t6) => {
        e4[t6] || this.canSetCurrentAttribute(t6) || (e4[t6] = false);
      }), !Tt(e4, this.currentAttributes)) return this.currentAttributes = e4, this.notifyDelegateOfCurrentAttributesChange();
    }
  }
  getCurrentAttributes() {
    return m4.call({}, this.currentAttributes);
  }
  getCurrentTextAttributes() {
    const t5 = {};
    for (const e4 in this.currentAttributes) {
      const i4 = this.currentAttributes[e4];
      false !== i4 && ft(e4) && (t5[e4] = i4);
    }
    return t5;
  }
  freezeSelection() {
    return this.setCurrentAttribute("frozen", true);
  }
  thawSelection() {
    return this.removeCurrentAttribute("frozen");
  }
  hasFrozenSelection() {
    return this.hasCurrentAttribute("frozen");
  }
  setSelection(t5) {
    var e4;
    const i4 = this.document.locationRangeFromRange(t5);
    return null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.compositionDidRequestChangingSelectionToLocationRange(i4);
  }
  getSelectedRange() {
    const t5 = this.getLocationRange();
    if (t5) return this.document.rangeFromLocationRange(t5);
  }
  setSelectedRange(t5) {
    const e4 = this.document.locationRangeFromRange(t5);
    return this.getSelectionManager().setLocationRange(e4);
  }
  getPosition() {
    const t5 = this.getLocationRange();
    if (t5) return this.document.positionFromLocation(t5[0]);
  }
  getLocationRange(t5) {
    return this.targetLocationRange ? this.targetLocationRange : this.getSelectionManager().getLocationRange(t5) || wt({ index: 0, offset: 0 });
  }
  withTargetLocationRange(t5, e4) {
    let i4;
    this.targetLocationRange = t5;
    try {
      i4 = e4();
    } finally {
      this.targetLocationRange = null;
    }
    return i4;
  }
  withTargetRange(t5, e4) {
    const i4 = this.document.locationRangeFromRange(t5);
    return this.withTargetLocationRange(i4, e4);
  }
  withTargetDOMRange(t5, e4) {
    const i4 = this.createLocationRangeFromDOMRange(t5, { strict: false });
    return this.withTargetLocationRange(i4, e4);
  }
  getExpandedRangeInDirection(t5) {
    let { length: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, [i4, n3] = Array.from(this.getSelectedRange());
    return "backward" === t5 ? e4 ? i4 -= e4 : i4 = this.translateUTF16PositionFromOffset(i4, -1) : e4 ? n3 += e4 : n3 = this.translateUTF16PositionFromOffset(n3, 1), wt([i4, n3]);
  }
  shouldManageMovingCursorInDirection(t5) {
    if (this.editingAttachment) return true;
    const e4 = this.getExpandedRangeInDirection(t5);
    return null != this.getAttachmentAtRange(e4);
  }
  moveCursorInDirection(t5) {
    let e4, i4;
    if (this.editingAttachment) i4 = this.document.getRangeOfAttachment(this.editingAttachment);
    else {
      const n3 = this.getSelectedRange();
      i4 = this.getExpandedRangeInDirection(t5), e4 = !Dt(n3, i4);
    }
    if ("backward" === t5 ? this.setSelectedRange(i4[0]) : this.setSelectedRange(i4[1]), e4) {
      const t6 = this.getAttachmentAtRange(i4);
      if (t6) return this.editAttachment(t6);
    }
  }
  expandSelectionInDirection(t5) {
    let { length: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i4 = this.getExpandedRangeInDirection(t5, { length: e4 });
    return this.setSelectedRange(i4);
  }
  expandSelectionForEditing() {
    if (this.hasCurrentAttribute("href")) return this.expandSelectionAroundCommonAttribute("href");
  }
  expandSelectionAroundCommonAttribute(t5) {
    const e4 = this.getPosition(), i4 = this.document.getRangeOfCommonAttributeAtPosition(t5, e4);
    return this.setSelectedRange(i4);
  }
  selectionContainsAttachments() {
    var t5;
    return (null === (t5 = this.getSelectedAttachments()) || void 0 === t5 ? void 0 : t5.length) > 0;
  }
  selectionIsInCursorTarget() {
    return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
  }
  positionIsCursorTarget(t5) {
    const e4 = this.document.locationFromPosition(t5);
    if (e4) return this.locationIsCursorTarget(e4);
  }
  positionIsBlockBreak(t5) {
    var e4;
    return null === (e4 = this.document.getPieceAtPosition(t5)) || void 0 === e4 ? void 0 : e4.isBlockBreak();
  }
  getSelectedDocument() {
    const t5 = this.getSelectedRange();
    if (t5) return this.document.getDocumentAtRange(t5);
  }
  getSelectedAttachments() {
    var t5;
    return null === (t5 = this.getSelectedDocument()) || void 0 === t5 ? void 0 : t5.getAttachments();
  }
  getAttachments() {
    return this.attachments.slice(0);
  }
  refreshAttachments() {
    const t5 = this.document.getAttachments(), { added: e4, removed: i4 } = function() {
      let t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      const i5 = [], n3 = [], r4 = /* @__PURE__ */ new Set();
      t6.forEach((t7) => {
        r4.add(t7);
      });
      const o3 = /* @__PURE__ */ new Set();
      return e5.forEach((t7) => {
        o3.add(t7), r4.has(t7) || i5.push(t7);
      }), t6.forEach((t7) => {
        o3.has(t7) || n3.push(t7);
      }), { added: i5, removed: n3 };
    }(this.attachments, t5);
    return this.attachments = t5, Array.from(i4).forEach((t6) => {
      var e5, i5;
      t6.delegate = null, null === (e5 = this.delegate) || void 0 === e5 || null === (i5 = e5.compositionDidRemoveAttachment) || void 0 === i5 || i5.call(e5, t6);
    }), (() => {
      const t6 = [];
      return Array.from(e4).forEach((e5) => {
        var i5, n3;
        e5.delegate = this, t6.push(null === (i5 = this.delegate) || void 0 === i5 || null === (n3 = i5.compositionDidAddAttachment) || void 0 === n3 ? void 0 : n3.call(i5, e5));
      }), t6;
    })();
  }
  attachmentDidChangeAttributes(t5) {
    var e4, i4;
    return this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidEditAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  attachmentDidChangePreviewURL(t5) {
    var e4, i4;
    return this.revision++, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidChangeAttachmentPreviewURL) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  editAttachment(t5, e4) {
    var i4, n3;
    if (t5 !== this.editingAttachment) return this.stopEditingAttachment(), this.editingAttachment = t5, null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionDidStartEditingAttachment) || void 0 === n3 ? void 0 : n3.call(i4, this.editingAttachment, e4);
  }
  stopEditingAttachment() {
    var t5, e4;
    this.editingAttachment && (null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionDidStopEditingAttachment) || void 0 === e4 || e4.call(t5, this.editingAttachment), this.editingAttachment = null);
  }
  updateAttributesForAttachment(t5, e4) {
    return this.setDocument(this.document.updateAttributesForAttachment(t5, e4));
  }
  removeAttributeForAttachment(t5, e4) {
    return this.setDocument(this.document.removeAttributeForAttachment(t5, e4));
  }
  breakFormattedBlock(t5) {
    let { document: e4 } = t5;
    const { block: i4 } = t5;
    let n3 = t5.startPosition, r4 = [n3 - 1, n3];
    i4.getBlockBreakPosition() === t5.startLocation.offset ? (i4.breaksOnReturn() && "\n" === t5.nextCharacter ? n3 += 1 : e4 = e4.removeTextAtRange(r4), r4 = [n3, n3]) : "\n" === t5.nextCharacter ? "\n" === t5.previousCharacter ? r4 = [n3 - 1, n3 + 1] : (r4 = [n3, n3 + 1], n3 += 1) : t5.startLocation.offset - 1 != 0 && (n3 += 1);
    const o3 = new on([i4.removeLastAttribute().copyWithoutText()]);
    return this.setDocument(e4.insertDocumentAtRange(o3, r4)), this.setSelection(n3);
  }
  getPreviousBlock() {
    const t5 = this.getLocationRange();
    if (t5) {
      const { index: e4 } = t5[0];
      if (e4 > 0) return this.document.getBlockAtIndex(e4 - 1);
    }
  }
  getBlock() {
    const t5 = this.getLocationRange();
    if (t5) return this.document.getBlockAtIndex(t5[0].index);
  }
  getAttachmentAtRange(t5) {
    const e4 = this.document.getDocumentAtRange(t5);
    if (e4.toString() === "".concat("\uFFFC", "\n")) return e4.getAttachments()[0];
  }
  notifyDelegateOfCurrentAttributesChange() {
    var t5, e4;
    return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionDidChangeCurrentAttributes) || void 0 === e4 ? void 0 : e4.call(t5, this.currentAttributes);
  }
  notifyDelegateOfInsertionAtRange(t5) {
    var e4, i4;
    return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionDidPerformInsertionAtRange) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  translateUTF16PositionFromOffset(t5, e4) {
    const i4 = this.document.toUTF16String(), n3 = i4.offsetFromUCS2Offset(t5);
    return i4.offsetToUCS2Offset(n3 + e4);
  }
};
kn.proxyMethod("getSelectionManager().getPointRange"), kn.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), kn.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), kn.proxyMethod("getSelectionManager().locationIsCursorTarget"), kn.proxyMethod("getSelectionManager().selectionIsExpanded"), kn.proxyMethod("delegate?.getSelectionManager");
var Tn = class extends q3 {
  constructor(t5) {
    super(...arguments), this.composition = t5, this.undoEntries = [], this.redoEntries = [];
  }
  recordUndoEntry(t5) {
    let { context: e4, consolidatable: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const n3 = this.undoEntries.slice(-1)[0];
    if (!i4 || !wn(n3, t5, e4)) {
      const i5 = this.createEntry({ description: t5, context: e4 });
      this.undoEntries.push(i5), this.redoEntries = [];
    }
  }
  undo() {
    const t5 = this.undoEntries.pop();
    if (t5) {
      const e4 = this.createEntry(t5);
      return this.redoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
    }
  }
  redo() {
    const t5 = this.redoEntries.pop();
    if (t5) {
      const e4 = this.createEntry(t5);
      return this.undoEntries.push(e4), this.composition.loadSnapshot(t5.snapshot);
    }
  }
  canUndo() {
    return this.undoEntries.length > 0;
  }
  canRedo() {
    return this.redoEntries.length > 0;
  }
  createEntry() {
    let { description: t5, context: e4 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return { description: null == t5 ? void 0 : t5.toString(), context: JSON.stringify(e4), snapshot: this.composition.getSnapshot() };
  }
};
var wn = (t5, e4, i4) => (null == t5 ? void 0 : t5.description) === (null == e4 ? void 0 : e4.toString()) && (null == t5 ? void 0 : t5.context) === JSON.stringify(i4);
var Ln = "attachmentGallery";
var Dn = class {
  constructor(t5) {
    this.document = t5.document, this.selectedRange = t5.selectedRange;
  }
  perform() {
    return this.removeBlockAttribute(), this.applyBlockAttribute();
  }
  getSnapshot() {
    return { document: this.document, selectedRange: this.selectedRange };
  }
  removeBlockAttribute() {
    return this.findRangesOfBlocks().map((t5) => this.document = this.document.removeAttributeAtRange(Ln, t5));
  }
  applyBlockAttribute() {
    let t5 = 0;
    this.findRangesOfPieces().forEach((e4) => {
      e4[1] - e4[0] > 1 && (e4[0] += t5, e4[1] += t5, "\n" !== this.document.getCharacterAtPosition(e4[1]) && (this.document = this.document.insertBlockBreakAtRange(e4[1]), e4[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), e4[1]++, t5++), 0 !== e4[0] && "\n" !== this.document.getCharacterAtPosition(e4[0] - 1) && (this.document = this.document.insertBlockBreakAtRange(e4[0]), e4[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), e4[0]++, t5++), this.document = this.document.applyBlockAttributeAtRange(Ln, true, e4));
    });
  }
  findRangesOfBlocks() {
    return this.document.findRangesForBlockAttribute(Ln);
  }
  findRangesOfPieces() {
    return this.document.findRangesForTextAttribute("presentation", { withValue: "gallery" });
  }
  moveSelectedRangeForward() {
    this.selectedRange[0] += 1, this.selectedRange[1] += 1;
  }
};
var Nn = function(t5) {
  const e4 = new Dn(t5);
  return e4.perform(), e4.getSnapshot();
};
var In = [Nn];
var On = class {
  constructor(t5, e4, i4) {
    this.insertFiles = this.insertFiles.bind(this), this.composition = t5, this.selectionManager = e4, this.element = i4, this.undoManager = new Tn(this.composition), this.filters = In.slice(0);
  }
  loadDocument(t5) {
    return this.loadSnapshot({ document: t5, selectedRange: [0, 0] });
  }
  loadHTML() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const e4 = cn.parse(t5, { referenceElement: this.element }).getDocument();
    return this.loadDocument(e4);
  }
  loadJSON(t5) {
    let { document: e4, selectedRange: i4 } = t5;
    return e4 = on.fromJSON(e4), this.loadSnapshot({ document: e4, selectedRange: i4 });
  }
  loadSnapshot(t5) {
    return this.undoManager = new Tn(this.composition), this.composition.loadSnapshot(t5);
  }
  getDocument() {
    return this.composition.document;
  }
  getSelectedDocument() {
    return this.composition.getSelectedDocument();
  }
  getSnapshot() {
    return this.composition.getSnapshot();
  }
  toJSON() {
    return this.getSnapshot();
  }
  deleteInDirection(t5) {
    return this.composition.deleteInDirection(t5);
  }
  insertAttachment(t5) {
    return this.composition.insertAttachment(t5);
  }
  insertAttachments(t5) {
    return this.composition.insertAttachments(t5);
  }
  insertDocument(t5) {
    return this.composition.insertDocument(t5);
  }
  insertFile(t5) {
    return this.composition.insertFile(t5);
  }
  insertFiles(t5) {
    return this.composition.insertFiles(t5);
  }
  insertHTML(t5) {
    return this.composition.insertHTML(t5);
  }
  insertString(t5) {
    return this.composition.insertString(t5);
  }
  insertText(t5) {
    return this.composition.insertText(t5);
  }
  insertLineBreak() {
    return this.composition.insertLineBreak();
  }
  getSelectedRange() {
    return this.composition.getSelectedRange();
  }
  getPosition() {
    return this.composition.getPosition();
  }
  getClientRectAtPosition(t5) {
    const e4 = this.getDocument().locationRangeFromRange([t5, t5 + 1]);
    return this.selectionManager.getClientRectAtLocationRange(e4);
  }
  expandSelectionInDirection(t5) {
    return this.composition.expandSelectionInDirection(t5);
  }
  moveCursorInDirection(t5) {
    return this.composition.moveCursorInDirection(t5);
  }
  setSelectedRange(t5) {
    return this.composition.setSelectedRange(t5);
  }
  activateAttribute(t5) {
    let e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    return this.composition.setCurrentAttribute(t5, e4);
  }
  attributeIsActive(t5) {
    return this.composition.hasCurrentAttribute(t5);
  }
  canActivateAttribute(t5) {
    return this.composition.canSetCurrentAttribute(t5);
  }
  deactivateAttribute(t5) {
    return this.composition.removeCurrentAttribute(t5);
  }
  setHTMLAtributeAtPosition(t5, e4, i4) {
    this.composition.setHTMLAtributeAtPosition(t5, e4, i4);
  }
  canDecreaseNestingLevel() {
    return this.composition.canDecreaseNestingLevel();
  }
  canIncreaseNestingLevel() {
    return this.composition.canIncreaseNestingLevel();
  }
  decreaseNestingLevel() {
    if (this.canDecreaseNestingLevel()) return this.composition.decreaseNestingLevel();
  }
  increaseNestingLevel() {
    if (this.canIncreaseNestingLevel()) return this.composition.increaseNestingLevel();
  }
  canRedo() {
    return this.undoManager.canRedo();
  }
  canUndo() {
    return this.undoManager.canUndo();
  }
  recordUndoEntry(t5) {
    let { context: e4, consolidatable: i4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return this.undoManager.recordUndoEntry(t5, { context: e4, consolidatable: i4 });
  }
  redo() {
    if (this.canRedo()) return this.undoManager.redo();
  }
  undo() {
    if (this.canUndo()) return this.undoManager.undo();
  }
};
var Fn = class {
  constructor(t5) {
    this.element = t5;
  }
  findLocationFromContainerAndOffset(t5, e4) {
    let { strict: i4 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { strict: true }, n3 = 0, r4 = false;
    const o3 = { index: 0, offset: 0 }, s4 = this.findAttachmentElementParentForNode(t5);
    s4 && (t5 = s4.parentNode, e4 = E2(s4));
    const a4 = R(this.element, { usingFilter: _n });
    for (; a4.nextNode(); ) {
      const s5 = a4.currentNode;
      if (s5 === t5 && B3(t5)) {
        F4(s5) || (o3.offset += e4);
        break;
      }
      if (s5.parentNode === t5) {
        if (n3++ === e4) break;
      } else if (!C3(t5, s5) && n3 > 0) break;
      N3(s5, { strict: i4 }) ? (r4 && o3.index++, o3.offset = 0, r4 = true) : o3.offset += Pn(s5);
    }
    return o3;
  }
  findContainerAndOffsetFromLocation(t5) {
    let e4, i4;
    if (0 === t5.index && 0 === t5.offset) {
      for (e4 = this.element, i4 = 0; e4.firstChild; ) if (e4 = e4.firstChild, D3(e4)) {
        i4 = 1;
        break;
      }
      return [e4, i4];
    }
    let [n3, r4] = this.findNodeAndOffsetFromLocation(t5);
    if (n3) {
      if (B3(n3)) 0 === Pn(n3) ? (e4 = n3.parentNode.parentNode, i4 = E2(n3.parentNode), F4(n3, { name: "right" }) && i4++) : (e4 = n3, i4 = t5.offset - r4);
      else {
        if (e4 = n3.parentNode, !N3(n3.previousSibling) && !D3(e4)) for (; n3 === e4.lastChild && (n3 = e4, e4 = e4.parentNode, !D3(e4)); ) ;
        i4 = E2(n3), 0 !== t5.offset && i4++;
      }
      return [e4, i4];
    }
  }
  findNodeAndOffsetFromLocation(t5) {
    let e4, i4, n3 = 0;
    for (const r4 of this.getSignificantNodesForIndex(t5.index)) {
      const o3 = Pn(r4);
      if (t5.offset <= n3 + o3) if (B3(r4)) {
        if (e4 = r4, i4 = n3, t5.offset === i4 && F4(e4)) break;
      } else e4 || (e4 = r4, i4 = n3);
      if (n3 += o3, n3 > t5.offset) break;
    }
    return [e4, i4];
  }
  findAttachmentElementParentForNode(t5) {
    for (; t5 && t5 !== this.element; ) {
      if (P3(t5)) return t5;
      t5 = t5.parentNode;
    }
  }
  getSignificantNodesForIndex(t5) {
    const e4 = [], i4 = R(this.element, { usingFilter: Mn });
    let n3 = false;
    for (; i4.nextNode(); ) {
      const o3 = i4.currentNode;
      var r4;
      if (I3(o3)) {
        if (null != r4 ? r4++ : r4 = 0, r4 === t5) n3 = true;
        else if (n3) break;
      } else n3 && e4.push(o3);
    }
    return e4;
  }
};
var Pn = function(t5) {
  if (t5.nodeType === Node.TEXT_NODE) {
    if (F4(t5)) return 0;
    return t5.textContent.length;
  }
  return "br" === k3(t5) || P3(t5) ? 1 : 0;
};
var Mn = function(t5) {
  return Bn(t5) === NodeFilter.FILTER_ACCEPT ? _n(t5) : NodeFilter.FILTER_REJECT;
};
var Bn = function(t5) {
  return M2(t5) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};
var _n = function(t5) {
  return P3(t5.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
};
var jn = class {
  createDOMRangeFromPoint(t5) {
    let e4, { x: i4, y: n3 } = t5;
    if (document.caretPositionFromPoint) {
      const { offsetNode: t6, offset: r4 } = document.caretPositionFromPoint(i4, n3);
      return e4 = document.createRange(), e4.setStart(t6, r4), e4;
    }
    if (document.caretRangeFromPoint) return document.caretRangeFromPoint(i4, n3);
    if (document.body.createTextRange) {
      const t6 = Mt();
      try {
        const t7 = document.body.createTextRange();
        t7.moveToPoint(i4, n3), t7.select();
      } catch (t7) {
      }
      return e4 = Mt(), Bt(t6), e4;
    }
  }
  getClientRectsForDOMRange(t5) {
    const e4 = Array.from(t5.getClientRects());
    return [e4[0], e4[e4.length - 1]];
  }
};
var Wn = class extends q3 {
  constructor(t5) {
    super(...arguments), this.didMouseDown = this.didMouseDown.bind(this), this.selectionDidChange = this.selectionDidChange.bind(this), this.element = t5, this.locationMapper = new Fn(this.element), this.pointMapper = new jn(), this.lockCount = 0, b3("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
  }
  getLocationRange() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return false === t5.strict ? this.createLocationRangeFromDOMRange(Mt()) : t5.ignoreLock ? this.currentLocationRange : this.lockedLocationRange ? this.lockedLocationRange : this.currentLocationRange;
  }
  setLocationRange(t5) {
    if (this.lockedLocationRange) return;
    t5 = wt(t5);
    const e4 = this.createDOMRangeFromLocationRange(t5);
    e4 && (Bt(e4), this.updateCurrentLocationRange(t5));
  }
  setLocationRangeFromPointRange(t5) {
    t5 = wt(t5);
    const e4 = this.getLocationAtPoint(t5[0]), i4 = this.getLocationAtPoint(t5[1]);
    this.setLocationRange([e4, i4]);
  }
  getClientRectAtLocationRange(t5) {
    const e4 = this.createDOMRangeFromLocationRange(t5);
    if (e4) return this.getClientRectsForDOMRange(e4)[1];
  }
  locationIsCursorTarget(t5) {
    const e4 = Array.from(this.findNodeAndOffsetFromLocation(t5))[0];
    return F4(e4);
  }
  lock() {
    0 == this.lockCount++ && (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange());
  }
  unlock() {
    if (0 == --this.lockCount) {
      const { lockedLocationRange: t5 } = this;
      if (this.lockedLocationRange = null, null != t5) return this.setLocationRange(t5);
    }
  }
  clearSelection() {
    var t5;
    return null === (t5 = Pt()) || void 0 === t5 ? void 0 : t5.removeAllRanges();
  }
  selectionIsCollapsed() {
    var t5;
    return true === (null === (t5 = Mt()) || void 0 === t5 ? void 0 : t5.collapsed);
  }
  selectionIsExpanded() {
    return !this.selectionIsCollapsed();
  }
  createLocationRangeFromDOMRange(t5, e4) {
    if (null == t5 || !this.domRangeWithinElement(t5)) return;
    const i4 = this.findLocationFromContainerAndOffset(t5.startContainer, t5.startOffset, e4);
    if (!i4) return;
    const n3 = t5.collapsed ? void 0 : this.findLocationFromContainerAndOffset(t5.endContainer, t5.endOffset, e4);
    return wt([i4, n3]);
  }
  didMouseDown() {
    return this.pauseTemporarily();
  }
  pauseTemporarily() {
    let t5;
    this.paused = true;
    const e4 = () => {
      if (this.paused = false, clearTimeout(i4), Array.from(t5).forEach((t6) => {
        t6.destroy();
      }), C3(document, this.element)) return this.selectionDidChange();
    }, i4 = setTimeout(e4, 200);
    t5 = ["mousemove", "keydown"].map((t6) => b3(t6, { onElement: document, withCallback: e4 }));
  }
  selectionDidChange() {
    if (!this.paused && !x4(this.element)) return this.updateCurrentLocationRange();
  }
  updateCurrentLocationRange(t5) {
    var e4, i4;
    if ((null != t5 ? t5 : t5 = this.createLocationRangeFromDOMRange(Mt())) && !Dt(t5, this.currentLocationRange)) return this.currentLocationRange = t5, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.locationRangeDidChange) || void 0 === i4 ? void 0 : i4.call(e4, this.currentLocationRange.slice(0));
  }
  createDOMRangeFromLocationRange(t5) {
    const e4 = this.findContainerAndOffsetFromLocation(t5[0]), i4 = Lt(t5) ? e4 : this.findContainerAndOffsetFromLocation(t5[1]) || e4;
    if (null != e4 && null != i4) {
      const t6 = document.createRange();
      return t6.setStart(...Array.from(e4 || [])), t6.setEnd(...Array.from(i4 || [])), t6;
    }
  }
  getLocationAtPoint(t5) {
    const e4 = this.createDOMRangeFromPoint(t5);
    var i4;
    if (e4) return null === (i4 = this.createLocationRangeFromDOMRange(e4)) || void 0 === i4 ? void 0 : i4[0];
  }
  domRangeWithinElement(t5) {
    return t5.collapsed ? C3(this.element, t5.startContainer) : C3(this.element, t5.startContainer) && C3(this.element, t5.endContainer);
  }
};
Wn.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), Wn.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), Wn.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), Wn.proxyMethod("pointMapper.createDOMRangeFromPoint"), Wn.proxyMethod("pointMapper.getClientRectsForDOMRange");
var Un = Object.freeze({ __proto__: null, Attachment: Wi, AttachmentManager: Sn, AttachmentPiece: Ui, Block: Gi, Composition: kn, Document: on, Editor: On, HTMLParser: cn, HTMLSanitizer: ui, LineBreakInsertion: Rn, LocationMapper: Fn, ManagedAttachment: En, Piece: _i, PointMapper: jn, SelectionManager: Wn, SplittableList: zi, StringPiece: Vi, Text: Ki, UndoManager: Tn });
var Vn = Object.freeze({ __proto__: null, ObjectView: ie, AttachmentView: gi, BlockView: xi, DocumentView: Ci, PieceView: bi, PreviewableAttachmentView: fi, TextView: vi });
var { lang: zn, css: qn, keyNames: Hn } = z3;
var Jn = function(t5) {
  return function() {
    const e4 = t5.apply(this, arguments);
    e4.do(), this.undos || (this.undos = []), this.undos.push(e4.undo);
  };
};
var Kn = class extends q3 {
  constructor(t5, e4, i4) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    super(...arguments), wi(this, "makeElementMutable", Jn(() => ({ do: () => {
      this.element.dataset.trixMutable = true;
    }, undo: () => delete this.element.dataset.trixMutable }))), wi(this, "addToolbar", Jn(() => {
      const t6 = T4({ tagName: "div", className: qn.attachmentToolbar, data: { trixMutable: true }, childNodes: T4({ tagName: "div", className: "trix-button-row", childNodes: T4({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: T4({ tagName: "button", className: "trix-button trix-button--remove", textContent: zn.remove, attributes: { title: zn.remove }, data: { trixAction: "remove" } }) }) }) });
      return this.attachment.isPreviewable() && t6.appendChild(T4({ tagName: "div", className: qn.attachmentMetadataContainer, childNodes: T4({ tagName: "span", className: qn.attachmentMetadata, childNodes: [T4({ tagName: "span", className: qn.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), T4({ tagName: "span", className: qn.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), b3("click", { onElement: t6, withCallback: this.didClickToolbar }), b3("click", { onElement: t6, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), v3("trix-attachment-before-toolbar", { onElement: this.element, attributes: { toolbar: t6, attachment: this.attachment } }), { do: () => this.element.appendChild(t6), undo: () => S2(t6) };
    })), wi(this, "installCaptionEditor", Jn(() => {
      const t6 = T4({ tagName: "textarea", className: qn.attachmentCaptionEditor, attributes: { placeholder: zn.captionPlaceholder }, data: { trixMutable: true } });
      t6.value = this.attachmentPiece.getCaption();
      const e5 = t6.cloneNode();
      e5.classList.add("trix-autoresize-clone"), e5.tabIndex = -1;
      const i5 = function() {
        e5.value = t6.value, t6.style.height = e5.scrollHeight + "px";
      };
      b3("input", { onElement: t6, withCallback: i5 }), b3("input", { onElement: t6, withCallback: this.didInputCaption }), b3("keydown", { onElement: t6, withCallback: this.didKeyDownCaption }), b3("change", { onElement: t6, withCallback: this.didChangeCaption }), b3("blur", { onElement: t6, withCallback: this.didBlurCaption });
      const n4 = this.element.querySelector("figcaption"), r4 = n4.cloneNode();
      return { do: () => {
        if (n4.style.display = "none", r4.appendChild(t6), r4.appendChild(e5), r4.classList.add("".concat(qn.attachmentCaption, "--editing")), n4.parentElement.insertBefore(r4, n4), i5(), this.options.editCaption) return Rt(() => t6.focus());
      }, undo() {
        S2(r4), n4.style.display = null;
      } };
    })), this.didClickToolbar = this.didClickToolbar.bind(this), this.didClickActionButton = this.didClickActionButton.bind(this), this.didKeyDownCaption = this.didKeyDownCaption.bind(this), this.didInputCaption = this.didInputCaption.bind(this), this.didChangeCaption = this.didChangeCaption.bind(this), this.didBlurCaption = this.didBlurCaption.bind(this), this.attachmentPiece = t5, this.element = e4, this.container = i4, this.options = n3, this.attachment = this.attachmentPiece.attachment, "a" === k3(this.element) && (this.element = this.element.firstChild), this.install();
  }
  install() {
    this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() && this.installCaptionEditor();
  }
  uninstall() {
    var t5;
    let e4 = this.undos.pop();
    for (this.savePendingCaption(); e4; ) e4(), e4 = this.undos.pop();
    null === (t5 = this.delegate) || void 0 === t5 || t5.didUninstallAttachmentEditor(this);
  }
  savePendingCaption() {
    if (null != this.pendingCaption) {
      const r4 = this.pendingCaption;
      var t5, e4, i4, n3;
      if (this.pendingCaption = null, r4) null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.attachmentEditorDidRequestUpdatingAttributesForAttachment) || void 0 === e4 || e4.call(t5, { caption: r4 }, this.attachment);
      else null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.attachmentEditorDidRequestRemovingAttributeForAttachment) || void 0 === n3 || n3.call(i4, "caption", this.attachment);
    }
  }
  didClickToolbar(t5) {
    return t5.preventDefault(), t5.stopPropagation();
  }
  didClickActionButton(t5) {
    var e4;
    if ("remove" === t5.target.getAttribute("data-trix-action")) return null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.attachmentEditorDidRequestRemovalOfAttachment(this.attachment);
  }
  didKeyDownCaption(t5) {
    var e4, i4;
    if ("return" === Hn[t5.keyCode]) return t5.preventDefault(), this.savePendingCaption(), null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.attachmentEditorDidRequestDeselectingAttachment) || void 0 === i4 ? void 0 : i4.call(e4, this.attachment);
  }
  didInputCaption(t5) {
    this.pendingCaption = t5.target.value.replace(/\s/g, " ").trim();
  }
  didChangeCaption(t5) {
    return this.savePendingCaption();
  }
  didBlurCaption(t5) {
    return this.savePendingCaption();
  }
};
var Gn = class extends q3 {
  constructor(t5, i4) {
    super(...arguments), this.didFocus = this.didFocus.bind(this), this.didBlur = this.didBlur.bind(this), this.didClickAttachment = this.didClickAttachment.bind(this), this.element = t5, this.composition = i4, this.documentView = new Ci(this.composition.document, { element: this.element }), b3("focus", { onElement: this.element, withCallback: this.didFocus }), b3("blur", { onElement: this.element, withCallback: this.didBlur }), b3("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), b3("mousedown", { onElement: this.element, matchingSelector: e3, withCallback: this.didClickAttachment }), b3("click", { onElement: this.element, matchingSelector: "a".concat(e3), preventDefault: true });
  }
  didFocus(t5) {
    var e4;
    const i4 = () => {
      var t6, e5;
      if (!this.focused) return this.focused = true, null === (t6 = this.delegate) || void 0 === t6 || null === (e5 = t6.compositionControllerDidFocus) || void 0 === e5 ? void 0 : e5.call(t6);
    };
    return (null === (e4 = this.blurPromise) || void 0 === e4 ? void 0 : e4.then(i4)) || i4();
  }
  didBlur(t5) {
    this.blurPromise = new Promise((t6) => Rt(() => {
      var e4, i4;
      x4(this.element) || (this.focused = null, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidBlur) || void 0 === i4 || i4.call(e4));
      return this.blurPromise = null, t6();
    }));
  }
  didClickAttachment(t5, e4) {
    var i4, n3;
    const r4 = this.findAttachmentForElement(e4), o3 = !!y3(t5.target, { matchingSelector: "figcaption" });
    return null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionControllerDidSelectAttachment) || void 0 === n3 ? void 0 : n3.call(i4, r4, { editCaption: o3 });
  }
  getSerializableElement() {
    return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
  }
  render() {
    var t5, e4, i4, n3, r4, o3;
    (this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced()) && (null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionControllerWillSyncDocumentView) || void 0 === n3 || n3.call(i4), this.documentView.sync(), null === (r4 = this.delegate) || void 0 === r4 || null === (o3 = r4.compositionControllerDidSyncDocumentView) || void 0 === o3 || o3.call(r4));
    return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.compositionControllerDidRender) || void 0 === e4 ? void 0 : e4.call(t5);
  }
  rerenderViewForObject(t5) {
    return this.invalidateViewForObject(t5), this.render();
  }
  invalidateViewForObject(t5) {
    return this.documentView.invalidateViewForObject(t5);
  }
  isViewCachingEnabled() {
    return this.documentView.isViewCachingEnabled();
  }
  enableViewCaching() {
    return this.documentView.enableViewCaching();
  }
  disableViewCaching() {
    return this.documentView.disableViewCaching();
  }
  refreshViewCache() {
    return this.documentView.garbageCollectCachedViews();
  }
  isEditingAttachment() {
    return !!this.attachmentEditor;
  }
  installAttachmentEditorForAttachment(t5, e4) {
    var i4;
    if ((null === (i4 = this.attachmentEditor) || void 0 === i4 ? void 0 : i4.attachment) === t5) return;
    const n3 = this.documentView.findElementForObject(t5);
    if (!n3) return;
    this.uninstallAttachmentEditor();
    const r4 = this.composition.document.getAttachmentPieceForAttachment(t5);
    this.attachmentEditor = new Kn(r4, n3, this.element, e4), this.attachmentEditor.delegate = this;
  }
  uninstallAttachmentEditor() {
    var t5;
    return null === (t5 = this.attachmentEditor) || void 0 === t5 ? void 0 : t5.uninstall();
  }
  didUninstallAttachmentEditor() {
    return this.attachmentEditor = null, this.render();
  }
  attachmentEditorDidRequestUpdatingAttributesForAttachment(t5, e4) {
    var i4, n3;
    return null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionControllerWillUpdateAttachment) || void 0 === n3 || n3.call(i4, e4), this.composition.updateAttributesForAttachment(t5, e4);
  }
  attachmentEditorDidRequestRemovingAttributeForAttachment(t5, e4) {
    var i4, n3;
    return null === (i4 = this.delegate) || void 0 === i4 || null === (n3 = i4.compositionControllerWillUpdateAttachment) || void 0 === n3 || n3.call(i4, e4), this.composition.removeAttributeForAttachment(t5, e4);
  }
  attachmentEditorDidRequestRemovalOfAttachment(t5) {
    var e4, i4;
    return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidRequestRemovalOfAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  attachmentEditorDidRequestDeselectingAttachment(t5) {
    var e4, i4;
    return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.compositionControllerDidRequestDeselectingAttachment) || void 0 === i4 ? void 0 : i4.call(e4, t5);
  }
  canSyncDocumentView() {
    return !this.isEditingAttachment();
  }
  findAttachmentForElement(t5) {
    return this.composition.document.getAttachmentById(parseInt(t5.dataset.trixId, 10));
  }
};
var Yn = class extends q3 {
};
var $n = "data-trix-mutable";
var Xn = "[".concat($n, "]");
var Zn = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true };
var Qn = class extends q3 {
  constructor(t5) {
    super(t5), this.didMutate = this.didMutate.bind(this), this.element = t5, this.observer = new window.MutationObserver(this.didMutate), this.start();
  }
  start() {
    return this.reset(), this.observer.observe(this.element, Zn);
  }
  stop() {
    return this.observer.disconnect();
  }
  didMutate(t5) {
    var e4, i4;
    if (this.mutations.push(...Array.from(this.findSignificantMutations(t5) || [])), this.mutations.length) return null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.elementDidMutate) || void 0 === i4 || i4.call(e4, this.getMutationSummary()), this.reset();
  }
  reset() {
    this.mutations = [];
  }
  findSignificantMutations(t5) {
    return t5.filter((t6) => this.mutationIsSignificant(t6));
  }
  mutationIsSignificant(t5) {
    if (this.nodeIsMutable(t5.target)) return false;
    for (const e4 of Array.from(this.nodesModifiedByMutation(t5))) if (this.nodeIsSignificant(e4)) return true;
    return false;
  }
  nodeIsSignificant(t5) {
    return t5 !== this.element && !this.nodeIsMutable(t5) && !M2(t5);
  }
  nodeIsMutable(t5) {
    return y3(t5, { matchingSelector: Xn });
  }
  nodesModifiedByMutation(t5) {
    const e4 = [];
    switch (t5.type) {
      case "attributes":
        t5.attributeName !== $n && e4.push(t5.target);
        break;
      case "characterData":
        e4.push(t5.target.parentNode), e4.push(t5.target);
        break;
      case "childList":
        e4.push(...Array.from(t5.addedNodes || [])), e4.push(...Array.from(t5.removedNodes || []));
    }
    return e4;
  }
  getMutationSummary() {
    return this.getTextMutationSummary();
  }
  getTextMutationSummary() {
    const { additions: t5, deletions: e4 } = this.getTextChangesFromCharacterData(), i4 = this.getTextChangesFromChildList();
    Array.from(i4.additions).forEach((e5) => {
      Array.from(t5).includes(e5) || t5.push(e5);
    }), e4.push(...Array.from(i4.deletions || []));
    const n3 = {}, r4 = t5.join("");
    r4 && (n3.textAdded = r4);
    const o3 = e4.join("");
    return o3 && (n3.textDeleted = o3), n3;
  }
  getMutationsByType(t5) {
    return Array.from(this.mutations).filter((e4) => e4.type === t5);
  }
  getTextChangesFromChildList() {
    let t5, e4;
    const i4 = [], n3 = [];
    Array.from(this.getMutationsByType("childList")).forEach((t6) => {
      i4.push(...Array.from(t6.addedNodes || [])), n3.push(...Array.from(t6.removedNodes || []));
    });
    0 === i4.length && 1 === n3.length && I3(n3[0]) ? (t5 = [], e4 = ["\n"]) : (t5 = tr(i4), e4 = tr(n3));
    const r4 = t5.filter((t6, i5) => t6 !== e4[i5]).map(Wt), o3 = e4.filter((e5, i5) => e5 !== t5[i5]).map(Wt);
    return { additions: r4, deletions: o3 };
  }
  getTextChangesFromCharacterData() {
    let t5, e4;
    const i4 = this.getMutationsByType("characterData");
    if (i4.length) {
      const n3 = i4[0], r4 = i4[i4.length - 1], o3 = function(t6, e5) {
        let i5, n4;
        return t6 = X2.box(t6), (e5 = X2.box(e5)).length < t6.length ? [n4, i5] = zt(t6, e5) : [i5, n4] = zt(e5, t6), { added: i5, removed: n4 };
      }(Wt(n3.oldValue), Wt(r4.target.data));
      t5 = o3.added, e4 = o3.removed;
    }
    return { additions: t5 ? [t5] : [], deletions: e4 ? [e4] : [] };
  }
};
var tr = function() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  const e4 = [];
  for (const i4 of Array.from(t5)) switch (i4.nodeType) {
    case Node.TEXT_NODE:
      e4.push(i4.data);
      break;
    case Node.ELEMENT_NODE:
      "br" === k3(i4) ? e4.push("\n") : e4.push(...Array.from(tr(i4.childNodes) || []));
  }
  return e4;
};
var er = class extends ee {
  constructor(t5) {
    super(...arguments), this.file = t5;
  }
  perform(t5) {
    const e4 = new FileReader();
    return e4.onerror = () => t5(false), e4.onload = () => {
      e4.onerror = null;
      try {
        e4.abort();
      } catch (t6) {
      }
      return t5(true, this.file);
    }, e4.readAsArrayBuffer(this.file);
  }
};
var ir = class {
  constructor(t5) {
    this.element = t5;
  }
  shouldIgnore(t5) {
    return !!a3.samsungAndroid && (this.previousEvent = this.event, this.event = t5, this.checkSamsungKeyboardBuggyModeStart(), this.checkSamsungKeyboardBuggyModeEnd(), this.buggyMode);
  }
  checkSamsungKeyboardBuggyModeStart() {
    this.insertingLongTextAfterUnidentifiedChar() && nr(this.element.innerText, this.event.data) && (this.buggyMode = true, this.event.preventDefault());
  }
  checkSamsungKeyboardBuggyModeEnd() {
    this.buggyMode && "insertText" !== this.event.inputType && (this.buggyMode = false);
  }
  insertingLongTextAfterUnidentifiedChar() {
    var t5;
    return this.isBeforeInputInsertText() && this.previousEventWasUnidentifiedKeydown() && (null === (t5 = this.event.data) || void 0 === t5 ? void 0 : t5.length) > 50;
  }
  isBeforeInputInsertText() {
    return "beforeinput" === this.event.type && "insertText" === this.event.inputType;
  }
  previousEventWasUnidentifiedKeydown() {
    var t5, e4;
    return "keydown" === (null === (t5 = this.previousEvent) || void 0 === t5 ? void 0 : t5.type) && "Unidentified" === (null === (e4 = this.previousEvent) || void 0 === e4 ? void 0 : e4.key);
  }
};
var nr = (t5, e4) => or(t5) === or(e4);
var rr = new RegExp("(".concat("\uFFFC", "|").concat(d2, "|").concat(g4, "|\\s)+"), "g");
var or = (t5) => t5.replace(rr, " ").trim();
var sr = class extends q3 {
  constructor(t5) {
    super(...arguments), this.element = t5, this.mutationObserver = new Qn(this.element), this.mutationObserver.delegate = this, this.flakyKeyboardDetector = new ir(this.element);
    for (const t6 in this.constructor.events) b3(t6, { onElement: this.element, withCallback: this.handlerFor(t6) });
  }
  elementDidMutate(t5) {
  }
  editorWillSyncDocumentView() {
    return this.mutationObserver.stop();
  }
  editorDidSyncDocumentView() {
    return this.mutationObserver.start();
  }
  requestRender() {
    var t5, e4;
    return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidRequestRender) || void 0 === e4 ? void 0 : e4.call(t5);
  }
  requestReparse() {
    var t5, e4;
    return null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidRequestReparse) || void 0 === e4 || e4.call(t5), this.requestRender();
  }
  attachFiles(t5) {
    const e4 = Array.from(t5).map((t6) => new er(t6));
    return Promise.all(e4).then((t6) => {
      this.handleInput(function() {
        var e5, i4;
        return null === (e5 = this.delegate) || void 0 === e5 || e5.inputControllerWillAttachFiles(), null === (i4 = this.responder) || void 0 === i4 || i4.insertFiles(t6), this.requestRender();
      });
    });
  }
  handlerFor(t5) {
    return (e4) => {
      e4.defaultPrevented || this.handleInput(() => {
        if (!x4(this.element)) {
          if (this.flakyKeyboardDetector.shouldIgnore(e4)) return;
          this.eventName = t5, this.constructor.events[t5].call(this, e4);
        }
      });
    };
  }
  handleInput(t5) {
    try {
      var e4;
      null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillHandleInput(), t5.call(this);
    } finally {
      var i4;
      null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerDidHandleInput();
    }
  }
  createLinkHTML(t5, e4) {
    const i4 = document.createElement("a");
    return i4.href = t5, i4.textContent = e4 || t5, i4.outerHTML;
  }
};
var ar;
wi(sr, "events", {});
var { browser: lr, keyNames: cr } = z3;
var ur = 0;
var hr = class extends sr {
  constructor() {
    super(...arguments), this.resetInputSummary();
  }
  setInputSummary() {
    let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.inputSummary.eventName = this.eventName;
    for (const e4 in t5) {
      const i4 = t5[e4];
      this.inputSummary[e4] = i4;
    }
    return this.inputSummary;
  }
  resetInputSummary() {
    this.inputSummary = {};
  }
  reset() {
    return this.resetInputSummary(), Ft.reset();
  }
  elementDidMutate(t5) {
    var e4, i4;
    return this.isComposing() ? null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidAllowUnhandledInput) || void 0 === i4 ? void 0 : i4.call(e4) : this.handleInput(function() {
      return this.mutationIsSignificant(t5) && (this.mutationIsExpected(t5) ? this.requestRender() : this.requestReparse()), this.reset();
    });
  }
  mutationIsExpected(t5) {
    let { textAdded: e4, textDeleted: i4 } = t5;
    if (this.inputSummary.preferDocument) return true;
    const n3 = null != e4 ? e4 === this.inputSummary.textAdded : !this.inputSummary.textAdded, r4 = null != i4 ? this.inputSummary.didDelete : !this.inputSummary.didDelete, o3 = ["\n", " \n"].includes(e4) && !n3, s4 = "\n" === i4 && !r4;
    if (o3 && !s4 || s4 && !o3) {
      const t6 = this.getSelectedRange();
      if (t6) {
        var a4;
        const i5 = o3 ? e4.replace(/\n$/, "").length || -1 : (null == e4 ? void 0 : e4.length) || 1;
        if (null !== (a4 = this.responder) && void 0 !== a4 && a4.positionIsBlockBreak(t6[1] + i5)) return true;
      }
    }
    return n3 && r4;
  }
  mutationIsSignificant(t5) {
    var e4;
    const i4 = Object.keys(t5).length > 0, n3 = "" === (null === (e4 = this.compositionInput) || void 0 === e4 ? void 0 : e4.getEndData());
    return i4 || !n3;
  }
  getCompositionInput() {
    if (this.isComposing()) return this.compositionInput;
    this.compositionInput = new fr(this);
  }
  isComposing() {
    return this.compositionInput && !this.compositionInput.isEnded();
  }
  deleteInDirection(t5, e4) {
    var i4;
    return false !== (null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.deleteInDirection(t5)) ? this.setInputSummary({ didDelete: true }) : e4 ? (e4.preventDefault(), this.requestRender()) : void 0;
  }
  serializeSelectionToDataTransfer(t5) {
    var e4;
    if (!function(t6) {
      if (null == t6 || !t6.setData) return false;
      for (const e5 in Ct) {
        const i5 = Ct[e5];
        try {
          if (t6.setData(e5, i5), !t6.getData(e5) === i5) return false;
        } catch (t7) {
          return false;
        }
      }
      return true;
    }(t5)) return;
    const i4 = null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.getSelectedDocument().toSerializableDocument();
    return t5.setData("application/x-trix-document", JSON.stringify(i4)), t5.setData("text/html", Ci.render(i4).innerHTML), t5.setData("text/plain", i4.toString().replace(/\n$/, "")), true;
  }
  canAcceptDataTransfer(t5) {
    const e4 = {};
    return Array.from((null == t5 ? void 0 : t5.types) || []).forEach((t6) => {
      e4[t6] = true;
    }), e4.Files || e4["application/x-trix-document"] || e4["text/html"] || e4["text/plain"];
  }
  getPastedHTMLUsingHiddenElement(t5) {
    const e4 = this.getSelectedRange(), i4 = { position: "absolute", left: "".concat(window.pageXOffset, "px"), top: "".concat(window.pageYOffset, "px"), opacity: 0 }, n3 = T4({ style: i4, tagName: "div", editable: true });
    return document.body.appendChild(n3), n3.focus(), requestAnimationFrame(() => {
      const i5 = n3.innerHTML;
      return S2(n3), this.setSelectedRange(e4), t5(i5);
    });
  }
};
wi(hr, "events", { keydown(t5) {
  this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true;
  const e4 = cr[t5.keyCode];
  if (e4) {
    var i4;
    let n4 = this.keys;
    ["ctrl", "alt", "shift", "meta"].forEach((e5) => {
      var i5;
      t5["".concat(e5, "Key")] && ("ctrl" === e5 && (e5 = "control"), n4 = null === (i5 = n4) || void 0 === i5 ? void 0 : i5[e5]);
    }), null != (null === (i4 = n4) || void 0 === i4 ? void 0 : i4[e4]) && (this.setInputSummary({ keyName: e4 }), Ft.reset(), n4[e4].call(this, t5));
  }
  if (St(t5)) {
    const e5 = String.fromCharCode(t5.keyCode).toLowerCase();
    if (e5) {
      var n3;
      const i5 = ["alt", "shift"].map((e6) => {
        if (t5["".concat(e6, "Key")]) return e6;
      }).filter((t6) => t6);
      i5.push(e5), null !== (n3 = this.delegate) && void 0 !== n3 && n3.inputControllerDidReceiveKeyboardCommand(i5) && t5.preventDefault();
    }
  }
}, keypress(t5) {
  if (null != this.inputSummary.eventName) return;
  if (t5.metaKey) return;
  if (t5.ctrlKey && !t5.altKey) return;
  const e4 = mr(t5);
  var i4, n3;
  return e4 ? (null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformTyping(), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(e4), this.setInputSummary({ textAdded: e4, didDelete: this.selectionIsExpanded() })) : void 0;
}, textInput(t5) {
  const { data: e4 } = t5, { textAdded: i4 } = this.inputSummary;
  if (i4 && i4 !== e4 && i4.toUpperCase() === e4) {
    var n3;
    const t6 = this.getSelectedRange();
    return this.setSelectedRange([t6[0], t6[1] + i4.length]), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(e4), this.setInputSummary({ textAdded: e4 }), this.setSelectedRange(t6);
  }
}, dragenter(t5) {
  t5.preventDefault();
}, dragstart(t5) {
  var e4, i4;
  return this.serializeSelectionToDataTransfer(t5.dataTransfer), this.draggedRange = this.getSelectedRange(), null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidStartDrag) || void 0 === i4 ? void 0 : i4.call(e4);
}, dragover(t5) {
  if (this.draggedRange || this.canAcceptDataTransfer(t5.dataTransfer)) {
    t5.preventDefault();
    const n3 = { x: t5.clientX, y: t5.clientY };
    var e4, i4;
    if (!Tt(n3, this.draggingPoint)) return this.draggingPoint = n3, null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidReceiveDragOverPoint) || void 0 === i4 ? void 0 : i4.call(e4, this.draggingPoint);
  }
}, dragend(t5) {
  var e4, i4;
  null === (e4 = this.delegate) || void 0 === e4 || null === (i4 = e4.inputControllerDidCancelDrag) || void 0 === i4 || i4.call(e4), this.draggedRange = null, this.draggingPoint = null;
}, drop(t5) {
  var e4, i4;
  t5.preventDefault();
  const n3 = null === (e4 = t5.dataTransfer) || void 0 === e4 ? void 0 : e4.files, r4 = t5.dataTransfer.getData("application/x-trix-document"), o3 = { x: t5.clientX, y: t5.clientY };
  if (null === (i4 = this.responder) || void 0 === i4 || i4.setLocationRangeFromPointRange(o3), null != n3 && n3.length) this.attachFiles(n3);
  else if (this.draggedRange) {
    var s4, a4;
    null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillMoveText(), null === (a4 = this.responder) || void 0 === a4 || a4.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender();
  } else if (r4) {
    var l4;
    const t6 = on.fromJSONString(r4);
    null === (l4 = this.responder) || void 0 === l4 || l4.insertDocument(t6), this.requestRender();
  }
  this.draggedRange = null, this.draggingPoint = null;
}, cut(t5) {
  var e4, i4;
  if (null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionIsExpanded() && (this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault(), null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillCutText(), this.deleteInDirection("backward"), t5.defaultPrevented)) return this.requestRender();
}, copy(t5) {
  var e4;
  null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionIsExpanded() && this.serializeSelectionToDataTransfer(t5.clipboardData) && t5.preventDefault();
}, paste(t5) {
  const e4 = t5.clipboardData || t5.testClipboardData, i4 = { clipboard: e4 };
  if (!e4 || pr(t5)) return void this.getPastedHTMLUsingHiddenElement((t6) => {
    var e5, n4, r5;
    return i4.type = "text/html", i4.html = t6, null === (e5 = this.delegate) || void 0 === e5 || e5.inputControllerWillPaste(i4), null === (n4 = this.responder) || void 0 === n4 || n4.insertHTML(i4.html), this.requestRender(), null === (r5 = this.delegate) || void 0 === r5 ? void 0 : r5.inputControllerDidPaste(i4);
  });
  const n3 = e4.getData("URL"), r4 = e4.getData("text/html"), o3 = e4.getData("public.url-name");
  if (n3) {
    var s4, a4, l4;
    let t6;
    i4.type = "text/html", t6 = o3 ? Vt(o3).trim() : n3, i4.html = this.createLinkHTML(n3, t6), null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: t6, didDelete: this.selectionIsExpanded() }), null === (a4 = this.responder) || void 0 === a4 || a4.insertHTML(i4.html), this.requestRender(), null === (l4 = this.delegate) || void 0 === l4 || l4.inputControllerDidPaste(i4);
  } else if (Et(e4)) {
    var c4, u4, h4;
    i4.type = "text/plain", i4.string = e4.getData("text/plain"), null === (c4 = this.delegate) || void 0 === c4 || c4.inputControllerWillPaste(i4), this.setInputSummary({ textAdded: i4.string, didDelete: this.selectionIsExpanded() }), null === (u4 = this.responder) || void 0 === u4 || u4.insertString(i4.string), this.requestRender(), null === (h4 = this.delegate) || void 0 === h4 || h4.inputControllerDidPaste(i4);
  } else if (r4) {
    var d3, g5, m5;
    i4.type = "text/html", i4.html = r4, null === (d3 = this.delegate) || void 0 === d3 || d3.inputControllerWillPaste(i4), null === (g5 = this.responder) || void 0 === g5 || g5.insertHTML(i4.html), this.requestRender(), null === (m5 = this.delegate) || void 0 === m5 || m5.inputControllerDidPaste(i4);
  } else if (Array.from(e4.types).includes("Files")) {
    var p4, f4;
    const t6 = null === (p4 = e4.items) || void 0 === p4 || null === (p4 = p4[0]) || void 0 === p4 || null === (f4 = p4.getAsFile) || void 0 === f4 ? void 0 : f4.call(p4);
    if (t6) {
      var b4, v4, A4;
      const e5 = dr(t6);
      !t6.name && e5 && (t6.name = "pasted-file-".concat(++ur, ".").concat(e5)), i4.type = "File", i4.file = t6, null === (b4 = this.delegate) || void 0 === b4 || b4.inputControllerWillAttachFiles(), null === (v4 = this.responder) || void 0 === v4 || v4.insertFile(i4.file), this.requestRender(), null === (A4 = this.delegate) || void 0 === A4 || A4.inputControllerDidPaste(i4);
    }
  }
  t5.preventDefault();
}, compositionstart(t5) {
  return this.getCompositionInput().start(t5.data);
}, compositionupdate(t5) {
  return this.getCompositionInput().update(t5.data);
}, compositionend(t5) {
  return this.getCompositionInput().end(t5.data);
}, beforeinput(t5) {
  this.inputSummary.didInput = true;
}, input(t5) {
  return this.inputSummary.didInput = true, t5.stopPropagation();
} }), wi(hr, "keys", { backspace(t5) {
  var e4;
  return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
}, delete(t5) {
  var e4;
  return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
}, return(t5) {
  var e4, i4;
  return this.setInputSummary({ preferDocument: true }), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.insertLineBreak();
}, tab(t5) {
  var e4, i4;
  null !== (e4 = this.responder) && void 0 !== e4 && e4.canIncreaseNestingLevel() && (null === (i4 = this.responder) || void 0 === i4 || i4.increaseNestingLevel(), this.requestRender(), t5.preventDefault());
}, left(t5) {
  var e4;
  if (this.selectionIsInCursorTarget()) return t5.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("backward");
}, right(t5) {
  var e4;
  if (this.selectionIsInCursorTarget()) return t5.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("forward");
}, control: { d(t5) {
  var e4;
  return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t5);
}, h(t5) {
  var e4;
  return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t5);
}, o(t5) {
  var e4, i4;
  return t5.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.insertString("\n", { updatePosition: false }), this.requestRender();
} }, shift: { return(t5) {
  var e4, i4;
  null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.insertString("\n"), this.requestRender(), t5.preventDefault();
}, tab(t5) {
  var e4, i4;
  null !== (e4 = this.responder) && void 0 !== e4 && e4.canDecreaseNestingLevel() && (null === (i4 = this.responder) || void 0 === i4 || i4.decreaseNestingLevel(), this.requestRender(), t5.preventDefault());
}, left(t5) {
  if (this.selectionIsInCursorTarget()) return t5.preventDefault(), this.expandSelectionInDirection("backward");
}, right(t5) {
  if (this.selectionIsInCursorTarget()) return t5.preventDefault(), this.expandSelectionInDirection("forward");
} }, alt: { backspace(t5) {
  var e4;
  return this.setInputSummary({ preferDocument: false }), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.inputControllerWillPerformTyping();
} }, meta: { backspace(t5) {
  var e4;
  return this.setInputSummary({ preferDocument: false }), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.inputControllerWillPerformTyping();
} } }), hr.proxyMethod("responder?.getSelectedRange"), hr.proxyMethod("responder?.setSelectedRange"), hr.proxyMethod("responder?.expandSelectionInDirection"), hr.proxyMethod("responder?.selectionIsInCursorTarget"), hr.proxyMethod("responder?.selectionIsExpanded");
var dr = (t5) => {
  var e4;
  return null === (e4 = t5.type) || void 0 === e4 || null === (e4 = e4.match(/\/(\w+)$/)) || void 0 === e4 ? void 0 : e4[1];
};
var gr = !(null === (ar = " ".codePointAt) || void 0 === ar || !ar.call(" ", 0));
var mr = function(t5) {
  if (t5.key && gr && t5.key.codePointAt(0) === t5.keyCode) return t5.key;
  {
    let e4;
    if (null === t5.which ? e4 = t5.keyCode : 0 !== t5.which && 0 !== t5.charCode && (e4 = t5.charCode), null != e4 && "escape" !== cr[e4]) return X2.fromCodepoints([e4]).toString();
  }
};
var pr = function(t5) {
  const e4 = t5.clipboardData;
  if (e4) {
    if (e4.types.includes("text/html")) {
      for (const t6 of e4.types) {
        const i4 = /^CorePasteboardFlavorType/.test(t6), n3 = /^dyn\./.test(t6) && e4.getData(t6);
        if (i4 || n3) return true;
      }
      return false;
    }
    {
      const t6 = e4.types.includes("com.apple.webarchive"), i4 = e4.types.includes("com.apple.flat-rtfd");
      return t6 || i4;
    }
  }
};
var fr = class extends q3 {
  constructor(t5) {
    super(...arguments), this.inputController = t5, this.responder = this.inputController.responder, this.delegate = this.inputController.delegate, this.inputSummary = this.inputController.inputSummary, this.data = {};
  }
  start(t5) {
    if (this.data.start = t5, this.isSignificant()) {
      var e4, i4;
      if ("keypress" === this.inputSummary.eventName && this.inputSummary.textAdded) null === (i4 = this.responder) || void 0 === i4 || i4.deleteInDirection("left");
      this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.getSelectedRange();
    }
  }
  update(t5) {
    if (this.data.update = t5, this.isSignificant()) {
      const t6 = this.selectPlaceholder();
      t6 && (this.forgetPlaceholder(), this.range = t6);
    }
  }
  end(t5) {
    return this.data.end = t5, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.setSelectedRange(this.range), null === (n3 = this.responder) || void 0 === n3 || n3.insertString(this.data.end), null === (r4 = this.responder) || void 0 === r4 ? void 0 : r4.setSelectedRange(this.range[0] + this.data.end.length)) : null != this.data.start || null != this.data.update ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
    var e4, i4, n3, r4;
  }
  getEndData() {
    return this.data.end;
  }
  isEnded() {
    return null != this.getEndData();
  }
  isSignificant() {
    return !lr.composesExistingText || this.inputSummary.didInput;
  }
  canApplyToDocument() {
    var t5, e4;
    return 0 === (null === (t5 = this.data.start) || void 0 === t5 ? void 0 : t5.length) && (null === (e4 = this.data.end) || void 0 === e4 ? void 0 : e4.length) > 0 && this.range;
  }
};
fr.proxyMethod("inputController.setInputSummary"), fr.proxyMethod("inputController.requestRender"), fr.proxyMethod("inputController.requestReparse"), fr.proxyMethod("responder?.selectionIsExpanded"), fr.proxyMethod("responder?.insertPlaceholder"), fr.proxyMethod("responder?.selectPlaceholder"), fr.proxyMethod("responder?.forgetPlaceholder");
var br = class extends sr {
  constructor() {
    super(...arguments), this.render = this.render.bind(this);
  }
  elementDidMutate() {
    return this.scheduledRender ? this.composing ? null === (t5 = this.delegate) || void 0 === t5 || null === (e4 = t5.inputControllerDidAllowUnhandledInput) || void 0 === e4 ? void 0 : e4.call(t5) : void 0 : this.reparse();
    var t5, e4;
  }
  scheduleRender() {
    return this.scheduledRender ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
  }
  render() {
    var t5, e4;
    (cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing) || (null === (e4 = this.delegate) || void 0 === e4 || e4.render());
    null === (t5 = this.afterRender) || void 0 === t5 || t5.call(this), this.afterRender = null;
  }
  reparse() {
    var t5;
    return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.reparse();
  }
  insertString() {
    var t5;
    let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i4 = arguments.length > 1 ? arguments[1] : void 0;
    return null === (t5 = this.delegate) || void 0 === t5 || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertString(e4, i4);
    });
  }
  toggleAttributeIfSupported(t5) {
    var e4;
    if (gt().includes(t5)) return null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
      var e5;
      return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.toggleCurrentAttribute(t5);
    });
  }
  activateAttributeIfSupported(t5, e4) {
    var i4;
    if (gt().includes(t5)) return null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformFormatting(t5), this.withTargetDOMRange(function() {
      var i5;
      return null === (i5 = this.responder) || void 0 === i5 ? void 0 : i5.setCurrentAttribute(t5, e4);
    });
  }
  deleteInDirection(t5) {
    let { recordUndoEntry: e4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { recordUndoEntry: true };
    var i4;
    e4 && (null === (i4 = this.delegate) || void 0 === i4 || i4.inputControllerWillPerformTyping());
    const n3 = () => {
      var e5;
      return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.deleteInDirection(t5);
    }, r4 = this.getTargetDOMRange({ minLength: this.composing ? 1 : 2 });
    return r4 ? this.withTargetDOMRange(r4, n3) : n3();
  }
  withTargetDOMRange(t5, e4) {
    var i4;
    return "function" == typeof t5 && (e4 = t5, t5 = this.getTargetDOMRange()), t5 ? null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.withTargetDOMRange(t5, e4.bind(this)) : (Ft.reset(), e4.call(this));
  }
  getTargetDOMRange() {
    var t5, e4;
    let { minLength: i4 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { minLength: 0 };
    const n3 = null === (t5 = (e4 = this.event).getTargetRanges) || void 0 === t5 ? void 0 : t5.call(e4);
    if (n3 && n3.length) {
      const t6 = vr(n3[0]);
      if (0 === i4 || t6.toString().length >= i4) return t6;
    }
  }
  withEvent(t5, e4) {
    let i4;
    this.event = t5;
    try {
      i4 = e4.call(this);
    } finally {
      this.event = null;
    }
    return i4;
  }
};
wi(br, "events", { keydown(t5) {
  if (St(t5)) {
    var e4;
    const i4 = Er(t5);
    null !== (e4 = this.delegate) && void 0 !== e4 && e4.inputControllerDidReceiveKeyboardCommand(i4) && t5.preventDefault();
  } else {
    let e5 = t5.key;
    t5.altKey && (e5 += "+Alt"), t5.shiftKey && (e5 += "+Shift");
    const i4 = this.constructor.keys[e5];
    if (i4) return this.withEvent(t5, i4);
  }
}, paste(t5) {
  var e4;
  let i4;
  const n3 = null === (e4 = t5.clipboardData) || void 0 === e4 ? void 0 : e4.getData("URL");
  return xr(t5) ? (t5.preventDefault(), this.attachFiles(t5.clipboardData.files)) : Cr(t5) ? (t5.preventDefault(), i4 = { type: "text/plain", string: t5.clipboardData.getData("text/plain") }, null === (r4 = this.delegate) || void 0 === r4 || r4.inputControllerWillPaste(i4), null === (o3 = this.responder) || void 0 === o3 || o3.insertString(i4.string), this.render(), null === (s4 = this.delegate) || void 0 === s4 ? void 0 : s4.inputControllerDidPaste(i4)) : n3 ? (t5.preventDefault(), i4 = { type: "text/html", html: this.createLinkHTML(n3) }, null === (a4 = this.delegate) || void 0 === a4 || a4.inputControllerWillPaste(i4), null === (l4 = this.responder) || void 0 === l4 || l4.insertHTML(i4.html), this.render(), null === (c4 = this.delegate) || void 0 === c4 ? void 0 : c4.inputControllerDidPaste(i4)) : void 0;
  var r4, o3, s4, a4, l4, c4;
}, beforeinput(t5) {
  const e4 = this.constructor.inputTypes[t5.inputType], i4 = (n3 = t5, !(!/iPhone|iPad/.test(navigator.userAgent) || n3.inputType && "insertParagraph" !== n3.inputType));
  var n3;
  e4 && (this.withEvent(t5, e4), i4 || this.scheduleRender()), i4 && this.render();
}, input(t5) {
  Ft.reset();
}, dragstart(t5) {
  var e4, i4;
  null !== (e4 = this.responder) && void 0 !== e4 && e4.selectionContainsAttachments() && (t5.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: null === (i4 = this.responder) || void 0 === i4 ? void 0 : i4.getSelectedRange(), point: Sr(t5) });
}, dragenter(t5) {
  Ar(t5) && t5.preventDefault();
}, dragover(t5) {
  if (this.dragging) {
    t5.preventDefault();
    const i4 = Sr(t5);
    var e4;
    if (!Tt(i4, this.dragging.point)) return this.dragging.point = i4, null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.setLocationRangeFromPointRange(i4);
  } else Ar(t5) && t5.preventDefault();
}, drop(t5) {
  var e4, i4;
  if (this.dragging) return t5.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillMoveText(), null === (i4 = this.responder) || void 0 === i4 || i4.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender();
  if (Ar(t5)) {
    var n3;
    t5.preventDefault();
    const e5 = Sr(t5);
    return null === (n3 = this.responder) || void 0 === n3 || n3.setLocationRangeFromPointRange(e5), this.attachFiles(t5.dataTransfer.files);
  }
}, dragend() {
  var t5;
  this.dragging && (null === (t5 = this.responder) || void 0 === t5 || t5.setSelectedRange(this.dragging.range), this.dragging = null);
}, compositionend(t5) {
  this.composing && (this.composing = false, a3.recentAndroid || this.scheduleRender());
} }), wi(br, "keys", { ArrowLeft() {
  var t5, e4;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageMovingCursorInDirection("backward")) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("backward");
}, ArrowRight() {
  var t5, e4;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageMovingCursorInDirection("forward")) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 ? void 0 : e4.moveCursorInDirection("forward");
}, Backspace() {
  var t5, e4, i4;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.shouldManageDeletingInDirection("backward")) return this.event.preventDefault(), null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillPerformTyping(), null === (i4 = this.responder) || void 0 === i4 || i4.deleteInDirection("backward"), this.render();
}, Tab() {
  var t5, e4;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canIncreaseNestingLevel()) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 || e4.increaseNestingLevel(), this.render();
}, "Tab+Shift"() {
  var t5, e4;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canDecreaseNestingLevel()) return this.event.preventDefault(), null === (e4 = this.responder) || void 0 === e4 || e4.decreaseNestingLevel(), this.render();
} }), wi(br, "inputTypes", { deleteByComposition() {
  return this.deleteInDirection("backward", { recordUndoEntry: false });
}, deleteByCut() {
  return this.deleteInDirection("backward");
}, deleteByDrag() {
  return this.event.preventDefault(), this.withTargetDOMRange(function() {
    var t5;
    this.deleteByDragRange = null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.getSelectedRange();
  });
}, deleteCompositionText() {
  return this.deleteInDirection("backward", { recordUndoEntry: false });
}, deleteContent() {
  return this.deleteInDirection("backward");
}, deleteContentBackward() {
  return this.deleteInDirection("backward");
}, deleteContentForward() {
  return this.deleteInDirection("forward");
}, deleteEntireSoftLine() {
  return this.deleteInDirection("forward");
}, deleteHardLineBackward() {
  return this.deleteInDirection("backward");
}, deleteHardLineForward() {
  return this.deleteInDirection("forward");
}, deleteSoftLineBackward() {
  return this.deleteInDirection("backward");
}, deleteSoftLineForward() {
  return this.deleteInDirection("forward");
}, deleteWordBackward() {
  return this.deleteInDirection("backward");
}, deleteWordForward() {
  return this.deleteInDirection("forward");
}, formatBackColor() {
  return this.activateAttributeIfSupported("backgroundColor", this.event.data);
}, formatBold() {
  return this.toggleAttributeIfSupported("bold");
}, formatFontColor() {
  return this.activateAttributeIfSupported("color", this.event.data);
}, formatFontName() {
  return this.activateAttributeIfSupported("font", this.event.data);
}, formatIndent() {
  var t5;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canIncreaseNestingLevel()) return this.withTargetDOMRange(function() {
    var t6;
    return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.increaseNestingLevel();
  });
}, formatItalic() {
  return this.toggleAttributeIfSupported("italic");
}, formatJustifyCenter() {
  return this.toggleAttributeIfSupported("justifyCenter");
}, formatJustifyFull() {
  return this.toggleAttributeIfSupported("justifyFull");
}, formatJustifyLeft() {
  return this.toggleAttributeIfSupported("justifyLeft");
}, formatJustifyRight() {
  return this.toggleAttributeIfSupported("justifyRight");
}, formatOutdent() {
  var t5;
  if (null !== (t5 = this.responder) && void 0 !== t5 && t5.canDecreaseNestingLevel()) return this.withTargetDOMRange(function() {
    var t6;
    return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.decreaseNestingLevel();
  });
}, formatRemove() {
  this.withTargetDOMRange(function() {
    for (const i4 in null === (t5 = this.responder) || void 0 === t5 ? void 0 : t5.getCurrentAttributes()) {
      var t5, e4;
      null === (e4 = this.responder) || void 0 === e4 || e4.removeCurrentAttribute(i4);
    }
  });
}, formatSetBlockTextDirection() {
  return this.activateAttributeIfSupported("blockDir", this.event.data);
}, formatSetInlineTextDirection() {
  return this.activateAttributeIfSupported("textDir", this.event.data);
}, formatStrikeThrough() {
  return this.toggleAttributeIfSupported("strike");
}, formatSubscript() {
  return this.toggleAttributeIfSupported("sub");
}, formatSuperscript() {
  return this.toggleAttributeIfSupported("sup");
}, formatUnderline() {
  return this.toggleAttributeIfSupported("underline");
}, historyRedo() {
  var t5;
  return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerWillPerformRedo();
}, historyUndo() {
  var t5;
  return null === (t5 = this.delegate) || void 0 === t5 ? void 0 : t5.inputControllerWillPerformUndo();
}, insertCompositionText() {
  return this.composing = true, this.insertString(this.event.data);
}, insertFromComposition() {
  return this.composing = false, this.insertString(this.event.data);
}, insertFromDrop() {
  const t5 = this.deleteByDragRange;
  var e4;
  if (t5) return this.deleteByDragRange = null, null === (e4 = this.delegate) || void 0 === e4 || e4.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
    var e5;
    return null === (e5 = this.responder) || void 0 === e5 ? void 0 : e5.moveTextFromRange(t5);
  });
}, insertFromPaste() {
  const { dataTransfer: t5 } = this.event, e4 = { dataTransfer: t5 }, i4 = t5.getData("URL"), n3 = t5.getData("text/html");
  if (i4) {
    var r4;
    let n4;
    this.event.preventDefault(), e4.type = "text/html";
    const o4 = t5.getData("public.url-name");
    n4 = o4 ? Vt(o4).trim() : i4, e4.html = this.createLinkHTML(i4, n4), null === (r4 = this.delegate) || void 0 === r4 || r4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertHTML(e4.html);
    }), this.afterRender = () => {
      var t6;
      return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
    };
  } else if (Et(t5)) {
    var o3;
    e4.type = "text/plain", e4.string = t5.getData("text/plain"), null === (o3 = this.delegate) || void 0 === o3 || o3.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertString(e4.string);
    }), this.afterRender = () => {
      var t6;
      return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
    };
  } else if (yr(this.event)) {
    var s4;
    e4.type = "File", e4.file = t5.files[0], null === (s4 = this.delegate) || void 0 === s4 || s4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertFile(e4.file);
    }), this.afterRender = () => {
      var t6;
      return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
    };
  } else if (n3) {
    var a4;
    this.event.preventDefault(), e4.type = "text/html", e4.html = n3, null === (a4 = this.delegate) || void 0 === a4 || a4.inputControllerWillPaste(e4), this.withTargetDOMRange(function() {
      var t6;
      return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertHTML(e4.html);
    }), this.afterRender = () => {
      var t6;
      return null === (t6 = this.delegate) || void 0 === t6 ? void 0 : t6.inputControllerDidPaste(e4);
    };
  }
}, insertFromYank() {
  return this.insertString(this.event.data);
}, insertLineBreak() {
  return this.insertString("\n");
}, insertLink() {
  return this.activateAttributeIfSupported("href", this.event.data);
}, insertOrderedList() {
  return this.toggleAttributeIfSupported("number");
}, insertParagraph() {
  var t5;
  return null === (t5 = this.delegate) || void 0 === t5 || t5.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
    var t6;
    return null === (t6 = this.responder) || void 0 === t6 ? void 0 : t6.insertLineBreak();
  });
}, insertReplacementText() {
  const t5 = this.event.dataTransfer.getData("text/plain"), e4 = this.event.getTargetRanges()[0];
  this.withTargetDOMRange(e4, () => {
    this.insertString(t5, { updatePosition: false });
  });
}, insertText() {
  var t5;
  return this.insertString(this.event.data || (null === (t5 = this.event.dataTransfer) || void 0 === t5 ? void 0 : t5.getData("text/plain")));
}, insertTranspose() {
  return this.insertString(this.event.data);
}, insertUnorderedList() {
  return this.toggleAttributeIfSupported("bullet");
} });
var vr = function(t5) {
  const e4 = document.createRange();
  return e4.setStart(t5.startContainer, t5.startOffset), e4.setEnd(t5.endContainer, t5.endOffset), e4;
};
var Ar = (t5) => {
  var e4;
  return Array.from((null === (e4 = t5.dataTransfer) || void 0 === e4 ? void 0 : e4.types) || []).includes("Files");
};
var yr = (t5) => {
  var e4;
  return (null === (e4 = t5.dataTransfer.files) || void 0 === e4 ? void 0 : e4[0]) && !xr(t5) && !((t6) => {
    let { dataTransfer: e5 } = t6;
    return e5.types.includes("Files") && e5.types.includes("text/html") && e5.getData("text/html").includes("urn:schemas-microsoft-com:office:office");
  })(t5);
};
var xr = function(t5) {
  const e4 = t5.clipboardData;
  if (e4) {
    return Array.from(e4.types).filter((t6) => t6.match(/file/i)).length === e4.types.length && e4.files.length >= 1;
  }
};
var Cr = function(t5) {
  const e4 = t5.clipboardData;
  if (e4) return e4.types.includes("text/plain") && 1 === e4.types.length;
};
var Er = function(t5) {
  const e4 = [];
  return t5.altKey && e4.push("alt"), t5.shiftKey && e4.push("shift"), e4.push(t5.key), e4;
};
var Sr = (t5) => ({ x: t5.clientX, y: t5.clientY });
var Rr = "[data-trix-attribute]";
var kr = "[data-trix-action]";
var Tr = "".concat(Rr, ", ").concat(kr);
var wr = "[data-trix-dialog]";
var Lr = "".concat(wr, "[data-trix-active]");
var Dr = "".concat(wr, " [data-trix-method]");
var Nr = "".concat(wr, " [data-trix-input]");
var Ir = (t5, e4) => (e4 || (e4 = Fr(t5)), t5.querySelector("[data-trix-input][name='".concat(e4, "']")));
var Or = (t5) => t5.getAttribute("data-trix-action");
var Fr = (t5) => t5.getAttribute("data-trix-attribute") || t5.getAttribute("data-trix-dialog-attribute");
var Pr = class extends q3 {
  constructor(t5) {
    super(t5), this.didClickActionButton = this.didClickActionButton.bind(this), this.didClickAttributeButton = this.didClickAttributeButton.bind(this), this.didClickDialogButton = this.didClickDialogButton.bind(this), this.didKeyDownDialogInput = this.didKeyDownDialogInput.bind(this), this.element = t5, this.attributes = {}, this.actions = {}, this.resetDialogInputs(), b3("mousedown", { onElement: this.element, matchingSelector: kr, withCallback: this.didClickActionButton }), b3("mousedown", { onElement: this.element, matchingSelector: Rr, withCallback: this.didClickAttributeButton }), b3("click", { onElement: this.element, matchingSelector: Tr, preventDefault: true }), b3("click", { onElement: this.element, matchingSelector: Dr, withCallback: this.didClickDialogButton }), b3("keydown", { onElement: this.element, matchingSelector: Nr, withCallback: this.didKeyDownDialogInput });
  }
  didClickActionButton(t5, e4) {
    var i4;
    null === (i4 = this.delegate) || void 0 === i4 || i4.toolbarDidClickButton(), t5.preventDefault();
    const n3 = Or(e4);
    return this.getDialog(n3) ? this.toggleDialog(n3) : null === (r4 = this.delegate) || void 0 === r4 ? void 0 : r4.toolbarDidInvokeAction(n3, e4);
    var r4;
  }
  didClickAttributeButton(t5, e4) {
    var i4;
    null === (i4 = this.delegate) || void 0 === i4 || i4.toolbarDidClickButton(), t5.preventDefault();
    const n3 = Fr(e4);
    var r4;
    this.getDialog(n3) ? this.toggleDialog(n3) : null === (r4 = this.delegate) || void 0 === r4 || r4.toolbarDidToggleAttribute(n3);
    return this.refreshAttributeButtons();
  }
  didClickDialogButton(t5, e4) {
    const i4 = y3(e4, { matchingSelector: wr });
    return this[e4.getAttribute("data-trix-method")].call(this, i4);
  }
  didKeyDownDialogInput(t5, e4) {
    if (13 === t5.keyCode) {
      t5.preventDefault();
      const i4 = e4.getAttribute("name"), n3 = this.getDialog(i4);
      this.setAttribute(n3);
    }
    if (27 === t5.keyCode) return t5.preventDefault(), this.hideDialog();
  }
  updateActions(t5) {
    return this.actions = t5, this.refreshActionButtons();
  }
  refreshActionButtons() {
    return this.eachActionButton((t5, e4) => {
      t5.disabled = false === this.actions[e4];
    });
  }
  eachActionButton(t5) {
    return Array.from(this.element.querySelectorAll(kr)).map((e4) => t5(e4, Or(e4)));
  }
  updateAttributes(t5) {
    return this.attributes = t5, this.refreshAttributeButtons();
  }
  refreshAttributeButtons() {
    return this.eachAttributeButton((t5, e4) => (t5.disabled = false === this.attributes[e4], this.attributes[e4] || this.dialogIsVisible(e4) ? (t5.setAttribute("data-trix-active", ""), t5.classList.add("trix-active")) : (t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"))));
  }
  eachAttributeButton(t5) {
    return Array.from(this.element.querySelectorAll(Rr)).map((e4) => t5(e4, Fr(e4)));
  }
  applyKeyboardCommand(t5) {
    const e4 = JSON.stringify(t5.sort());
    for (const t6 of Array.from(this.element.querySelectorAll("[data-trix-key]"))) {
      const i4 = t6.getAttribute("data-trix-key").split("+");
      if (JSON.stringify(i4.sort()) === e4) return v3("mousedown", { onElement: t6 }), true;
    }
    return false;
  }
  dialogIsVisible(t5) {
    const e4 = this.getDialog(t5);
    if (e4) return e4.hasAttribute("data-trix-active");
  }
  toggleDialog(t5) {
    return this.dialogIsVisible(t5) ? this.hideDialog() : this.showDialog(t5);
  }
  showDialog(t5) {
    var e4, i4;
    this.hideDialog(), null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarWillShowDialog();
    const n3 = this.getDialog(t5);
    n3.setAttribute("data-trix-active", ""), n3.classList.add("trix-active"), Array.from(n3.querySelectorAll("input[disabled]")).forEach((t6) => {
      t6.removeAttribute("disabled");
    });
    const r4 = Fr(n3);
    if (r4) {
      const e5 = Ir(n3, t5);
      e5 && (e5.value = this.attributes[r4] || "", e5.select());
    }
    return null === (i4 = this.delegate) || void 0 === i4 ? void 0 : i4.toolbarDidShowDialog(t5);
  }
  setAttribute(t5) {
    var e4;
    const i4 = Fr(t5), n3 = Ir(t5, i4);
    return !n3.willValidate || (n3.setCustomValidity(""), n3.checkValidity() && this.isSafeAttribute(n3)) ? (null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarDidUpdateAttribute(i4, n3.value), this.hideDialog()) : (n3.setCustomValidity("Invalid value"), n3.setAttribute("data-trix-validate", ""), n3.classList.add("trix-validate"), n3.focus());
  }
  isSafeAttribute(t5) {
    return !t5.hasAttribute("data-trix-validate-href") || si.isValidAttribute("a", "href", t5.value);
  }
  removeAttribute(t5) {
    var e4;
    const i4 = Fr(t5);
    return null === (e4 = this.delegate) || void 0 === e4 || e4.toolbarDidRemoveAttribute(i4), this.hideDialog();
  }
  hideDialog() {
    const t5 = this.element.querySelector(Lr);
    var e4;
    if (t5) return t5.removeAttribute("data-trix-active"), t5.classList.remove("trix-active"), this.resetDialogInputs(), null === (e4 = this.delegate) || void 0 === e4 ? void 0 : e4.toolbarDidHideDialog(((t6) => t6.getAttribute("data-trix-dialog"))(t5));
  }
  resetDialogInputs() {
    Array.from(this.element.querySelectorAll(Nr)).forEach((t5) => {
      t5.setAttribute("disabled", "disabled"), t5.removeAttribute("data-trix-validate"), t5.classList.remove("trix-validate");
    });
  }
  getDialog(t5) {
    return this.element.querySelector("[data-trix-dialog=".concat(t5, "]"));
  }
};
var Mr = class extends Yn {
  constructor(t5) {
    let { editorElement: e4, document: i4, html: n3 } = t5;
    super(...arguments), this.editorElement = e4, this.selectionManager = new Wn(this.editorElement), this.selectionManager.delegate = this, this.composition = new kn(), this.composition.delegate = this, this.attachmentManager = new Sn(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = 2 === _3.getLevel() ? new br(this.editorElement) : new hr(this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new Gn(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new Pr(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new On(this.composition, this.selectionManager, this.editorElement), i4 ? this.editor.loadDocument(i4) : this.editor.loadHTML(n3);
  }
  registerSelectionManager() {
    return Ft.registerSelectionManager(this.selectionManager);
  }
  unregisterSelectionManager() {
    return Ft.unregisterSelectionManager(this.selectionManager);
  }
  render() {
    return this.compositionController.render();
  }
  reparse() {
    return this.composition.replaceHTML(this.editorElement.innerHTML);
  }
  compositionDidChangeDocument(t5) {
    if (this.notifyEditorElement("document-change"), !this.handlingInput) return this.render();
  }
  compositionDidChangeCurrentAttributes(t5) {
    return this.currentAttributes = t5, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
  }
  compositionDidPerformInsertionAtRange(t5) {
    this.pasting && (this.pastedRange = t5);
  }
  compositionShouldAcceptFile(t5) {
    return this.notifyEditorElement("file-accept", { file: t5 });
  }
  compositionDidAddAttachment(t5) {
    const e4 = this.attachmentManager.manageAttachment(t5);
    return this.notifyEditorElement("attachment-add", { attachment: e4 });
  }
  compositionDidEditAttachment(t5) {
    this.compositionController.rerenderViewForObject(t5);
    const e4 = this.attachmentManager.manageAttachment(t5);
    return this.notifyEditorElement("attachment-edit", { attachment: e4 }), this.notifyEditorElement("change");
  }
  compositionDidChangeAttachmentPreviewURL(t5) {
    return this.compositionController.invalidateViewForObject(t5), this.notifyEditorElement("change");
  }
  compositionDidRemoveAttachment(t5) {
    const e4 = this.attachmentManager.unmanageAttachment(t5);
    return this.notifyEditorElement("attachment-remove", { attachment: e4 });
  }
  compositionDidStartEditingAttachment(t5, e4) {
    return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t5), this.compositionController.installAttachmentEditorForAttachment(t5, e4), this.selectionManager.setLocationRange(this.attachmentLocationRange);
  }
  compositionDidStopEditingAttachment(t5) {
    this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
  }
  compositionDidRequestChangingSelectionToLocationRange(t5) {
    if (!this.loadingSnapshot || this.isFocused()) return this.requestedLocationRange = t5, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render();
  }
  compositionWillLoadSnapshot() {
    this.loadingSnapshot = true;
  }
  compositionDidLoadSnapshot() {
    this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
  }
  getSelectionManager() {
    return this.selectionManager;
  }
  attachmentManagerDidRequestRemovalOfAttachment(t5) {
    return this.removeAttachment(t5);
  }
  compositionControllerWillSyncDocumentView() {
    return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
  }
  compositionControllerDidSyncDocumentView() {
    return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
  }
  compositionControllerDidRender() {
    this.requestedLocationRange && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
  }
  compositionControllerDidFocus() {
    return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
  }
  compositionControllerDidBlur() {
    return this.notifyEditorElement("blur");
  }
  compositionControllerDidSelectAttachment(t5, e4) {
    return this.toolbarController.hideDialog(), this.composition.editAttachment(t5, e4);
  }
  compositionControllerDidRequestDeselectingAttachment(t5) {
    const e4 = this.attachmentLocationRange || this.composition.document.getLocationRangeOfAttachment(t5);
    return this.selectionManager.setLocationRange(e4[1]);
  }
  compositionControllerWillUpdateAttachment(t5) {
    return this.editor.recordUndoEntry("Edit Attachment", { context: t5.id, consolidatable: true });
  }
  compositionControllerDidRequestRemovalOfAttachment(t5) {
    return this.removeAttachment(t5);
  }
  inputControllerWillHandleInput() {
    this.handlingInput = true, this.requestedRender = false;
  }
  inputControllerDidRequestRender() {
    this.requestedRender = true;
  }
  inputControllerDidHandleInput() {
    if (this.handlingInput = false, this.requestedRender) return this.requestedRender = false, this.render();
  }
  inputControllerDidAllowUnhandledInput() {
    return this.notifyEditorElement("change");
  }
  inputControllerDidRequestReparse() {
    return this.reparse();
  }
  inputControllerWillPerformTyping() {
    return this.recordTypingUndoEntry();
  }
  inputControllerWillPerformFormatting(t5) {
    return this.recordFormattingUndoEntry(t5);
  }
  inputControllerWillCutText() {
    return this.editor.recordUndoEntry("Cut");
  }
  inputControllerWillPaste(t5) {
    return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t5 });
  }
  inputControllerDidPaste(t5) {
    return t5.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t5 });
  }
  inputControllerWillMoveText() {
    return this.editor.recordUndoEntry("Move");
  }
  inputControllerWillAttachFiles() {
    return this.editor.recordUndoEntry("Drop Files");
  }
  inputControllerWillPerformUndo() {
    return this.editor.undo();
  }
  inputControllerWillPerformRedo() {
    return this.editor.redo();
  }
  inputControllerDidReceiveKeyboardCommand(t5) {
    return this.toolbarController.applyKeyboardCommand(t5);
  }
  inputControllerDidStartDrag() {
    this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
  }
  inputControllerDidReceiveDragOverPoint(t5) {
    return this.selectionManager.setLocationRangeFromPointRange(t5);
  }
  inputControllerDidCancelDrag() {
    this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
  }
  locationRangeDidChange(t5) {
    return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !Dt(this.attachmentLocationRange, t5) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
  }
  toolbarDidClickButton() {
    if (!this.getLocationRange()) return this.setLocationRange({ index: 0, offset: 0 });
  }
  toolbarDidInvokeAction(t5, e4) {
    return this.invokeAction(t5, e4);
  }
  toolbarDidToggleAttribute(t5) {
    if (this.recordFormattingUndoEntry(t5), this.composition.toggleCurrentAttribute(t5), this.render(), !this.selectionFrozen) return this.editorElement.focus();
  }
  toolbarDidUpdateAttribute(t5, e4) {
    if (this.recordFormattingUndoEntry(t5), this.composition.setCurrentAttribute(t5, e4), this.render(), !this.selectionFrozen) return this.editorElement.focus();
  }
  toolbarDidRemoveAttribute(t5) {
    if (this.recordFormattingUndoEntry(t5), this.composition.removeCurrentAttribute(t5), this.render(), !this.selectionFrozen) return this.editorElement.focus();
  }
  toolbarWillShowDialog(t5) {
    return this.composition.expandSelectionForEditing(), this.freezeSelection();
  }
  toolbarDidShowDialog(t5) {
    return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t5 });
  }
  toolbarDidHideDialog(t5) {
    return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t5 });
  }
  freezeSelection() {
    if (!this.selectionFrozen) return this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render();
  }
  thawSelection() {
    if (this.selectionFrozen) return this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render();
  }
  canInvokeAction(t5) {
    return !!this.actionIsExternal(t5) || !(null === (e4 = this.actions[t5]) || void 0 === e4 || null === (e4 = e4.test) || void 0 === e4 || !e4.call(this));
    var e4;
  }
  invokeAction(t5, e4) {
    return this.actionIsExternal(t5) ? this.notifyEditorElement("action-invoke", { actionName: t5, invokingElement: e4 }) : null === (i4 = this.actions[t5]) || void 0 === i4 || null === (i4 = i4.perform) || void 0 === i4 ? void 0 : i4.call(this);
    var i4;
  }
  actionIsExternal(t5) {
    return /^x-./.test(t5);
  }
  getCurrentActions() {
    const t5 = {};
    for (const e4 in this.actions) t5[e4] = this.canInvokeAction(e4);
    return t5;
  }
  updateCurrentActions() {
    const t5 = this.getCurrentActions();
    if (!Tt(t5, this.currentActions)) return this.currentActions = t5, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions });
  }
  runEditorFilters() {
    let t5 = this.composition.getSnapshot();
    if (Array.from(this.editor.filters).forEach((e5) => {
      const { document: i5, selectedRange: n3 } = t5;
      t5 = e5.call(this.editor, t5) || {}, t5.document || (t5.document = i5), t5.selectedRange || (t5.selectedRange = n3);
    }), e4 = t5, i4 = this.composition.getSnapshot(), !Dt(e4.selectedRange, i4.selectedRange) || !e4.document.isEqualTo(i4.document)) return this.composition.loadSnapshot(t5);
    var e4, i4;
  }
  updateInputElement() {
    const t5 = function(t6, e4) {
      const i4 = xn[e4];
      if (i4) return i4(t6);
      throw new Error("unknown content type: ".concat(e4));
    }(this.compositionController.getSerializableElement(), "text/html");
    return this.editorElement.setFormValue(t5);
  }
  notifyEditorElement(t5, e4) {
    switch (t5) {
      case "document-change":
        this.documentChangedSinceLastRender = true;
        break;
      case "render":
        this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
        break;
      case "change":
      case "attachment-add":
      case "attachment-edit":
      case "attachment-remove":
        this.updateInputElement();
    }
    return this.editorElement.notify(t5, e4);
  }
  removeAttachment(t5) {
    return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t5), this.render();
  }
  recordFormattingUndoEntry(t5) {
    const e4 = mt(t5), i4 = this.selectionManager.getLocationRange();
    if (e4 || !Lt(i4)) return this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true });
  }
  recordTypingUndoEntry() {
    return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
  }
  getUndoContext() {
    for (var t5 = arguments.length, e4 = new Array(t5), i4 = 0; i4 < t5; i4++) e4[i4] = arguments[i4];
    return [this.getLocationContext(), this.getTimeContext(), ...Array.from(e4)];
  }
  getLocationContext() {
    const t5 = this.selectionManager.getLocationRange();
    return Lt(t5) ? t5[0].index : t5;
  }
  getTimeContext() {
    return V3.interval > 0 ? Math.floor((/* @__PURE__ */ new Date()).getTime() / V3.interval) : 0;
  }
  isFocused() {
    var t5;
    return this.editorElement === (null === (t5 = this.editorElement.ownerDocument) || void 0 === t5 ? void 0 : t5.activeElement);
  }
  isFocusedInvisibly() {
    return this.isFocused() && !this.getLocationRange();
  }
  get actions() {
    return this.constructor.actions;
  }
};
wi(Mr, "actions", { undo: { test() {
  return this.editor.canUndo();
}, perform() {
  return this.editor.undo();
} }, redo: { test() {
  return this.editor.canRedo();
}, perform() {
  return this.editor.redo();
} }, link: { test() {
  return this.editor.canActivateAttribute("href");
} }, increaseNestingLevel: { test() {
  return this.editor.canIncreaseNestingLevel();
}, perform() {
  return this.editor.increaseNestingLevel() && this.render();
} }, decreaseNestingLevel: { test() {
  return this.editor.canDecreaseNestingLevel();
}, perform() {
  return this.editor.decreaseNestingLevel() && this.render();
} }, attachFiles: { test: () => true, perform() {
  return _3.pickFiles(this.editor.insertFiles);
} } }), Mr.proxyMethod("getSelectionManager().setLocationRange"), Mr.proxyMethod("getSelectionManager().getLocationRange");
var Br = Object.freeze({ __proto__: null, AttachmentEditorController: Kn, CompositionController: Gn, Controller: Yn, EditorController: Mr, InputController: sr, Level0InputController: hr, Level2InputController: br, ToolbarController: Pr });
var _r = Object.freeze({ __proto__: null, MutationObserver: Qn, SelectionChangeObserver: Ot });
var jr = Object.freeze({ __proto__: null, FileVerificationOperation: er, ImagePreloadOperation: ji });
vt("trix-toolbar", "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}");
var Wr = class extends HTMLElement {
  connectedCallback() {
    "" === this.innerHTML && (this.innerHTML = U2.getDefaultHTML());
  }
};
var Ur = 0;
var Vr = function(t5) {
  if (!t5.hasAttribute("contenteditable")) return t5.setAttribute("contenteditable", ""), function(t6) {
    let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return e4.times = 1, b3(t6, e4);
  }("focus", { onElement: t5, withCallback: () => zr(t5) });
};
var zr = function(t5) {
  return qr(t5), Hr(t5);
};
var qr = function(t5) {
  var e4, i4;
  if (null !== (e4 = (i4 = document).queryCommandSupported) && void 0 !== e4 && e4.call(i4, "enableObjectResizing")) return document.execCommand("enableObjectResizing", false, false), b3("mscontrolselect", { onElement: t5, preventDefault: true });
};
var Hr = function(t5) {
  var e4, i4;
  if (null !== (e4 = (i4 = document).queryCommandSupported) && void 0 !== e4 && e4.call(i4, "DefaultParagraphSeparator")) {
    const { tagName: t6 } = n2.default;
    if (["div", "p"].includes(t6)) return document.execCommand("DefaultParagraphSeparator", false, t6);
  }
};
var Jr = a3.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
vt("trix-editor", "%t {\n    display: block;\n}\n\n%t:empty::before {\n    content: attr(placeholder);\n    color: graytext;\n    cursor: text;\n    pointer-events: none;\n    white-space: pre-line;\n}\n\n%t a[contenteditable=false] {\n    cursor: text;\n}\n\n%t img {\n    max-width: 100%;\n    height: auto;\n}\n\n%t ".concat(e3, " figcaption textarea {\n    resize: none;\n}\n\n%t ").concat(e3, " figcaption textarea.trix-autoresize-clone {\n    position: absolute;\n    left: -9999px;\n    max-height: 0px;\n}\n\n%t ").concat(e3, " figcaption[data-trix-placeholder]:empty::before {\n    content: attr(data-trix-placeholder);\n    color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n    display: ").concat(Jr.display, " !important;\n    width: ").concat(Jr.width, " !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n    vertical-align: top !important;\n    margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n    vertical-align: bottom !important;\n    margin-right: -1px !important;\n}"));
var Kr = /* @__PURE__ */ new WeakMap();
var Gr = /* @__PURE__ */ new WeakSet();
var Yr = class {
  constructor(t5) {
    var e4, i4;
    Mi(e4 = this, i4 = Gr), i4.add(e4), Bi(this, Kr, { writable: true, value: void 0 }), this.element = t5, Ni(this, Kr, t5.attachInternals());
  }
  connectedCallback() {
    Pi(this, Gr, $r).call(this);
  }
  disconnectedCallback() {
  }
  get labels() {
    return Di(this, Kr).labels;
  }
  get disabled() {
    var t5;
    return null === (t5 = this.element.inputElement) || void 0 === t5 ? void 0 : t5.disabled;
  }
  set disabled(t5) {
    this.element.toggleAttribute("disabled", t5);
  }
  get required() {
    return this.element.hasAttribute("required");
  }
  set required(t5) {
    this.element.toggleAttribute("required", t5), Pi(this, Gr, $r).call(this);
  }
  get validity() {
    return Di(this, Kr).validity;
  }
  get validationMessage() {
    return Di(this, Kr).validationMessage;
  }
  get willValidate() {
    return Di(this, Kr).willValidate;
  }
  setFormValue(t5) {
    Pi(this, Gr, $r).call(this);
  }
  checkValidity() {
    return Di(this, Kr).checkValidity();
  }
  reportValidity() {
    return Di(this, Kr).reportValidity();
  }
  setCustomValidity(t5) {
    Pi(this, Gr, $r).call(this, t5);
  }
};
function $r() {
  let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
  const { required: e4, value: i4 } = this.element, n3 = e4 && !i4, r4 = !!t5, o3 = T4("input", { required: e4 }), s4 = t5 || o3.validationMessage;
  Di(this, Kr).setValidity({ valueMissing: n3, customError: r4 }, s4);
}
var Xr = /* @__PURE__ */ new WeakMap();
var Zr = /* @__PURE__ */ new WeakMap();
var Qr = /* @__PURE__ */ new WeakMap();
var to2 = class {
  constructor(t5) {
    Bi(this, Xr, { writable: true, value: void 0 }), Bi(this, Zr, { writable: true, value: (t6) => {
      t6.defaultPrevented || t6.target === this.element.form && this.element.reset();
    } }), Bi(this, Qr, { writable: true, value: (t6) => {
      if (t6.defaultPrevented) return;
      if (this.element.contains(t6.target)) return;
      const e4 = y3(t6.target, { matchingSelector: "label" });
      e4 && Array.from(this.labels).includes(e4) && this.element.focus();
    } }), this.element = t5;
  }
  connectedCallback() {
    Ni(this, Xr, function(t5) {
      if (t5.hasAttribute("aria-label") || t5.hasAttribute("aria-labelledby")) return;
      const e4 = function() {
        const e5 = Array.from(t5.labels).map((e6) => {
          if (!e6.contains(t5)) return e6.textContent;
        }).filter((t6) => t6), i4 = e5.join(" ");
        return i4 ? t5.setAttribute("aria-label", i4) : t5.removeAttribute("aria-label");
      };
      return e4(), b3("focus", { onElement: t5, withCallback: e4 });
    }(this.element)), window.addEventListener("reset", Di(this, Zr), false), window.addEventListener("click", Di(this, Qr), false);
  }
  disconnectedCallback() {
    var t5;
    null === (t5 = Di(this, Xr)) || void 0 === t5 || t5.destroy(), window.removeEventListener("reset", Di(this, Zr), false), window.removeEventListener("click", Di(this, Qr), false);
  }
  get labels() {
    const t5 = [];
    this.element.id && this.element.ownerDocument && t5.push(...Array.from(this.element.ownerDocument.querySelectorAll("label[for='".concat(this.element.id, "']")) || []));
    const e4 = y3(this.element, { matchingSelector: "label" });
    return e4 && [this.element, null].includes(e4.control) && t5.push(e4), t5;
  }
  get disabled() {
    return console.warn("This browser does not support the [disabled] attribute for trix-editor elements."), false;
  }
  set disabled(t5) {
    console.warn("This browser does not support the [disabled] attribute for trix-editor elements.");
  }
  get required() {
    return console.warn("This browser does not support the [required] attribute for trix-editor elements."), false;
  }
  set required(t5) {
    console.warn("This browser does not support the [required] attribute for trix-editor elements.");
  }
  get validity() {
    return console.warn("This browser does not support the validity property for trix-editor elements."), null;
  }
  get validationMessage() {
    return console.warn("This browser does not support the validationMessage property for trix-editor elements."), "";
  }
  get willValidate() {
    return console.warn("This browser does not support the willValidate property for trix-editor elements."), false;
  }
  setFormValue(t5) {
  }
  checkValidity() {
    return console.warn("This browser does not support checkValidity() for trix-editor elements."), true;
  }
  reportValidity() {
    return console.warn("This browser does not support reportValidity() for trix-editor elements."), true;
  }
  setCustomValidity(t5) {
    console.warn("This browser does not support setCustomValidity(validationMessage) for trix-editor elements.");
  }
};
var eo = /* @__PURE__ */ new WeakMap();
var io = class extends HTMLElement {
  constructor() {
    super(), Bi(this, eo, { writable: true, value: void 0 }), Ni(this, eo, this.constructor.formAssociated ? new Yr(this) : new to2(this));
  }
  get trixId() {
    return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++Ur), this.trixId);
  }
  get labels() {
    return Di(this, eo).labels;
  }
  get disabled() {
    return Di(this, eo).disabled;
  }
  set disabled(t5) {
    Di(this, eo).disabled = t5;
  }
  get required() {
    return Di(this, eo).required;
  }
  set required(t5) {
    Di(this, eo).required = t5;
  }
  get validity() {
    return Di(this, eo).validity;
  }
  get validationMessage() {
    return Di(this, eo).validationMessage;
  }
  get willValidate() {
    return Di(this, eo).willValidate;
  }
  get type() {
    return this.localName;
  }
  get toolbarElement() {
    var t5;
    if (this.hasAttribute("toolbar")) return null === (t5 = this.ownerDocument) || void 0 === t5 ? void 0 : t5.getElementById(this.getAttribute("toolbar"));
    if (this.parentNode) {
      const t6 = "trix-toolbar-".concat(this.trixId);
      this.setAttribute("toolbar", t6);
      const e4 = T4("trix-toolbar", { id: t6 });
      return this.parentNode.insertBefore(e4, this), e4;
    }
  }
  get form() {
    var t5;
    return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.form;
  }
  get inputElement() {
    var t5;
    if (this.hasAttribute("input")) return null === (t5 = this.ownerDocument) || void 0 === t5 ? void 0 : t5.getElementById(this.getAttribute("input"));
    if (this.parentNode) {
      const t6 = "trix-input-".concat(this.trixId);
      this.setAttribute("input", t6);
      const e4 = T4("input", { type: "hidden", id: t6 });
      return this.parentNode.insertBefore(e4, this.nextElementSibling), e4;
    }
  }
  get editor() {
    var t5;
    return null === (t5 = this.editorController) || void 0 === t5 ? void 0 : t5.editor;
  }
  get name() {
    var t5;
    return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.name;
  }
  get value() {
    var t5;
    return null === (t5 = this.inputElement) || void 0 === t5 ? void 0 : t5.value;
  }
  set value(t5) {
    var e4;
    this.defaultValue = t5, null === (e4 = this.editor) || void 0 === e4 || e4.loadHTML(this.defaultValue);
  }
  notify(t5, e4) {
    if (this.editorController) return v3("trix-".concat(t5), { onElement: this, attributes: e4 });
  }
  setFormValue(t5) {
    this.inputElement && (this.inputElement.value = t5, Di(this, eo).setFormValue(t5));
  }
  connectedCallback() {
    this.hasAttribute("data-trix-internal") || (Vr(this), function(t5) {
      if (!t5.hasAttribute("role")) t5.setAttribute("role", "textbox");
    }(this), this.editorController || (v3("trix-before-initialize", { onElement: this }), this.editorController = new Mr({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(() => v3("trix-initialize", { onElement: this }))), this.editorController.registerSelectionManager(), Di(this, eo).connectedCallback(), function(t5) {
      if (!document.querySelector(":focus") && t5.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t5) t5.focus();
    }(this));
  }
  disconnectedCallback() {
    var t5;
    null === (t5 = this.editorController) || void 0 === t5 || t5.unregisterSelectionManager(), Di(this, eo).disconnectedCallback();
  }
  checkValidity() {
    return Di(this, eo).checkValidity();
  }
  reportValidity() {
    return Di(this, eo).reportValidity();
  }
  setCustomValidity(t5) {
    Di(this, eo).setCustomValidity(t5);
  }
  formDisabledCallback(t5) {
    this.inputElement && (this.inputElement.disabled = t5), this.toggleAttribute("contenteditable", !t5);
  }
  formResetCallback() {
    this.reset();
  }
  reset() {
    this.value = this.defaultValue;
  }
};
wi(io, "formAssociated", "ElementInternals" in window);
var no = { VERSION: t3, config: z3, core: Cn, models: Un, views: Vn, controllers: Br, observers: _r, operations: jr, elements: Object.freeze({ __proto__: null, TrixEditorElement: io, TrixToolbarElement: Wr }), filters: Object.freeze({ __proto__: null, Filter: Dn, attachmentGalleryFilter: Nn }) };
Object.assign(no, Un), window.Trix = no, setTimeout(function() {
  customElements.get("trix-toolbar") || customElements.define("trix-toolbar", Wr), customElements.get("trix-editor") || customElements.define("trix-editor", io);
}, 0);

// node_modules/@rails/actiontext/app/assets/javascripts/actiontext.esm.js
var sparkMd5 = {
  exports: {}
};
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function(undefined$1) {
    var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function md5cycle(x5, k4) {
      var a4 = x5[0], b4 = x5[1], c4 = x5[2], d3 = x5[3];
      a4 += (b4 & c4 | ~b4 & d3) + k4[0] - 680876936 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[1] - 389564586 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[2] + 606105819 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[3] - 1044525330 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[4] - 176418897 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[5] + 1200080426 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[6] - 1473231341 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[7] - 45705983 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[8] + 1770035416 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[9] - 1958414417 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[10] - 42063 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[11] - 1990404162 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & c4 | ~b4 & d3) + k4[12] + 1804603682 | 0;
      a4 = (a4 << 7 | a4 >>> 25) + b4 | 0;
      d3 += (a4 & b4 | ~a4 & c4) + k4[13] - 40341101 | 0;
      d3 = (d3 << 12 | d3 >>> 20) + a4 | 0;
      c4 += (d3 & a4 | ~d3 & b4) + k4[14] - 1502002290 | 0;
      c4 = (c4 << 17 | c4 >>> 15) + d3 | 0;
      b4 += (c4 & d3 | ~c4 & a4) + k4[15] + 1236535329 | 0;
      b4 = (b4 << 22 | b4 >>> 10) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[1] - 165796510 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[6] - 1069501632 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[11] + 643717713 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[0] - 373897302 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[5] - 701558691 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[10] + 38016083 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[15] - 660478335 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[4] - 405537848 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[9] + 568446438 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[14] - 1019803690 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[3] - 187363961 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[8] + 1163531501 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 & d3 | c4 & ~d3) + k4[13] - 1444681467 | 0;
      a4 = (a4 << 5 | a4 >>> 27) + b4 | 0;
      d3 += (a4 & c4 | b4 & ~c4) + k4[2] - 51403784 | 0;
      d3 = (d3 << 9 | d3 >>> 23) + a4 | 0;
      c4 += (d3 & b4 | a4 & ~b4) + k4[7] + 1735328473 | 0;
      c4 = (c4 << 14 | c4 >>> 18) + d3 | 0;
      b4 += (c4 & a4 | d3 & ~a4) + k4[12] - 1926607734 | 0;
      b4 = (b4 << 20 | b4 >>> 12) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[5] - 378558 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[8] - 2022574463 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[11] + 1839030562 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[14] - 35309556 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[1] - 1530992060 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[4] + 1272893353 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[7] - 155497632 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[10] - 1094730640 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[13] + 681279174 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[0] - 358537222 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[3] - 722521979 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[6] + 76029189 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (b4 ^ c4 ^ d3) + k4[9] - 640364487 | 0;
      a4 = (a4 << 4 | a4 >>> 28) + b4 | 0;
      d3 += (a4 ^ b4 ^ c4) + k4[12] - 421815835 | 0;
      d3 = (d3 << 11 | d3 >>> 21) + a4 | 0;
      c4 += (d3 ^ a4 ^ b4) + k4[15] + 530742520 | 0;
      c4 = (c4 << 16 | c4 >>> 16) + d3 | 0;
      b4 += (c4 ^ d3 ^ a4) + k4[2] - 995338651 | 0;
      b4 = (b4 << 23 | b4 >>> 9) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[0] - 198630844 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[7] + 1126891415 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[14] - 1416354905 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[5] - 57434055 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[12] + 1700485571 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[3] - 1894986606 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[10] - 1051523 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[1] - 2054922799 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[8] + 1873313359 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[15] - 30611744 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[6] - 1560198380 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[13] + 1309151649 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      a4 += (c4 ^ (b4 | ~d3)) + k4[4] - 145523070 | 0;
      a4 = (a4 << 6 | a4 >>> 26) + b4 | 0;
      d3 += (b4 ^ (a4 | ~c4)) + k4[11] - 1120210379 | 0;
      d3 = (d3 << 10 | d3 >>> 22) + a4 | 0;
      c4 += (a4 ^ (d3 | ~b4)) + k4[2] + 718787259 | 0;
      c4 = (c4 << 15 | c4 >>> 17) + d3 | 0;
      b4 += (d3 ^ (c4 | ~a4)) + k4[9] - 343485551 | 0;
      b4 = (b4 << 21 | b4 >>> 11) + c4 | 0;
      x5[0] = a4 + x5[0] | 0;
      x5[1] = b4 + x5[1] | 0;
      x5[2] = c4 + x5[2] | 0;
      x5[3] = d3 + x5[3] | 0;
    }
    function md5blk(s4) {
      var md5blks = [], i4;
      for (i4 = 0; i4 < 64; i4 += 4) {
        md5blks[i4 >> 2] = s4.charCodeAt(i4) + (s4.charCodeAt(i4 + 1) << 8) + (s4.charCodeAt(i4 + 2) << 16) + (s4.charCodeAt(i4 + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a4) {
      var md5blks = [], i4;
      for (i4 = 0; i4 < 64; i4 += 4) {
        md5blks[i4 >> 2] = a4[i4] + (a4[i4 + 1] << 8) + (a4[i4 + 2] << 16) + (a4[i4 + 3] << 24);
      }
      return md5blks;
    }
    function md51(s4) {
      var n3 = s4.length, state = [1732584193, -271733879, -1732584194, 271733878], i4, length, tail, tmp, lo, hi2;
      for (i4 = 64; i4 <= n3; i4 += 64) {
        md5cycle(state, md5blk(s4.substring(i4 - 64, i4)));
      }
      s4 = s4.substring(i4 - 64);
      length = s4.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i4 = 0; i4 < length; i4 += 1) {
        tail[i4 >> 2] |= s4.charCodeAt(i4) << (i4 % 4 << 3);
      }
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(state, tail);
        for (i4 = 0; i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = n3 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a4) {
      var n3 = a4.length, state = [1732584193, -271733879, -1732584194, 271733878], i4, length, tail, tmp, lo, hi2;
      for (i4 = 64; i4 <= n3; i4 += 64) {
        md5cycle(state, md5blk_array(a4.subarray(i4 - 64, i4)));
      }
      a4 = i4 - 64 < n3 ? a4.subarray(i4 - 64) : new Uint8Array(0);
      length = a4.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i4 = 0; i4 < length; i4 += 1) {
        tail[i4 >> 2] |= a4[i4] << (i4 % 4 << 3);
      }
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(state, tail);
        for (i4 = 0; i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = n3 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n3) {
      var s4 = "", j5;
      for (j5 = 0; j5 < 4; j5 += 1) {
        s4 += hex_chr[n3 >> j5 * 8 + 4 & 15] + hex_chr[n3 >> j5 * 8 & 15];
      }
      return s4;
    }
    function hex2(x5) {
      var i4;
      for (i4 = 0; i4 < x5.length; i4 += 1) {
        x5[i4] = rhex(x5[i4]);
      }
      return x5.join("");
    }
    if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") ;
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp(val, length) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length, 0);
          }
          return Math.min(val, length);
        }
        ArrayBuffer.prototype.slice = function(from2, to3) {
          var length = this.byteLength, begin = clamp(from2, length), end = length, num, target, targetArray, sourceArray;
          if (to3 !== undefined$1) {
            end = clamp(to3, length);
          }
          if (begin > end) {
            return new ArrayBuffer(0);
          }
          num = end - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
      }
      return str;
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i4;
      for (i4 = 0; i4 < length; i4 += 1) {
        arr[i4] = str.charCodeAt(i4);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return returnUInt8Array ? result : result.buffer;
    }
    function hexToBinaryString(hex3) {
      var bytes = [], length = hex3.length, x5;
      for (x5 = 0; x5 < length - 1; x5 += 2) {
        bytes.push(parseInt(hex3.substr(x5, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD52() {
      this.reset();
    }
    SparkMD52.prototype.append = function(str) {
      this.appendBinary(toUtf8(str));
      return this;
    };
    SparkMD52.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length = this._buff.length, i4;
      for (i4 = 64; i4 <= length; i4 += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i4 - 64, i4)));
      }
      this._buff = this._buff.substring(i4 - 64);
      return this;
    };
    SparkMD52.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, i4, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i4 = 0; i4 < length; i4 += 1) {
        tail[i4 >> 2] |= buff.charCodeAt(i4) << (i4 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex2(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD52.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD52.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD52.prototype._finish = function(tail, length) {
      var i4 = length, tmp, lo, hi2;
      tail[i4 >> 2] |= 128 << (i4 % 4 << 3);
      if (i4 > 55) {
        md5cycle(this._hash, tail);
        for (i4 = 0; i4 < 16; i4 += 1) {
          tail[i4] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi2 = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi2;
      md5cycle(this._hash, tail);
    };
    SparkMD52.hash = function(str, raw) {
      return SparkMD52.hashBinary(toUtf8(str), raw);
    };
    SparkMD52.hashBinary = function(content, raw) {
      var hash = md51(content), ret = hex2(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD52.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD52.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i4;
      this._length += arr.byteLength;
      for (i4 = 64; i4 <= length; i4 += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i4 - 64, i4)));
      }
      this._buff = i4 - 64 < length ? new Uint8Array(buff.buffer.slice(i4 - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i4, ret;
      for (i4 = 0; i4 < length; i4 += 1) {
        tail[i4 >> 2] |= buff[i4] << (i4 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex2(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD52.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD52.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD52.prototype.setState.call(this, state);
    };
    SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
    SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
    SparkMD52.ArrayBuffer.hash = function(arr, raw) {
      var hash = md51_array(new Uint8Array(arr)), ret = hex2(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD52;
  });
})(sparkMd5);
var SparkMD5 = sparkMd5.exports;
var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
var FileChecksum = class _FileChecksum {
  static create(file, callback2) {
    const instance = new _FileChecksum(file);
    instance.create(callback2);
  }
  constructor(file) {
    this.file = file;
    this.chunkSize = 2097152;
    this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
    this.chunkIndex = 0;
  }
  create(callback2) {
    this.callback = callback2;
    this.md5Buffer = new SparkMD5.ArrayBuffer();
    this.fileReader = new FileReader();
    this.fileReader.addEventListener("load", (event2) => this.fileReaderDidLoad(event2));
    this.fileReader.addEventListener("error", (event2) => this.fileReaderDidError(event2));
    this.readNextChunk();
  }
  fileReaderDidLoad(event2) {
    this.md5Buffer.append(event2.target.result);
    if (!this.readNextChunk()) {
      const binaryDigest = this.md5Buffer.end(true);
      const base64digest = btoa(binaryDigest);
      this.callback(null, base64digest);
    }
  }
  fileReaderDidError(event2) {
    this.callback(`Error reading ${this.file.name}`);
  }
  readNextChunk() {
    if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
      const start4 = this.chunkIndex * this.chunkSize;
      const end = Math.min(start4 + this.chunkSize, this.file.size);
      const bytes = fileSlice.call(this.file, start4, end);
      this.fileReader.readAsArrayBuffer(bytes);
      this.chunkIndex++;
      return true;
    } else {
      return false;
    }
  }
};
function getMetaValue(name) {
  const element = findElement(document.head, `meta[name="${name}"]`);
  if (element) {
    return element.getAttribute("content");
  }
}
function findElements2(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  const elements2 = root.querySelectorAll(selector);
  return toArray2(elements2);
}
function findElement(root, selector) {
  if (typeof root == "string") {
    selector = root;
    root = document;
  }
  return root.querySelector(selector);
}
function dispatchEvent2(element, type, eventInit = {}) {
  const { disabled } = element;
  const { bubbles, cancelable, detail } = eventInit;
  const event2 = document.createEvent("Event");
  event2.initEvent(type, bubbles || true, cancelable || true);
  event2.detail = detail || {};
  try {
    element.disabled = false;
    element.dispatchEvent(event2);
  } finally {
    element.disabled = disabled;
  }
  return event2;
}
function toArray2(value) {
  if (Array.isArray(value)) {
    return value;
  } else if (Array.from) {
    return Array.from(value);
  } else {
    return [].slice.call(value);
  }
}
var BlobRecord = class {
  constructor(file, checksum, url, customHeaders = {}) {
    this.file = file;
    this.attributes = {
      filename: file.name,
      content_type: file.type || "application/octet-stream",
      byte_size: file.size,
      checksum
    };
    this.xhr = new XMLHttpRequest();
    this.xhr.open("POST", url, true);
    this.xhr.responseType = "json";
    this.xhr.setRequestHeader("Content-Type", "application/json");
    this.xhr.setRequestHeader("Accept", "application/json");
    this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    Object.keys(customHeaders).forEach((headerKey) => {
      this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
    });
    const csrfToken2 = getMetaValue("csrf-token");
    if (csrfToken2 != void 0) {
      this.xhr.setRequestHeader("X-CSRF-Token", csrfToken2);
    }
    this.xhr.addEventListener("load", (event2) => this.requestDidLoad(event2));
    this.xhr.addEventListener("error", (event2) => this.requestDidError(event2));
  }
  get status() {
    return this.xhr.status;
  }
  get response() {
    const { responseType, response } = this.xhr;
    if (responseType == "json") {
      return response;
    } else {
      return JSON.parse(response);
    }
  }
  create(callback2) {
    this.callback = callback2;
    this.xhr.send(JSON.stringify({
      blob: this.attributes
    }));
  }
  requestDidLoad(event2) {
    if (this.status >= 200 && this.status < 300) {
      const { response } = this;
      const { direct_upload } = response;
      delete response.direct_upload;
      this.attributes = response;
      this.directUploadData = direct_upload;
      this.callback(null, this.toJSON());
    } else {
      this.requestDidError(event2);
    }
  }
  requestDidError(event2) {
    this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
  }
  toJSON() {
    const result = {};
    for (const key in this.attributes) {
      result[key] = this.attributes[key];
    }
    return result;
  }
};
var BlobUpload = class {
  constructor(blob) {
    this.blob = blob;
    this.file = blob.file;
    const { url, headers } = blob.directUploadData;
    this.xhr = new XMLHttpRequest();
    this.xhr.open("PUT", url, true);
    this.xhr.responseType = "text";
    for (const key in headers) {
      this.xhr.setRequestHeader(key, headers[key]);
    }
    this.xhr.addEventListener("load", (event2) => this.requestDidLoad(event2));
    this.xhr.addEventListener("error", (event2) => this.requestDidError(event2));
  }
  create(callback2) {
    this.callback = callback2;
    this.xhr.send(this.file.slice());
  }
  requestDidLoad(event2) {
    const { status, response } = this.xhr;
    if (status >= 200 && status < 300) {
      this.callback(null, response);
    } else {
      this.requestDidError(event2);
    }
  }
  requestDidError(event2) {
    this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
  }
};
var id = 0;
var DirectUpload = class {
  constructor(file, url, delegate2, customHeaders = {}) {
    this.id = ++id;
    this.file = file;
    this.url = url;
    this.delegate = delegate2;
    this.customHeaders = customHeaders;
  }
  create(callback2) {
    FileChecksum.create(this.file, (error2, checksum) => {
      if (error2) {
        callback2(error2);
        return;
      }
      const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
      notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
      blob.create((error3) => {
        if (error3) {
          callback2(error3);
        } else {
          const upload = new BlobUpload(blob);
          notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
          upload.create((error4) => {
            if (error4) {
              callback2(error4);
            } else {
              callback2(null, blob.toJSON());
            }
          });
        }
      });
    });
  }
};
function notify(object, methodName, ...messages) {
  if (object && typeof object[methodName] == "function") {
    return object[methodName](...messages);
  }
}
var DirectUploadController = class {
  constructor(input, file) {
    this.input = input;
    this.file = file;
    this.directUpload = new DirectUpload(this.file, this.url, this);
    this.dispatch("initialize");
  }
  start(callback2) {
    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.name = this.input.name;
    this.input.insertAdjacentElement("beforebegin", hiddenInput);
    this.dispatch("start");
    this.directUpload.create((error2, attributes) => {
      if (error2) {
        hiddenInput.parentNode.removeChild(hiddenInput);
        this.dispatchError(error2);
      } else {
        hiddenInput.value = attributes.signed_id;
      }
      this.dispatch("end");
      callback2(error2);
    });
  }
  uploadRequestDidProgress(event2) {
    const progress = event2.loaded / event2.total * 100;
    if (progress) {
      this.dispatch("progress", {
        progress
      });
    }
  }
  get url() {
    return this.input.getAttribute("data-direct-upload-url");
  }
  dispatch(name, detail = {}) {
    detail.file = this.file;
    detail.id = this.directUpload.id;
    return dispatchEvent2(this.input, `direct-upload:${name}`, {
      detail
    });
  }
  dispatchError(error2) {
    const event2 = this.dispatch("error", {
      error: error2
    });
    if (!event2.defaultPrevented) {
      alert(error2);
    }
  }
  directUploadWillCreateBlobWithXHR(xhr) {
    this.dispatch("before-blob-request", {
      xhr
    });
  }
  directUploadWillStoreFileWithXHR(xhr) {
    this.dispatch("before-storage-request", {
      xhr
    });
    xhr.upload.addEventListener("progress", (event2) => this.uploadRequestDidProgress(event2));
  }
};
var inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
var DirectUploadsController = class {
  constructor(form2) {
    this.form = form2;
    this.inputs = findElements2(form2, inputSelector).filter((input) => input.files.length);
  }
  start(callback2) {
    const controllers2 = this.createDirectUploadControllers();
    const startNextController = () => {
      const controller = controllers2.shift();
      if (controller) {
        controller.start((error2) => {
          if (error2) {
            callback2(error2);
            this.dispatch("end");
          } else {
            startNextController();
          }
        });
      } else {
        callback2();
        this.dispatch("end");
      }
    };
    this.dispatch("start");
    startNextController();
  }
  createDirectUploadControllers() {
    const controllers2 = [];
    this.inputs.forEach((input) => {
      toArray2(input.files).forEach((file) => {
        const controller = new DirectUploadController(input, file);
        controllers2.push(controller);
      });
    });
    return controllers2;
  }
  dispatch(name, detail = {}) {
    return dispatchEvent2(this.form, `direct-uploads:${name}`, {
      detail
    });
  }
};
var processingAttribute = "data-direct-uploads-processing";
var submitButtonsByForm = /* @__PURE__ */ new WeakMap();
var started = false;
function start3() {
  if (!started) {
    started = true;
    document.addEventListener("click", didClick, true);
    document.addEventListener("submit", didSubmitForm, true);
    document.addEventListener("ajax:before", didSubmitRemoteElement);
  }
}
function didClick(event2) {
  const button = event2.target.closest("button, input");
  if (button && button.type === "submit" && button.form) {
    submitButtonsByForm.set(button.form, button);
  }
}
function didSubmitForm(event2) {
  handleFormSubmissionEvent(event2);
}
function didSubmitRemoteElement(event2) {
  if (event2.target.tagName == "FORM") {
    handleFormSubmissionEvent(event2);
  }
}
function handleFormSubmissionEvent(event2) {
  const form2 = event2.target;
  if (form2.hasAttribute(processingAttribute)) {
    event2.preventDefault();
    return;
  }
  const controller = new DirectUploadsController(form2);
  const { inputs } = controller;
  if (inputs.length) {
    event2.preventDefault();
    form2.setAttribute(processingAttribute, "");
    inputs.forEach(disable);
    controller.start((error2) => {
      form2.removeAttribute(processingAttribute);
      if (error2) {
        inputs.forEach(enable);
      } else {
        submitForm(form2);
      }
    });
  }
}
function submitForm(form2) {
  let button = submitButtonsByForm.get(form2) || findElement(form2, "input[type=submit], button[type=submit]");
  if (button) {
    const { disabled } = button;
    button.disabled = false;
    button.focus();
    button.click();
    button.disabled = disabled;
  } else {
    button = document.createElement("input");
    button.type = "submit";
    button.style.display = "none";
    form2.appendChild(button);
    button.click();
    form2.removeChild(button);
  }
  submitButtonsByForm.delete(form2);
}
function disable(input) {
  input.disabled = true;
}
function enable(input) {
  input.disabled = false;
}
function autostart() {
  if (window.ActiveStorage) {
    start3();
  }
}
setTimeout(autostart, 1);
var AttachmentUpload = class {
  constructor(attachment, element) {
    this.attachment = attachment;
    this.element = element;
    this.directUpload = new DirectUpload(attachment.file, this.directUploadUrl, this);
  }
  start() {
    this.directUpload.create(this.directUploadDidComplete.bind(this));
    this.dispatch("start");
  }
  directUploadWillStoreFileWithXHR(xhr) {
    xhr.upload.addEventListener("progress", (event2) => {
      const progress = event2.loaded / event2.total * 100;
      this.attachment.setUploadProgress(progress);
      if (progress) {
        this.dispatch("progress", {
          progress
        });
      }
    });
  }
  directUploadDidComplete(error2, attributes) {
    if (error2) {
      this.dispatchError(error2);
    } else {
      this.attachment.setAttributes({
        sgid: attributes.attachable_sgid,
        url: this.createBlobUrl(attributes.signed_id, attributes.filename)
      });
      this.dispatch("end");
    }
  }
  createBlobUrl(signedId, filename) {
    return this.blobUrlTemplate.replace(":signed_id", signedId).replace(":filename", encodeURIComponent(filename));
  }
  dispatch(name, detail = {}) {
    detail.attachment = this.attachment;
    return dispatchEvent2(this.element, `direct-upload:${name}`, {
      detail
    });
  }
  dispatchError(error2) {
    const event2 = this.dispatch("error", {
      error: error2
    });
    if (!event2.defaultPrevented) {
      alert(error2);
    }
  }
  get directUploadUrl() {
    return this.element.dataset.directUploadUrl;
  }
  get blobUrlTemplate() {
    return this.element.dataset.blobUrlTemplate;
  }
};
addEventListener("trix-attachment-add", (event2) => {
  const { attachment, target } = event2;
  if (attachment.file) {
    const upload = new AttachmentUpload(attachment, target);
    upload.start();
  }
});

// app/javascript/plugins/fullcalendar.js
document.addEventListener("turbo:load", function() {
  const calendarEl = document.getElementById("calendar1");
  if (calendarEl) {
    if (window.fullCalendarInstance) {
      window.fullCalendarInstance.destroy();
    }
    window.fullCalendarInstance = new Calendar(calendarEl, {
      plugins: [index, index2],
      themeSystem: "bootstrap",
      initialView: "dayGridMonth",
      headerToolbar: {
        start: "title",
        center: "",
        end: "today prev,next"
      },
      contentHeight: "auto",
      events: [
        {
          title: "Call with Dave",
          start: "2025-03-18",
          className: "bg-gradient-danger"
        },
        {
          title: "Lunch meeting",
          start: "2025-03-21",
          end: "2025-03-22",
          className: "bg-gradient-warning"
        },
        {
          title: "All day conference",
          start: "2025-03-29",
          className: "bg-gradient-success"
        },
        {
          title: "Meeting with Mary",
          start: "2025-03-01",
          className: "bg-gradient-info"
        },
        {
          title: "Winter Hackathon",
          start: "2025-03-03",
          className: "bg-gradient-danger"
        },
        {
          title: "Digital event",
          start: "2025-03-07",
          end: "2025-03-09",
          className: "bg-gradient-warning"
        },
        {
          title: "Marketing event",
          start: "2025-03-10",
          className: "bg-gradient-primary"
        },
        {
          title: "Dinner with Family",
          start: "2025-03-19",
          className: "bg-gradient-danger"
        },
        {
          title: "Black Friday",
          start: "2025-03-23",
          className: "bg-gradient-info"
        },
        {
          title: "Cyber Week",
          start: "2025-03-02",
          className: "bg-gradient-warning"
        }
      ]
    });
    setTimeout(() => {
      window.fullCalendarInstance.render();
    }, 100);
  }
});
document.querySelectorAll('[data-bs-toggle="tab"]').forEach((tab) => {
  tab.addEventListener("shown.bs.tab", function() {
    if (window.fullCalendarInstance) {
      setTimeout(() => {
        window.fullCalendarInstance.render();
      }, 100);
    }
  });
});

// app/javascript/plugins/swot_chart.js
document.addEventListener("DOMContentLoaded", function() {
  const ctx = document.getElementById("swotChart");
  if (ctx) {
    const swotData = {
      labels: ["Strengths", "Weaknesses", "Opportunities", "Threats"],
      datasets: [
        {
          label: "SWOT Analysis",
          data: [
            document.getElementById("strengths").textContent.length,
            document.getElementById("weaknesses").textContent.length,
            document.getElementById("opportunities").textContent.length,
            document.getElementById("threats").textContent.length
          ],
          backgroundColor: [
            "rgba(75, 192, 192, 0.6)",
            // Strengths (Green)
            "rgba(255, 99, 132, 0.6)",
            // Weaknesses (Red)
            "rgba(54, 162, 235, 0.6)",
            // Opportunities (Blue)
            "rgba(255, 206, 86, 0.6)"
            // Threats (Yellow)
          ],
          borderColor: [
            "rgba(75, 192, 192, 1)",
            "rgba(255, 99, 132, 1)",
            "rgba(54, 162, 235, 1)",
            "rgba(255, 206, 86, 1)"
          ],
          borderWidth: 1
        }
      ]
    };
    new auto_default(ctx, {
      type: "bar",
      // You can change this to 'pie' or 'radar'
      data: swotData,
      options: {
        responsive: true,
        scales: {
          y: {
            beginAtZero: true
          }
        }
      }
    });
  }
});

// app/javascript/plugins/line_chart.js
function initializeLineChart() {
  const ctx1 = document.getElementById("chart-line");
  if (ctx1) {
    const gradientStroke1 = ctx1.getContext("2d").createLinearGradient(0, 230, 0, 50);
    gradientStroke1.addColorStop(1, "rgba(94, 114, 228, 0.2)");
    gradientStroke1.addColorStop(0.2, "rgba(94, 114, 228, 0.0)");
    gradientStroke1.addColorStop(0, "rgba(94, 114, 228, 0)");
    new auto_default(ctx1, {
      type: "line",
      data: {
        labels: ["Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        datasets: [
          {
            label: "Mobile apps",
            tension: 0.4,
            borderWidth: 0,
            pointRadius: 0,
            borderColor: "#5e72e4",
            backgroundColor: gradientStroke1,
            borderWidth: 3,
            fill: true,
            data: [50, 40, 300, 220, 500, 250, 400, 230, 500],
            maxBarThickness: 6
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          }
        },
        interaction: {
          intersect: false,
          mode: "index"
        },
        scales: {
          y: {
            grid: {
              drawBorder: false,
              display: true,
              drawOnChartArea: true,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              padding: 10,
              color: "#fbfbfb",
              font: {
                size: 11,
                family: "Open Sans",
                style: "normal",
                lineHeight: 2
              }
            }
          },
          x: {
            grid: {
              drawBorder: false,
              display: false,
              drawOnChartArea: false,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              color: "#ccc",
              padding: 20,
              font: {
                size: 11,
                family: "Open Sans",
                style: "normal",
                lineHeight: 2
              }
            }
          }
        }
      }
    });
  }
}
document.addEventListener("turbo:load", initializeLineChart);

// app/javascript/argon-dashboard.js
(function() {
  var isWindows = navigator.platform.indexOf("Win") > -1 ? true : false;
  if (isWindows) {
    if (document.getElementsByClassName("main-content")[0]) {
      var mainpanel = document.querySelector(".main-content");
      var ps = new PerfectScrollbar(mainpanel);
    }
    if (document.getElementsByClassName("sidenav")[0]) {
      var sidebar = document.querySelector(".sidenav");
      var ps1 = new PerfectScrollbar(sidebar);
    }
    if (document.getElementsByClassName("navbar-collapse")[0]) {
      var fixedplugin = document.querySelector(
        ".navbar:not(.navbar-expand-lg) .navbar-collapse"
      );
      var ps2 = new PerfectScrollbar(fixedplugin);
    }
    if (document.getElementsByClassName("fixed-plugin")[0]) {
      var fixedplugin = document.querySelector(".fixed-plugin");
      var ps3 = new PerfectScrollbar(fixedplugin);
    }
  }
})();
if (document.getElementById("navbarBlur") && document.getElementById("navbarBlur").getAttribute("data-scroll") == "true") {
  navbarBlurOnScroll("navbarBlur");
}
var popoverTriggerList = [].slice.call(
  document.querySelectorAll('[data-bs-toggle="popover"]')
);
var popoverList = popoverTriggerList.map(function(popoverTriggerEl) {
  return new bootstrap.Popover(popoverTriggerEl);
});
var tooltipTriggerList = [].slice.call(
  document.querySelectorAll('[data-bs-toggle="tooltip"]')
);
var tooltipList = tooltipTriggerList.map(function(tooltipTriggerEl) {
  return new bootstrap.Tooltip(tooltipTriggerEl);
});
document.addEventListener("DOMContentLoaded", function() {
  var toastElList = [].slice.call(document.querySelectorAll(".toast"));
  var toastList = toastElList.map(function(toastEl) {
    return new bootstrap.Toast(toastEl);
  });
  var toastButtonList = [].slice.call(document.querySelectorAll(".toast-btn"));
  toastButtonList.map(function(toastButtonEl) {
    toastButtonEl.addEventListener("click", function() {
      var toastToTrigger = document.getElementById(toastButtonEl.dataset.target);
      if (toastToTrigger) {
        var toast = bootstrap.Toast.getInstance(toastToTrigger);
        toast.show();
      }
    });
  });
});
if (document.querySelector('[data-toggle="widget-calendar"]')) {
  calendarEl = document.querySelector('[data-toggle="widget-calendar"]');
  today = /* @__PURE__ */ new Date();
  mYear = today.getFullYear();
  weekday = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  mDay = weekday[today.getDay()];
  m5 = today.getMonth();
  d3 = today.getDate();
  document.getElementsByClassName("widget-calendar-year")[0].innerHTML = mYear;
  document.getElementsByClassName("widget-calendar-day")[0].innerHTML = mDay;
  calendar = new FullCalendar.Calendar(calendarEl, {
    contentHeight: "auto",
    initialView: "dayGridMonth",
    selectable: true,
    initialDate: "2020-12-01",
    editable: true,
    headerToolbar: false,
    events: [
      {
        title: "Call with Dave",
        start: "2020-11-18",
        end: "2020-11-18",
        className: "bg-gradient-danger"
      },
      {
        title: "Lunch meeting",
        start: "2020-11-21",
        end: "2020-11-22",
        className: "bg-gradient-warning"
      },
      {
        title: "All day conference",
        start: "2020-11-29",
        end: "2020-11-29",
        className: "bg-gradient-success"
      },
      {
        title: "Meeting with Mary",
        start: "2020-12-01",
        end: "2020-12-01",
        className: "bg-gradient-info"
      },
      {
        title: "Winter Hackaton",
        start: "2020-12-03",
        end: "2020-12-03",
        className: "bg-gradient-danger"
      },
      {
        title: "Digital event",
        start: "2020-12-07",
        end: "2020-12-09",
        className: "bg-gradient-warning"
      },
      {
        title: "Marketing event",
        start: "2020-12-10",
        end: "2020-12-10",
        className: "bg-gradient-primary"
      },
      {
        title: "Dinner with Family",
        start: "2020-12-19",
        end: "2020-12-19",
        className: "bg-gradient-danger"
      },
      {
        title: "Black Friday",
        start: "2020-12-23",
        end: "2020-12-23",
        className: "bg-gradient-info"
      },
      {
        title: "Cyber Week",
        start: "2020-12-02",
        end: "2020-12-02",
        className: "bg-gradient-warning"
      }
    ]
  });
  calendar.render();
}
var calendarEl;
var today;
var mYear;
var weekday;
var mDay;
var m5;
var d3;
var calendar;
function focused(el) {
  if (el.parentElement.classList.contains("input-group")) {
    el.parentElement.classList.add("focused");
  }
}
function defocused(el) {
  if (el.parentElement.classList.contains("input-group")) {
    el.parentElement.classList.remove("focused");
  }
}
function setAttributes(el, options) {
  Object.keys(options).forEach(function(attr) {
    el.setAttribute(attr, options[attr]);
  });
}
if (document.querySelectorAll(".input-group").length != 0) {
  allInputs = document.querySelectorAll("input.form-control");
  allInputs.forEach(
    (el) => setAttributes(el, {
      onfocus: "focused(this)",
      onfocusout: "defocused(this)"
    })
  );
}
var allInputs;
if (document.querySelector(".fixed-plugin")) {
  fixedPlugin = document.querySelector(".fixed-plugin");
  fixedPluginButton = document.querySelector(".fixed-plugin-button");
  fixedPluginButtonNav = document.querySelector(".fixed-plugin-button-nav");
  fixedPluginCard = document.querySelector(".fixed-plugin .card");
  fixedPluginCloseButton = document.querySelectorAll(
    ".fixed-plugin-close-button"
  );
  navbar = document.getElementById("navbarBlur");
  buttonNavbarFixed = document.getElementById("navbarFixed");
  if (fixedPluginButton) {
    fixedPluginButton.onclick = function() {
      if (!fixedPlugin.classList.contains("show")) {
        fixedPlugin.classList.add("show");
      } else {
        fixedPlugin.classList.remove("show");
      }
    };
  }
  if (fixedPluginButtonNav) {
    fixedPluginButtonNav.onclick = function() {
      if (!fixedPlugin.classList.contains("show")) {
        fixedPlugin.classList.add("show");
      } else {
        fixedPlugin.classList.remove("show");
      }
    };
  }
  fixedPluginCloseButton.forEach(function(el) {
    el.onclick = function() {
      fixedPlugin.classList.remove("show");
    };
  });
  document.querySelector("body").onclick = function(e4) {
    if (e4.target != fixedPluginButton && e4.target != fixedPluginButtonNav && e4.target.closest(".fixed-plugin .card") != fixedPluginCard) {
      fixedPlugin.classList.remove("show");
    }
  };
  if (navbar) {
    if (navbar.getAttribute("data-scroll") == "true" && buttonNavbarFixed) {
      buttonNavbarFixed.setAttribute("checked", "true");
    }
  }
}
var fixedPlugin;
var fixedPluginButton;
var fixedPluginButtonNav;
var fixedPluginCard;
var fixedPluginCloseButton;
var navbar;
var buttonNavbarFixed;
function sidebarColor(a4) {
  var parent = a4.parentElement.children;
  var color2 = a4.getAttribute("data-color");
  for (var i4 = 0; i4 < parent.length; i4++) {
    parent[i4].classList.remove("active");
  }
  if (!a4.classList.contains("active")) {
    a4.classList.add("active");
  } else {
    a4.classList.remove("active");
  }
  var sidebar = document.querySelector(".sidenav");
  sidebar.setAttribute("data-color", color2);
  if (document.querySelector("#sidenavCard")) {
    var sidenavCard = document.querySelector("#sidenavCard");
    let sidenavCardClasses = [
      "card",
      "card-background",
      "shadow-none",
      "card-background-mask-" + color2
    ];
    sidenavCard.className = "";
    sidenavCard.classList.add(...sidenavCardClasses);
    var sidenavCardIcon = document.querySelector("#sidenavCardIcon");
    let sidenavCardIconClasses = [
      "ni",
      "ni-diamond",
      "text-gradient",
      "text-lg",
      "top-0",
      "text-" + color2
    ];
    sidenavCardIcon.className = "";
    sidenavCardIcon.classList.add(...sidenavCardIconClasses);
  }
}
function sidebarType(a4) {
  var parent = a4.parentElement.children;
  var color2 = a4.getAttribute("data-class");
  var body2 = document.querySelector("body");
  var bodyWhite = document.querySelector("body:not(.dark-version)");
  var bodyDark = body2.classList.contains("dark-version");
  var colors2 = [];
  for (var i4 = 0; i4 < parent.length; i4++) {
    parent[i4].classList.remove("active");
    colors2.push(parent[i4].getAttribute("data-class"));
  }
  if (!a4.classList.contains("active")) {
    a4.classList.add("active");
  } else {
    a4.classList.remove("active");
  }
  var sidebar = document.querySelector(".sidenav");
  for (var i4 = 0; i4 < colors2.length; i4++) {
    sidebar.classList.remove(colors2[i4]);
  }
  sidebar.classList.add(color2);
  if (color2 == "bg-transparent" || color2 == "bg-white") {
    var textWhites = document.querySelectorAll(".sidenav .text-white");
    for (let i5 = 0; i5 < textWhites.length; i5++) {
      textWhites[i5].classList.remove("text-white");
      textWhites[i5].classList.add("text-dark");
    }
  } else {
    var textDarks = document.querySelectorAll(".sidenav .text-dark");
    for (let i5 = 0; i5 < textDarks.length; i5++) {
      textDarks[i5].classList.add("text-white");
      textDarks[i5].classList.remove("text-dark");
    }
  }
  if (color2 == "bg-transparent" && bodyDark) {
    var textDarks = document.querySelectorAll(".navbar-brand .text-dark");
    for (let i5 = 0; i5 < textDarks.length; i5++) {
      textDarks[i5].classList.add("text-white");
      textDarks[i5].classList.remove("text-dark");
    }
  }
  if ((color2 == "bg-transparent" || color2 == "bg-white") && bodyWhite) {
    var navbarBrand = document.querySelector(".navbar-brand-img");
    var navbarBrandImg = navbarBrand.src;
    if (navbarBrandImg.includes("logo-ct.png")) {
      var navbarBrandImgNew = navbarBrandImg.replace("logo-ct", "logo-ct-dark");
      navbarBrand.src = navbarBrandImgNew;
    }
  } else {
    var navbarBrand = document.querySelector(".navbar-brand-img");
    var navbarBrandImg = navbarBrand.src;
    if (navbarBrandImg.includes("logo-ct-dark.png")) {
      var navbarBrandImgNew = navbarBrandImg.replace("logo-ct-dark", "logo-ct");
      navbarBrand.src = navbarBrandImgNew;
    }
  }
  if (color2 == "bg-white" && bodyDark) {
    var navbarBrand = document.querySelector(".navbar-brand-img");
    var navbarBrandImg = navbarBrand.src;
    if (navbarBrandImg.includes("logo-ct.png")) {
      var navbarBrandImgNew = navbarBrandImg.replace("logo-ct", "logo-ct-dark");
      navbarBrand.src = navbarBrandImgNew;
    }
  }
}
function navbarFixed(el) {
  let classes = [
    "position-sticky",
    "blur",
    "shadow-blur",
    "mt-4",
    "left-auto",
    "top-1",
    "z-index-sticky"
  ];
  const navbar = document.getElementById("navbarBlur");
  if (!el.getAttribute("checked")) {
    navbar.classList.add(...classes);
    navbar.setAttribute("data-scroll", "true");
    navbarBlurOnScroll("navbarBlur");
    el.setAttribute("checked", "true");
  } else {
    navbar.classList.remove(...classes);
    navbar.setAttribute("data-scroll", "false");
    navbarBlurOnScroll("navbarBlur");
    el.removeAttribute("checked");
  }
}
function navbarMinimize(el) {
  var sidenavShow = document.getElementsByClassName("g-sidenav-show")[0];
  if (!el.getAttribute("checked")) {
    sidenavShow.classList.remove("g-sidenav-pinned");
    sidenavShow.classList.add("g-sidenav-hidden");
    el.setAttribute("checked", "true");
  } else {
    sidenavShow.classList.remove("g-sidenav-hidden");
    sidenavShow.classList.add("g-sidenav-pinned");
    el.removeAttribute("checked");
  }
}
function navbarBlurOnScroll(id2) {
  const navbar = document.getElementById(id2);
  let navbarScrollActive = navbar ? navbar.getAttribute("data-scroll") : false;
  let scrollDistance = 5;
  let classes = ["blur", "shadow-blur", "left-auto"];
  let toggleClasses = ["shadow-none"];
  if (navbarScrollActive == "true") {
    window.onscroll = debounce3(function() {
      if (window.scrollY > scrollDistance) {
        blurNavbar();
      } else {
        transparentNavbar();
      }
    }, 10);
  } else {
    window.onscroll = debounce3(function() {
      transparentNavbar();
    }, 10);
  }
  var isWindows = navigator.platform.indexOf("Win") > -1 ? true : false;
  if (isWindows) {
    var content = document.querySelector(".main-content");
    if (navbarScrollActive == "true") {
      content.addEventListener(
        "ps-scroll-y",
        debounce3(function() {
          if (content.scrollTop > scrollDistance) {
            blurNavbar();
          } else {
            transparentNavbar();
          }
        }, 10)
      );
    } else {
      content.addEventListener(
        "ps-scroll-y",
        debounce3(function() {
          transparentNavbar();
        }, 10)
      );
    }
  }
  function blurNavbar() {
    navbar.classList.add(...classes);
    navbar.classList.remove(...toggleClasses);
    toggleNavLinksColor("blur");
  }
  function transparentNavbar() {
    navbar.classList.remove(...classes);
    navbar.classList.add(...toggleClasses);
    toggleNavLinksColor("transparent");
  }
  function toggleNavLinksColor(type) {
    let navLinks = document.querySelectorAll(".navbar-main .nav-link");
    let navLinksToggler = document.querySelectorAll(
      ".navbar-main .sidenav-toggler-line"
    );
    if (type === "blur") {
      navLinks.forEach((element) => {
        element.classList.remove("text-body");
      });
      navLinksToggler.forEach((element) => {
        element.classList.add("bg-dark");
      });
    } else if (type === "transparent") {
      navLinks.forEach((element) => {
        element.classList.add("text-body");
      });
      navLinksToggler.forEach((element) => {
        element.classList.remove("bg-dark");
      });
    }
  }
}
function debounce3(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}
var total = document.querySelectorAll(".nav-pills");
function initNavs() {
  total.forEach(function(item, i4) {
    var moving_div = document.createElement("div");
    var li_active = item.querySelector(".nav-link.active");
    var tab = li_active.cloneNode();
    tab.innerHTML = "-";
    moving_div.classList.add("moving-tab", "position-absolute", "nav-link");
    moving_div.appendChild(tab);
    item.appendChild(moving_div);
    var list_length = item.getElementsByTagName("li").length;
    moving_div.style.padding = "0px";
    moving_div.style.transition = ".5s ease";
    let li2 = item.querySelector(".nav-link.active").parentElement;
    if (li2) {
      let nodes = Array.from(li2.closest("ul").children);
      let index4 = nodes.indexOf(li2) + 1;
      let sum = 0;
      if (item.classList.contains("flex-column")) {
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetHeight;
        }
        moving_div.style.transform = "translate3d(0px," + sum + "px, 0px)";
        moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
        moving_div.style.height = item.querySelector(
          "li:nth-child(" + j5 + ")"
        ).offsetHeight;
      } else {
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetWidth;
        }
        moving_div.style.transform = "translate3d(" + sum + "px, 0px, 0px)";
        moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
      }
    }
    item.onmouseover = function(event2) {
      let target = getEventTarget(event2);
      let li3 = target.closest("li");
      if (li3) {
        let nodes = Array.from(li3.closest("ul").children);
        let index4 = nodes.indexOf(li3) + 1;
        item.querySelector("li:nth-child(" + index4 + ") .nav-link").onclick = function() {
          moving_div = item.querySelector(".moving-tab");
          let sum = 0;
          if (item.classList.contains("flex-column")) {
            for (var j6 = 1; j6 <= nodes.indexOf(li3); j6++) {
              sum += item.querySelector(
                "li:nth-child(" + j6 + ")"
              ).offsetHeight;
            }
            moving_div.style.transform = "translate3d(0px," + sum + "px, 0px)";
            moving_div.style.height = item.querySelector(
              "li:nth-child(" + j6 + ")"
            ).offsetHeight;
          } else {
            for (var j6 = 1; j6 <= nodes.indexOf(li3); j6++) {
              sum += item.querySelector("li:nth-child(" + j6 + ")").offsetWidth;
            }
            moving_div.style.transform = "translate3d(" + sum + "px, 0px, 0px)";
            moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
          }
        };
      }
    };
  });
}
setTimeout(function() {
  initNavs();
}, 100);
window.addEventListener("resize", function(event2) {
  total.forEach(function(item, i4) {
    item.querySelector(".moving-tab").remove();
    var moving_div = document.createElement("div");
    var tab = item.querySelector(".nav-link.active").cloneNode();
    tab.innerHTML = "-";
    moving_div.classList.add("moving-tab", "position-absolute", "nav-link");
    moving_div.appendChild(tab);
    item.appendChild(moving_div);
    moving_div.style.padding = "0px";
    moving_div.style.transition = ".5s ease";
    let li2 = item.querySelector(".nav-link.active").parentElement;
    if (li2) {
      let nodes = Array.from(li2.closest("ul").children);
      let index4 = nodes.indexOf(li2) + 1;
      let sum = 0;
      if (item.classList.contains("flex-column")) {
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetHeight;
        }
        moving_div.style.transform = "translate3d(0px," + sum + "px, 0px)";
        moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
        moving_div.style.height = item.querySelector(
          "li:nth-child(" + j5 + ")"
        ).offsetHeight;
      } else {
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetWidth;
        }
        moving_div.style.transform = "translate3d(" + sum + "px, 0px, 0px)";
        moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
      }
    }
  });
  if (window.innerWidth < 991) {
    total.forEach(function(item, i4) {
      if (!item.classList.contains("flex-column")) {
        item.classList.remove("flex-row");
        item.classList.add("flex-column", "on-resize");
        let li2 = item.querySelector(".nav-link.active").parentElement;
        let nodes = Array.from(li2.closest("ul").children);
        let index4 = nodes.indexOf(li2) + 1;
        let sum = 0;
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetHeight;
        }
        var moving_div = document.querySelector(".moving-tab");
        moving_div.style.width = item.querySelector("li:nth-child(1)").offsetWidth + "px";
        moving_div.style.transform = "translate3d(0px," + sum + "px, 0px)";
      }
    });
  } else {
    total.forEach(function(item, i4) {
      if (item.classList.contains("on-resize")) {
        item.classList.remove("flex-column", "on-resize");
        item.classList.add("flex-row");
        let li2 = item.querySelector(".nav-link.active").parentElement;
        let nodes = Array.from(li2.closest("ul").children);
        let index4 = nodes.indexOf(li2) + 1;
        let sum = 0;
        for (var j5 = 1; j5 <= nodes.indexOf(li2); j5++) {
          sum += item.querySelector("li:nth-child(" + j5 + ")").offsetWidth;
        }
        var moving_div = document.querySelector(".moving-tab");
        moving_div.style.transform = "translate3d(" + sum + "px, 0px, 0px)";
        moving_div.style.width = item.querySelector("li:nth-child(" + index4 + ")").offsetWidth + "px";
      }
    });
  }
});
if (window.innerWidth < 991) {
  total.forEach(function(item, i4) {
    if (item.classList.contains("flex-row")) {
      item.classList.remove("flex-row");
      item.classList.add("flex-column", "on-resize");
    }
  });
}
function getEventTarget(e4) {
  e4 = e4 || window.event;
  return e4.target || e4.srcElement;
}
if (document.querySelector(".sidenav-toggler")) {
  sidenavToggler = document.getElementsByClassName("sidenav-toggler")[0];
  sidenavShow = document.getElementsByClassName("g-sidenav-show")[0];
  toggleNavbarMinimize = document.getElementById("navbarMinimize");
  if (sidenavShow) {
    sidenavToggler.onclick = function() {
      if (!sidenavShow.classList.contains("g-sidenav-hidden")) {
        sidenavShow.classList.remove("g-sidenav-pinned");
        sidenavShow.classList.add("g-sidenav-hidden");
        if (toggleNavbarMinimize) {
          toggleNavbarMinimize.click();
          toggleNavbarMinimize.setAttribute("checked", "true");
        }
      } else {
        sidenavShow.classList.remove("g-sidenav-hidden");
        sidenavShow.classList.add("g-sidenav-pinned");
        if (toggleNavbarMinimize) {
          toggleNavbarMinimize.click();
          toggleNavbarMinimize.removeAttribute("checked");
        }
      }
    };
  }
}
var sidenavToggler;
var sidenavShow;
var toggleNavbarMinimize;
var iconNavbarSidenav = document.getElementById("iconNavbarSidenav");
var iconSidenav = document.getElementById("iconSidenav");
var sidenav = document.getElementById("sidenav-main");
var body = document.getElementsByTagName("body")[0];
var className = "g-sidenav-pinned";
if (iconNavbarSidenav) {
  iconNavbarSidenav.addEventListener("click", toggleSidenav);
}
if (iconSidenav) {
  iconSidenav.addEventListener("click", toggleSidenav);
}
function toggleSidenav() {
  if (body.classList.contains(className)) {
    body.classList.remove(className);
    setTimeout(function() {
      sidenav.classList.remove("bg-white");
    }, 100);
    sidenav.classList.remove("bg-transparent");
  } else {
    body.classList.add(className);
    sidenav.classList.remove("bg-transparent");
    iconSidenav.classList.remove("d-none");
  }
}
var referenceButtons = document.querySelector("[data-class]");
window.addEventListener("resize", navbarColorOnResize);
function navbarColorOnResize() {
  if (sidenav) {
    if (window.innerWidth > 1200) {
      if (referenceButtons?.classList.contains("active") && referenceButtons?.getAttribute("data-class") === "bg-transparent") {
        sidenav.classList.remove("bg-white");
      } else {
        if (!document.querySelector("body").classList.contains("dark-version")) {
          sidenav.classList.add("bg-white");
        }
      }
    } else {
      sidenav.classList.remove("bg-transparent");
    }
  }
}
window.addEventListener("resize", sidenavTypeOnResize);
window.addEventListener("load", sidenavTypeOnResize);
function sidenavTypeOnResize() {
  let elements2 = document.querySelectorAll('[onclick="sidebarType(this)"]');
  if (window.innerWidth < 1200) {
    elements2.forEach(function(el) {
      el.classList.add("disabled");
    });
  } else {
    elements2.forEach(function(el) {
      el.classList.remove("disabled");
    });
  }
}
window.onload = function() {
  var inputs = document.querySelectorAll("input");
  for (var i4 = 0; i4 < inputs.length; i4++) {
    if (inputs[i4].hasAttribute("value")) {
      inputs[i4].parentElement.classList.add("is-filled");
    }
    inputs[i4].addEventListener(
      "focus",
      function(e4) {
        this.parentElement.classList.add("is-focused");
      },
      false
    );
    inputs[i4].onkeyup = function(e4) {
      if (this.value != "") {
        this.parentElement.classList.add("is-filled");
      } else {
        this.parentElement.classList.remove("is-filled");
      }
    };
    inputs[i4].addEventListener(
      "focusout",
      function(e4) {
        if (this.value != "") {
          this.parentElement.classList.add("is-filled");
        }
        this.parentElement.classList.remove("is-focused");
      },
      false
    );
  }
  var ripples = document.querySelectorAll(".btn");
  for (var i4 = 0; i4 < ripples.length; i4++) {
    ripples[i4].addEventListener(
      "click",
      function(e4) {
        var targetEl = e4.target;
        var rippleDiv = targetEl.querySelector(".ripple");
        rippleDiv = document.createElement("span");
        rippleDiv.classList.add("ripple");
        rippleDiv.style.width = rippleDiv.style.height = Math.max(targetEl.offsetWidth, targetEl.offsetHeight) + "px";
        targetEl.appendChild(rippleDiv);
        rippleDiv.style.left = e4.offsetX - rippleDiv.offsetWidth / 2 + "px";
        rippleDiv.style.top = e4.offsetY - rippleDiv.offsetHeight / 2 + "px";
        rippleDiv.classList.add("ripple");
        setTimeout(function() {
          rippleDiv.parentElement.removeChild(rippleDiv);
        }, 600);
      },
      false
    );
  }
};
function darkMode(el) {
  const body2 = document.getElementsByTagName("body")[0];
  const darkModeEnabled = body2.classList.contains("dark-version");
  const hr2 = document.querySelectorAll("div:not(.sidenav) > hr");
  const hr_card = document.querySelectorAll("div:not(.bg-gradient-dark) hr");
  const text_btn = document.querySelectorAll("button:not(.btn) > .text-dark");
  const text_span = document.querySelectorAll(
    "span.text-dark, .breadcrumb .text-dark"
  );
  const text_span_white = document.querySelectorAll(
    "span.text-white, .breadcrumb .text-white"
  );
  const text_strong = document.querySelectorAll("strong.text-dark");
  const text_strong_white = document.querySelectorAll("strong.text-white");
  const text_nav_link = document.querySelectorAll("a.nav-link.text-dark");
  const text_nav_link_white = document.querySelectorAll("a.nav-link.text-white");
  const secondary = document.querySelectorAll(".text-secondary");
  const bg_gray_100 = document.querySelectorAll(".bg-gray-100");
  const bg_gray_600 = document.querySelectorAll(".bg-gray-600");
  const btn_text_dark = document.querySelectorAll(
    ".btn.btn-link.text-dark, .material-symbols-rounded.text-dark"
  );
  const btn_text_white = document.querySelectorAll(
    ".btn.btn-link.text-white, .material-symbols-rounded.text-white"
  );
  const card_border = document.querySelectorAll(".card.border");
  const card_border_dark = document.querySelectorAll(".card.border.border-dark");
  const mainContent_blur = document.querySelectorAll(
    ".main-content .container-fluid .card"
  );
  const svg = document.querySelectorAll("g");
  const sidenavs = document.querySelectorAll(".sidenav");
  if (!el.getAttribute("checked")) {
    body2.classList.add("dark-version");
    for (var i4 = 0; i4 < hr2.length; i4++) {
      if (hr2[i4].classList.contains("dark")) {
        hr2[i4].classList.remove("dark");
        hr2[i4].classList.add("light");
      }
    }
    for (let i5 = 0; i5 < sidenavs.length; i5++) {
      const sidenav2 = sidenavs[i5];
      console.log(sidenav2);
      if (sidenav2.classList.contains("bg-white")) {
        sidenav2.classList.remove("bg-white");
        sidenav2.classList.add("bg-dark");
      }
    }
    for (var i4 = 0; i4 < mainContent_blur.length; i4++) {
      if (mainContent_blur[i4].classList.contains("blur")) {
        mainContent_blur[i4].classList.remove("blur", "shadow-blur");
      }
    }
    for (var i4 = 0; i4 < hr_card.length; i4++) {
      if (hr_card[i4].classList.contains("dark")) {
        hr_card[i4].classList.remove("dark");
        hr_card[i4].classList.add("light");
      }
    }
    for (var i4 = 0; i4 < text_btn.length; i4++) {
      if (text_btn[i4].classList.contains("text-dark")) {
        text_btn[i4].classList.remove("text-dark");
        text_btn[i4].classList.add("text-white");
      }
    }
    for (var i4 = 0; i4 < text_span.length; i4++) {
      if (text_span[i4].classList.contains("text-dark")) {
        text_span[i4].classList.remove("text-dark");
        text_span[i4].classList.add("text-white");
      }
    }
    for (var i4 = 0; i4 < text_strong.length; i4++) {
      if (text_strong[i4].classList.contains("text-dark")) {
        text_strong[i4].classList.remove("text-dark");
        text_strong[i4].classList.add("text-white");
      }
    }
    for (var i4 = 0; i4 < text_nav_link.length; i4++) {
      if (text_nav_link[i4].classList.contains("text-dark")) {
        text_nav_link[i4].classList.remove("text-dark");
        text_nav_link[i4].classList.add("text-white");
      }
    }
    for (var i4 = 0; i4 < secondary.length; i4++) {
      if (secondary[i4].classList.contains("text-secondary")) {
        secondary[i4].classList.remove("text-secondary");
        secondary[i4].classList.add("text-white");
        secondary[i4].classList.add("opacity-8");
      }
    }
    for (var i4 = 0; i4 < bg_gray_100.length; i4++) {
      if (bg_gray_100[i4].classList.contains("bg-gray-100")) {
        bg_gray_100[i4].classList.remove("bg-gray-100");
        bg_gray_100[i4].classList.add("bg-gray-600");
      }
    }
    for (var i4 = 0; i4 < btn_text_dark.length; i4++) {
      btn_text_dark[i4].classList.remove("text-dark");
      btn_text_dark[i4].classList.add("text-white");
    }
    for (var i4 = 0; i4 < svg.length; i4++) {
      if (svg[i4].hasAttribute("fill")) {
        svg[i4].setAttribute("fill", "#fff");
      }
    }
    for (var i4 = 0; i4 < card_border.length; i4++) {
      card_border[i4].classList.add("border-dark");
    }
    el.setAttribute("checked", "true");
  } else {
    body2.classList.remove("dark-version");
    for (var i4 = 0; i4 < hr2.length; i4++) {
      if (hr2[i4].classList.contains("light")) {
        hr2[i4].classList.add("dark");
        hr2[i4].classList.remove("light");
      }
    }
    for (let i5 = 0; i5 < sidenavs.length; i5++) {
      if (sidenav.classList.contains("bg-dark")) {
        sidenav.classList.remove("bg-dark");
        sidenav.classList.add("bg-white");
      }
    }
    for (var i4 = 0; i4 < hr_card.length; i4++) {
      if (hr_card[i4].classList.contains("light")) {
        hr_card[i4].classList.add("dark");
        hr_card[i4].classList.remove("light");
      }
    }
    for (var i4 = 0; i4 < mainContent_blur.length; i4++) {
      mainContent_blur[i4].classList.add("blur", "shadow-blur");
    }
    for (var i4 = 0; i4 < text_btn.length; i4++) {
      if (text_btn[i4].classList.contains("text-white")) {
        text_btn[i4].classList.remove("text-white");
        text_btn[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < text_span_white.length; i4++) {
      if (text_span_white[i4].classList.contains("text-white") && !text_span_white[i4].closest(".sidenav") && !text_span_white[i4].closest(".card.bg-gradient-dark")) {
        text_span_white[i4].classList.remove("text-white");
        text_span_white[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < text_strong_white.length; i4++) {
      if (text_strong_white[i4].classList.contains("text-white")) {
        text_strong_white[i4].classList.remove("text-white");
        text_strong_white[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < text_nav_link_white.length; i4++) {
      if (text_nav_link_white[i4].classList.contains("text-white") && !text_nav_link_white[i4].closest(".sidenav")) {
        text_nav_link_white[i4].classList.remove("text-white");
        text_nav_link_white[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < secondary.length; i4++) {
      if (secondary[i4].classList.contains("text-white")) {
        secondary[i4].classList.remove("text-white");
        secondary[i4].classList.remove("opacity-8");
        secondary[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < bg_gray_600.length; i4++) {
      if (bg_gray_600[i4].classList.contains("bg-gray-600")) {
        bg_gray_600[i4].classList.remove("bg-gray-600");
        bg_gray_600[i4].classList.add("bg-gray-100");
      }
    }
    for (var i4 = 0; i4 < svg.length; i4++) {
      if (svg[i4].hasAttribute("fill")) {
        svg[i4].setAttribute("fill", "#252f40");
      }
    }
    for (var i4 = 0; i4 < btn_text_white.length; i4++) {
      if (!btn_text_white[i4].closest(".card.bg-gradient-dark")) {
        btn_text_white[i4].classList.remove("text-white");
        btn_text_white[i4].classList.add("text-dark");
      }
    }
    for (var i4 = 0; i4 < card_border_dark.length; i4++) {
      card_border_dark[i4].classList.remove("border-dark");
    }
    el.removeAttribute("checked");
  }
  if (!darkModeEnabled) {
    body2.classList.add("dark-version");
    localStorage.setItem("darkMode", "enabled");
    el.setAttribute("checked", "true");
  } else {
    body2.classList.remove("dark-version");
    localStorage.setItem("darkMode", "disabled");
    el.removeAttribute("checked");
  }
}
if (document.querySelector(".datepicker")) {
  flatpickr(".datepicker", {
    mode: "range"
  });
}
var form = document.getElementById("form");
var username = document.getElementById("username");
var email = document.getElementById("email");
var password = document.getElementById("password");
var password2 = document.getElementById("confirm_password");
function showError(input, message) {
  const formControl = input.parentElement;
  formControl.className = "input-group input-group-outline my-5 is-invalid is-filled";
  const small = formControl.querySelector("small");
  small.innerText = message;
}
function showSucces(input) {
  const formControl = input.parentElement;
  formControl.className = "input-group input-group-outline my-5 is-valid is-filled";
}
function checkEmail(input) {
  const re2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  if (re2.test(input.value.trim())) {
    showSucces(input);
  } else {
    showError(input, "Email is not invalid");
  }
}
function checkRequired(inputArr) {
  inputArr.forEach(function(input) {
    if (input.value.trim() === "") {
      showError(input, `${getFieldName(input)} is required`);
    } else {
      showSucces(input);
    }
  });
}
function checkLength(input, min, max) {
  if (input.value.length < min) {
    showError(
      input,
      `${getFieldName(input)} must be at least ${min} characters`
    );
  } else if (input.value.length > max) {
    showError(
      input,
      `${getFieldName(input)} must be les than ${max} characters`
    );
  } else {
    showSucces(input);
  }
}
function getFieldName(input) {
  return input.id.charAt(0).toUpperCase() + input.id.slice(1);
}
function checkPasswordMatch(input1, input2) {
  if (input1.value !== input2.value) {
    showError(input2, "Passwords do not match");
  }
}
if (form) {
  form.addEventListener("submit", function(e4) {
    e4.preventDefault();
    checkRequired([username, email, password, password2]);
    checkLength(username, 3, 15);
    checkLength(password, 6, 25);
    checkEmail(email);
    checkPasswordMatch(password, password2);
  });
}
window.darkMode = darkMode;
window.navbarFixed = navbarFixed;
window.navbarMinimize = navbarMinimize;
window.focused = focused;
window.defocused = defocused;
window.sidebarColor = sidebarColor;
window.sidebarType = sidebarType;

// app/javascript/application.js
Rails.start();
turbo_es2017_esm_exports.session.drive = false;
document.addEventListener("turbo:load", function() {
  document.querySelectorAll(".dropdown-toggle").forEach((dropdown) => {
    new bootstrap.Dropdown(dropdown);
  });
});
document.addEventListener("turbo:load", function() {
  document.querySelectorAll('[data-bs-toggle="dropdown"]').forEach((dropdown) => {
    dropdown.addEventListener("show.bs.dropdown", function(event2) {
      const dropdownInstance = bootstrap.Dropdown.getOrCreateInstance(
        event2.target
      );
      if (dropdownInstance._popper && dropdownInstance._popper.state) {
        const preventOverflowModifier = dropdownInstance._popper.state.options.modifiers.find(
          (modifier) => modifier.name === "preventOverflow"
        );
        if (preventOverflowModifier) {
          preventOverflowModifier.enabled = false;
          dropdownInstance._popper.update();
        }
      }
    });
  });
  document.querySelectorAll(".dropdown-toggle").forEach((dropdownToggleEl) => {
    new bootstrap.Dropdown(dropdownToggleEl);
  });
});
document.addEventListener("DOMContentLoaded", function() {
  const darkModeToggle = document.getElementById("dark-version");
  const savedDarkMode = localStorage.getItem("darkMode");
  if (savedDarkMode === "enabled") {
    document.body.classList.add("dark-version");
    document.getElementById("sidenav-main").classList.remove("bg-white");
    document.getElementById("sidenav-main").classList.add("bg-dark");
    document.getElementById("sidenav-main").classList.add("bg-default");
    if (darkModeToggle) {
      darkModeToggle.setAttribute("checked", "true");
    }
  } else {
    document.body.classList.remove("dark-version");
    if (darkModeToggle) {
      darkModeToggle.removeAttribute("checked");
    }
  }
});
document.addEventListener("DOMContentLoaded", function() {
  document.addEventListener("submit", function(event2) {
    const form2 = event2.target;
    if (form2.tagName === "FORM") {
      document.body.classList.add("blurred");
      document.getElementById("page-loader").classList.add("show");
    }
  });
  document.querySelectorAll("[data-ai-suggestion]").forEach((button) => {
    button.addEventListener("click", function() {
      document.body.classList.add("blurred");
      document.getElementById("page-loader").classList.add("show");
    });
  });
  window.addEventListener("load", function() {
    document.body.classList.remove("blurred");
    document.getElementById("page-loader").classList.remove("show");
  });
  document.addEventListener("ajax:complete", function() {
    this.alert("finish fetching");
    document.body.classList.remove("blurred");
    document.getElementById("page-loader").classList.remove("show");
  });
});
document.addEventListener("turbo:load", function() {
  document.querySelectorAll(".moving-tab").forEach((el) => el.remove());
  document.querySelectorAll(".nav-pills").forEach(function(nav) {
    if (typeof initMovingTab === "function") {
      initMovingTab(nav);
      const activeTab = nav.querySelector(".nav-link.active");
      if (activeTab) activeTab.click();
    }
  });
});
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll(".moving-tab").forEach((el) => el.remove());
  document.querySelectorAll(".nav-pills").forEach(function(nav) {
    if (typeof initMovingTab === "function") {
      initMovingTab(nav);
      const activeTab = nav.querySelector(".nav-link.active");
      if (activeTab) activeTab.click();
    }
  });
});
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

bootstrap/dist/js/bootstrap.bundle.min.js:
  (*!
    * Bootstrap v5.3.3 (https://getbootstrap.com/)
    * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.12
  Copyright © 2024 37signals LLC
   *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.6
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.6
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

trix/dist/trix.esm.min.js:
  (*! @license DOMPurify 3.2.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.3/LICENSE *)
*/
//# sourceMappingURL=/assets/application.js.map
